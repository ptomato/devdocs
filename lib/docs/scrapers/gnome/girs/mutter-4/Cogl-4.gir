<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GL" version="1.0"/>
  <include name="GObject" version="2.0"/>
  <namespace name="Cogl"
             version="4"
             shared-library="libmutter-cogl-4.so.0"
             c:identifier-prefixes="Cogl"
             c:symbol-prefixes="cogl">
    <alias name="Angle" c:type="CoglAngle">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-types.h"
           line="128">Integer representation of an angle such that 1024 corresponds to
full circle (i.e., 2 * pi).</doc>
      <source-position filename="../cogl/cogl/cogl-types.h" line="136"/>
      <type name="gint32" c:type="int32_t"/>
    </alias>
    <alias name="Handle" c:type="CoglHandle">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-types.h"
           line="75">Type used for storing references to cogl objects, the CoglHandle is
a fully opaque type without any public data members.</doc>
      <source-position filename="../cogl/cogl/cogl-types.h" line="81"/>
      <type name="gpointer" c:type="void*"/>
    </alias>
    <alias name="UserDataDestroyCallback" c:type="CoglUserDataDestroyCallback">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-object.h"
           line="129">When associating private data with a #CoglObject a callback can be
given which will be called either if the object is destroyed or if
cogl_object_set_user_data() is called with NULL user_data for the
same key.</doc>
      <source-position filename="../cogl/cogl/cogl-object.h" line="141"/>
      <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
    </alias>
    <constant name="AFIRST_BIT" value="64" c:type="COGL_AFIRST_BIT">
      <source-position filename="../cogl/cogl/cogl-types.h" line="145"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="A_BIT" value="16" c:type="COGL_A_BIT">
      <source-position filename="../cogl/cogl/cogl-types.h" line="143"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <enumeration name="AttributeType" version="1.0" c:type="CoglAttributeType">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-types.h"
           line="587">Data types for the components of a vertex attribute.</doc>
      <source-position filename="../cogl/cogl/cogl-types.h" line="608"/>
      <member name="byte" value="5120" c:identifier="COGL_ATTRIBUTE_TYPE_BYTE">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="589">Data is the same size of a byte</doc>
      </member>
      <member name="unsigned_byte"
              value="5121"
              c:identifier="COGL_ATTRIBUTE_TYPE_UNSIGNED_BYTE">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="590">Data is the same size of an
  unsigned byte</doc>
      </member>
      <member name="short"
              value="5122"
              c:identifier="COGL_ATTRIBUTE_TYPE_SHORT">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="592">Data is the same size of a short integer</doc>
      </member>
      <member name="unsigned_short"
              value="5123"
              c:identifier="COGL_ATTRIBUTE_TYPE_UNSIGNED_SHORT">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="593">Data is the same size of
  an unsigned short integer</doc>
      </member>
      <member name="float"
              value="5126"
              c:identifier="COGL_ATTRIBUTE_TYPE_FLOAT">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="595">Data is the same size of a float</doc>
      </member>
    </enumeration>
    <constant name="BGR_BIT" value="32" c:type="COGL_BGR_BIT">
      <source-position filename="../cogl/cogl/cogl-types.h" line="144"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="Bitmap"
           c:symbol-prefix="bitmap"
           c:type="CoglBitmap"
           parent="Object"
           glib:type-name="CoglBitmap"
           glib:get-type="cogl_bitmap_get_gtype"
           glib:fundamental="1">
      <constructor name="new_for_data"
                   c:identifier="cogl_bitmap_new_for_data"
                   version="1.10"
                   introspectable="0"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-bitmap.h"
             line="148">Creates a bitmap using some existing data. The data is not copied
so the application must keep the buffer alive for the lifetime of
the #CoglBitmap. This can be used for example with
cogl_framebuffer_read_pixels_into_bitmap() to read data directly
into an application buffer with the specified rowstride.</doc>
        <source-position filename="../cogl/cogl/cogl-bitmap.h" line="169"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-bitmap.h"
               line="164">A new #CoglBitmap.</doc>
          <type name="Bitmap" c:type="CoglBitmap*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-bitmap.h"
                 line="150">A #CoglContext</doc>
            <type c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-bitmap.h"
                 line="151">The width of the bitmap.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-bitmap.h"
                 line="152">The height of the bitmap.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-bitmap.h"
                 line="153">The format of the pixel data.</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-bitmap.h"
                 line="154">The rowstride of the bitmap (the number of bytes from
  the start of one row of the bitmap to the next).</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-bitmap.h"
                 line="156">A pointer to the data. The bitmap will take ownership of this data.</doc>
            <type name="guint8" c:type="uint8_t*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_buffer"
                   c:identifier="cogl_bitmap_new_from_buffer"
                   version="1.8"
                   introspectable="0"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-bitmap.h"
             line="86">Wraps some image data that has been uploaded into a #CoglBuffer as
a #CoglBitmap. The data is not copied in this process.</doc>
        <source-position filename="../cogl/cogl/cogl-bitmap.h" line="106"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-bitmap.h"
               line="100">a #CoglBitmap encapsulating the given @buffer.</doc>
          <type name="Bitmap" c:type="CoglBitmap*"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-bitmap.h"
                 line="88">A #CoglBuffer containing image data</doc>
            <type c:type="CoglBuffer*"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-bitmap.h"
                 line="89">The #CoglPixelFormat defining the format of the image data
         in the given @buffer.</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-bitmap.h"
                 line="91">The width of the image data in the given @buffer.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-bitmap.h"
                 line="92">The height of the image data in the given @buffer.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-bitmap.h"
                 line="93">The rowstride in bytes of the image data in the given @buffer.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-bitmap.h"
                 line="94">The offset into the given @buffer to the first pixel that
         should be considered part of the #CoglBitmap.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_file"
                   c:identifier="cogl_bitmap_new_from_file"
                   version="1.0"
                   throws="1">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-bitmap.h"
             line="69">Loads an image file from disk. This function can be safely called from
within a thread.</doc>
        <source-position filename="../cogl/cogl/cogl-bitmap.h" line="83"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-bitmap.h"
               line="77">a #CoglBitmap to the new loaded
              image data, or %NULL if loading the image failed.</doc>
          <type name="Bitmap" c:type="CoglBitmap*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-bitmap.h"
                 line="71">the file to load.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_size"
                   c:identifier="cogl_bitmap_new_with_size"
                   version="1.10"
                   introspectable="0"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-bitmap.h"
             line="113">Creates a new #CoglBitmap with the given width, height and format.
The initial contents of the bitmap are undefined.

The data for the bitmap will be stored in a newly created
#CoglPixelBuffer. You can get a pointer to the pixel buffer using
cogl_bitmap_get_buffer(). The #CoglBuffer API can then be
used to fill the bitmap with data.

&lt;note&gt;Cogl will try its best to provide a hardware array you can
map, write into and effectively do a zero copy upload when creating
a texture from it with cogl_texture_new_from_bitmap(). For various
reasons, such arrays are likely to have a stride larger than width
* bytes_per_pixel. The user must take the stride into account when
writing into it. The stride can be retrieved with
cogl_bitmap_get_rowstride().&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/cogl-bitmap.h" line="143"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-bitmap.h"
               line="136">a #CoglPixelBuffer representing the
              newly created array or %NULL on failure</doc>
          <type name="Bitmap" c:type="CoglBitmap*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-bitmap.h"
                 line="115">A #CoglContext</doc>
            <type c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-bitmap.h"
                 line="116">width of the bitmap in pixels</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-bitmap.h"
                 line="117">height of the bitmap in pixels</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-bitmap.h"
                 line="118">the format of the pixels the array will store</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="error_quark" c:identifier="cogl_bitmap_error_quark">
        <source-position filename="../cogl/cogl/cogl-bitmap.h" line="299"/>
        <return-value transfer-ownership="none">
          <type name="guint32" c:type="uint32_t"/>
        </return-value>
      </function>
      <function name="get_size_from_file"
                c:identifier="cogl_bitmap_get_size_from_file"
                version="1.0">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-bitmap.h"
             line="236">Parses an image file enough to extract the width and height
of the bitmap.</doc>
        <source-position filename="../cogl/cogl/cogl-bitmap.h" line="250"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-bitmap.h"
               line="245">%TRUE if the image was successfully parsed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-bitmap.h"
                 line="238">the file to check</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="width"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-bitmap.h"
                 line="239">return location for the bitmap width, or %NULL</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
          <parameter name="height"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-bitmap.h"
                 line="240">return location for the bitmap height, or %NULL</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
        </parameters>
      </function>
      <method name="get_buffer"
              c:identifier="cogl_bitmap_get_buffer"
              version="1.10"
              introspectable="0"
              stability="Unstable">
        <source-position filename="../cogl/cogl/cogl-bitmap.h" line="234"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-bitmap.h"
               line="226">the #CoglPixelBuffer that this
  buffer uses for storage. Note that if the bitmap was created with
  cogl_bitmap_new_from_file() then it will not actually be using a
  pixel buffer and this function will return %NULL.</doc>
          <type c:type="CoglPixelBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="bitmap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-bitmap.h"
                 line="224">A #CoglBitmap</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_format"
              c:identifier="cogl_bitmap_get_format"
              version="1.10"
              stability="Unstable">
        <source-position filename="../cogl/cogl/cogl-bitmap.h" line="185"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-bitmap.h"
               line="180">the #CoglPixelFormat that the data for the bitmap is in.</doc>
          <type name="PixelFormat" c:type="CoglPixelFormat"/>
        </return-value>
        <parameters>
          <instance-parameter name="bitmap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-bitmap.h"
                 line="178">A #CoglBitmap</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_height"
              c:identifier="cogl_bitmap_get_height"
              version="1.10"
              stability="Unstable">
        <source-position filename="../cogl/cogl/cogl-bitmap.h" line="207"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-bitmap.h"
               line="202">the height of the bitmap</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="bitmap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-bitmap.h"
                 line="200">A #CoglBitmap</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_rowstride"
              c:identifier="cogl_bitmap_get_rowstride"
              version="1.10"
              stability="Unstable">
        <source-position filename="../cogl/cogl/cogl-bitmap.h" line="220"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-bitmap.h"
               line="213">the rowstride of the bitmap. This is the number of
  bytes between the address of start of one row to the address of the
  next row in the image.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="bitmap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-bitmap.h"
                 line="211">A #CoglBitmap</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_width"
              c:identifier="cogl_bitmap_get_width"
              version="1.10"
              stability="Unstable">
        <source-position filename="../cogl/cogl/cogl-bitmap.h" line="196"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-bitmap.h"
               line="191">the width of the bitmap</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="bitmap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-bitmap.h"
                 line="189">A #CoglBitmap</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <enumeration name="BitmapError" version="1.4" c:type="CoglBitmapError">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-bitmap.h"
           line="277">Error codes that can be thrown when performing bitmap
operations. Note that gdk_pixbuf_new_from_file() can also throw
errors directly from the underlying image loading library. For
example, if GdkPixbuf is used then errors #GdkPixbufError&lt;!-- --&gt;s
will be used directly.</doc>
      <source-position filename="../cogl/cogl/cogl-bitmap.h" line="297"/>
      <member name="failed" value="0" c:identifier="COGL_BITMAP_ERROR_FAILED">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-bitmap.h"
             line="279">Generic failure code, something went
  wrong.</doc>
      </member>
      <member name="unknown_type"
              value="1"
              c:identifier="COGL_BITMAP_ERROR_UNKNOWN_TYPE">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-bitmap.h"
             line="281">Unknown image type.</doc>
      </member>
      <member name="corrupt_image"
              value="2"
              c:identifier="COGL_BITMAP_ERROR_CORRUPT_IMAGE">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-bitmap.h"
             line="282">An image file was broken somehow.</doc>
      </member>
    </enumeration>
    <enumeration name="BlendStringError"
                 version="1.0"
                 c:type="CoglBlendStringError">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-types.h"
           line="523">Error enumeration for the blend strings parser</doc>
      <source-position filename="../cogl/cogl/cogl-types.h" line="541"/>
      <member name="parse_error"
              value="0"
              c:identifier="COGL_BLEND_STRING_ERROR_PARSE_ERROR">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="525">Generic parse error</doc>
      </member>
      <member name="argument_parse_error"
              value="1"
              c:identifier="COGL_BLEND_STRING_ERROR_ARGUMENT_PARSE_ERROR">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="526">Argument parse error</doc>
      </member>
      <member name="invalid_error"
              value="2"
              c:identifier="COGL_BLEND_STRING_ERROR_INVALID_ERROR">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="527">Internal parser error</doc>
      </member>
      <member name="gpu_unsupported_error"
              value="3"
              c:identifier="COGL_BLEND_STRING_ERROR_GPU_UNSUPPORTED_ERROR">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="528">Blend string not
  supported by the GPU</doc>
      </member>
    </enumeration>
    <bitfield name="BufferBit" version="1.0" c:type="CoglBufferBit">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-types.h"
           line="817">Types of auxiliary buffers</doc>
      <source-position filename="../cogl/cogl/cogl-types.h" line="832"/>
      <member name="color" value="1" c:identifier="COGL_BUFFER_BIT_COLOR">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="819">Selects the primary color buffer</doc>
      </member>
      <member name="depth" value="2" c:identifier="COGL_BUFFER_BIT_DEPTH">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="820">Selects the depth buffer</doc>
      </member>
      <member name="stencil" value="4" c:identifier="COGL_BUFFER_BIT_STENCIL">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="821">Selects the stencil buffer</doc>
      </member>
    </bitfield>
    <bitfield name="BufferTarget" version="0.8" c:type="CoglBufferTarget">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-types.h"
           line="389">Target flags for FBOs.</doc>
      <source-position filename="../cogl/cogl/cogl-types.h" line="402"/>
      <member name="window_buffer" value="2" c:identifier="COGL_WINDOW_BUFFER">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="391">FIXME</doc>
      </member>
      <member name="offscreen_buffer"
              value="4"
              c:identifier="COGL_OFFSCREEN_BUFFER">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="392">FIXME</doc>
      </member>
    </bitfield>
    <record name="Color"
            c:type="CoglColor"
            version="1.0"
            glib:type-name="CoglColor"
            glib:get-type="cogl_color_get_gtype"
            c:symbol-prefix="color">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-types.h"
           line="404">A structure for holding a color definition. The contents of
the CoglColor structure are private and should never by accessed
directly.</doc>
      <source-position filename="../cogl/cogl/cogl-types.h" line="431"/>
      <field name="private_member_red" readable="0" private="1">
        <type name="guint8" c:type="uint8_t"/>
      </field>
      <field name="private_member_green" readable="0" private="1">
        <type name="guint8" c:type="uint8_t"/>
      </field>
      <field name="private_member_blue" readable="0" private="1">
        <type name="guint8" c:type="uint8_t"/>
      </field>
      <field name="private_member_alpha" readable="0" private="1">
        <type name="guint8" c:type="uint8_t"/>
      </field>
      <field name="private_member_padding0" readable="0" private="1">
        <type name="guint32" c:type="uint32_t"/>
      </field>
      <field name="private_member_padding1" readable="0" private="1">
        <type name="guint32" c:type="uint32_t"/>
      </field>
      <field name="private_member_padding2" readable="0" private="1">
        <type name="guint32" c:type="uint32_t"/>
      </field>
      <constructor name="new" c:identifier="cogl_color_new" version="1.0">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-color.h"
             line="62">Creates a new (empty) color</doc>
        <source-position filename="../cogl/cogl/cogl-color.h" line="73"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-color.h"
               line="67">a newly-allocated #CoglColor. Use cogl_color_free()
  to free the allocated resources</doc>
          <type name="Color" c:type="CoglColor*"/>
        </return-value>
      </constructor>
      <method name="copy" c:identifier="cogl_color_copy" version="1.0">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-color.h"
             line="75">Creates a copy of @color</doc>
        <source-position filename="../cogl/cogl/cogl-color.h" line="87"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-color.h"
               line="81">a newly-allocated #CoglColor. Use cogl_color_free()
  to free the allocate resources</doc>
          <type name="Color" c:type="CoglColor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="77">the color to copy</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="cogl_color_free" version="1.0">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-color.h"
             line="89">Frees the resources allocated by cogl_color_new() and cogl_color_copy()</doc>
        <source-position filename="../cogl/cogl/cogl-color.h" line="98"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="91">the color to free</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_alpha"
              c:identifier="cogl_color_get_alpha"
              version="1.0">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-color.h"
             line="347">Retrieves the alpha channel of @color as a fixed point
value between 0 and 1.0.</doc>
        <source-position filename="../cogl/cogl/cogl-color.h" line="359"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-color.h"
               line="354">the alpha channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="349">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_alpha_byte"
              c:identifier="cogl_color_get_alpha_byte"
              version="1.0">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-color.h"
             line="235">Retrieves the alpha channel of @color as a byte value
between 0 and 255</doc>
        <source-position filename="../cogl/cogl/cogl-color.h" line="247"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-color.h"
               line="242">the alpha channel of the passed color</doc>
          <type name="guint8" c:type="unsigned char"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="237">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_alpha_float"
              c:identifier="cogl_color_get_alpha_float"
              version="1.0">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-color.h"
             line="291">Retrieves the alpha channel of @color as a floating point
value between 0.0 and 1.0</doc>
        <source-position filename="../cogl/cogl/cogl-color.h" line="303"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-color.h"
               line="298">the alpha channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="293">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_blue" c:identifier="cogl_color_get_blue" version="1.0">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-color.h"
             line="333">Retrieves the blue channel of @color as a fixed point
value between 0 and 1.0.</doc>
        <source-position filename="../cogl/cogl/cogl-color.h" line="345"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-color.h"
               line="340">the blue channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="335">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_blue_byte"
              c:identifier="cogl_color_get_blue_byte"
              version="1.0">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-color.h"
             line="221">Retrieves the blue channel of @color as a byte value
between 0 and 255</doc>
        <source-position filename="../cogl/cogl/cogl-color.h" line="233"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-color.h"
               line="228">the blue channel of the passed color</doc>
          <type name="guint8" c:type="unsigned char"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="223">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_blue_float"
              c:identifier="cogl_color_get_blue_float"
              version="1.0">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-color.h"
             line="277">Retrieves the blue channel of @color as a floating point
value between 0.0 and 1.0</doc>
        <source-position filename="../cogl/cogl/cogl-color.h" line="289"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-color.h"
               line="284">the blue channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="279">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_green"
              c:identifier="cogl_color_get_green"
              version="1.0">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-color.h"
             line="319">Retrieves the green channel of @color as a fixed point
value between 0 and 1.0.</doc>
        <source-position filename="../cogl/cogl/cogl-color.h" line="331"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-color.h"
               line="326">the green channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="321">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_green_byte"
              c:identifier="cogl_color_get_green_byte"
              version="1.0">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-color.h"
             line="207">Retrieves the green channel of @color as a byte value
between 0 and 255</doc>
        <source-position filename="../cogl/cogl/cogl-color.h" line="219"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-color.h"
               line="214">the green channel of the passed color</doc>
          <type name="guint8" c:type="unsigned char"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="209">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_green_float"
              c:identifier="cogl_color_get_green_float"
              version="1.0">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-color.h"
             line="263">Retrieves the green channel of @color as a floating point
value between 0.0 and 1.0</doc>
        <source-position filename="../cogl/cogl/cogl-color.h" line="275"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-color.h"
               line="270">the green channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="265">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_red" c:identifier="cogl_color_get_red" version="1.0">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-color.h"
             line="305">Retrieves the red channel of @color as a fixed point
value between 0 and 1.0.</doc>
        <source-position filename="../cogl/cogl/cogl-color.h" line="317"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-color.h"
               line="312">the red channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="307">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_red_byte"
              c:identifier="cogl_color_get_red_byte"
              version="1.0">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-color.h"
             line="193">Retrieves the red channel of @color as a byte value
between 0 and 255</doc>
        <source-position filename="../cogl/cogl/cogl-color.h" line="205"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-color.h"
               line="200">the red channel of the passed color</doc>
          <type name="guint8" c:type="unsigned char"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="195">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_red_float"
              c:identifier="cogl_color_get_red_float"
              version="1.0">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-color.h"
             line="249">Retrieves the red channel of @color as a floating point
value between 0.0 and 1.0</doc>
        <source-position filename="../cogl/cogl/cogl-color.h" line="261"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-color.h"
               line="256">the red channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="251">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init_from_4f"
              c:identifier="cogl_color_init_from_4f"
              version="1.4">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-color.h"
             line="140">Sets the values of the passed channels into a #CoglColor</doc>
        <source-position filename="../cogl/cogl/cogl-color.h" line="153"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="142">A pointer to a #CoglColor to initialize</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="143">value of the red channel, between 0 and 1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="144">value of the green channel, between 0 and 1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="145">value of the blue channel, between 0 and 1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="146">value of the alpha channel, between 0 and 1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_4fv"
              c:identifier="cogl_color_init_from_4fv"
              version="1.4">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-color.h"
             line="180">Sets the values of the passed channels into a #CoglColor</doc>
        <source-position filename="../cogl/cogl/cogl-color.h" line="190"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="182">A pointer to a #CoglColor to initialize</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="color_array" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="183">a pointer to an array of 4 float color components</doc>
            <type name="gfloat" c:type="const float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_4ub"
              c:identifier="cogl_color_init_from_4ub"
              version="1.4">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-color.h"
             line="100">Sets the values of the passed channels into a #CoglColor.</doc>
        <source-position filename="../cogl/cogl/cogl-color.h" line="113"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="102">A pointer to a #CoglColor to initialize</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="103">value of the red channel, between 0 and 255</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="104">value of the green channel, between 0 and 255</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="105">value of the blue channel, between 0 and 255</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="106">value of the alpha channel, between 0 and 255</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="premultiply"
              c:identifier="cogl_color_premultiply"
              version="1.0">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-color.h"
             line="517">Converts a non-premultiplied color to a pre-multiplied color. For
example, semi-transparent red is (1.0, 0, 0, 0.5) when non-premultiplied
and (0.5, 0, 0, 0.5) when premultiplied.</doc>
        <source-position filename="../cogl/cogl/cogl-color.h" line="528"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="519">the color to premultiply</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_alpha"
              c:identifier="cogl_color_set_alpha"
              version="1.4">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-color.h"
             line="504">Sets the alpha channel of @color to @alpha.</doc>
        <source-position filename="../cogl/cogl/cogl-color.h" line="514"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="506">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="507">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_alpha_byte"
              c:identifier="cogl_color_set_alpha_byte"
              version="1.4">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-color.h"
             line="400">Sets the alpha channel of @color to @alpha.</doc>
        <source-position filename="../cogl/cogl/cogl-color.h" line="410"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="402">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="403">a byte value between 0 and 255</doc>
            <type name="guint8" c:type="unsigned char"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_alpha_float"
              c:identifier="cogl_color_set_alpha_float"
              version="1.4">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-color.h"
             line="452">Sets the alpha channel of @color to @alpha.</doc>
        <source-position filename="../cogl/cogl/cogl-color.h" line="462"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="454">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="455">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blue" c:identifier="cogl_color_set_blue" version="1.4">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-color.h"
             line="491">Sets the blue channel of @color to @blue.</doc>
        <source-position filename="../cogl/cogl/cogl-color.h" line="501"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="493">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="494">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blue_byte"
              c:identifier="cogl_color_set_blue_byte"
              version="1.4">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-color.h"
             line="387">Sets the blue channel of @color to @blue.</doc>
        <source-position filename="../cogl/cogl/cogl-color.h" line="397"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="389">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="390">a byte value between 0 and 255</doc>
            <type name="guint8" c:type="unsigned char"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blue_float"
              c:identifier="cogl_color_set_blue_float"
              version="1.4">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-color.h"
             line="439">Sets the blue channel of @color to @blue.</doc>
        <source-position filename="../cogl/cogl/cogl-color.h" line="449"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="441">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="442">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_from_4f"
              c:identifier="cogl_color_set_from_4f"
              version="1.0"
              deprecated="1"
              deprecated-version="1.4">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-color.h"
             line="159">Sets the values of the passed channels into a #CoglColor</doc>
        <doc-deprecated xml:space="preserve">Use cogl_color_init_from_4f instead.</doc-deprecated>
        <source-position filename="../cogl/cogl/cogl-color.h" line="174"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="161">A pointer to a #CoglColor to initialize</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="162">value of the red channel, between 0 and %1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="163">value of the green channel, between 0 and %1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="164">value of the blue channel, between 0 and %1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="165">value of the alpha channel, between 0 and %1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_from_4ub"
              c:identifier="cogl_color_set_from_4ub"
              version="1.0"
              deprecated="1"
              deprecated-version="1.4">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-color.h"
             line="119">Sets the values of the passed channels into a #CoglColor.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_color_init_from_4ub instead.</doc-deprecated>
        <source-position filename="../cogl/cogl/cogl-color.h" line="134"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="121">A pointer to a #CoglColor to initialize</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="122">value of the red channel, between 0 and 255</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="123">value of the green channel, between 0 and 255</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="124">value of the blue channel, between 0 and 255</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="125">value of the alpha channel, between 0 and 255</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_green"
              c:identifier="cogl_color_set_green"
              version="1.4">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-color.h"
             line="478">Sets the green channel of @color to @green.</doc>
        <source-position filename="../cogl/cogl/cogl-color.h" line="488"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="480">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="481">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_green_byte"
              c:identifier="cogl_color_set_green_byte"
              version="1.4">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-color.h"
             line="374">Sets the green channel of @color to @green.</doc>
        <source-position filename="../cogl/cogl/cogl-color.h" line="384"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="376">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="377">a byte value between 0 and 255</doc>
            <type name="guint8" c:type="unsigned char"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_green_float"
              c:identifier="cogl_color_set_green_float"
              version="1.4">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-color.h"
             line="426">Sets the green channel of @color to @green.</doc>
        <source-position filename="../cogl/cogl/cogl-color.h" line="436"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="428">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="429">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_red" c:identifier="cogl_color_set_red" version="1.4">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-color.h"
             line="465">Sets the red channel of @color to @red.</doc>
        <source-position filename="../cogl/cogl/cogl-color.h" line="475"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="467">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="468">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_red_byte"
              c:identifier="cogl_color_set_red_byte"
              version="1.4">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-color.h"
             line="361">Sets the red channel of @color to @red.</doc>
        <source-position filename="../cogl/cogl/cogl-color.h" line="371"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="363">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="364">a byte value between 0 and 255</doc>
            <type name="guint8" c:type="unsigned char"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_red_float"
              c:identifier="cogl_color_set_red_float"
              version="1.4">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-color.h"
             line="413">Sets the red channel of @color to @red.</doc>
        <source-position filename="../cogl/cogl/cogl-color.h" line="423"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="415">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="416">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_hsl" c:identifier="cogl_color_to_hsl" version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-color.h"
             line="560">Converts @color to the HLS format.

The @hue value is in the 0 .. 360 range. The @luminance and
@saturation values are in the 0 .. 1 range.</doc>
        <source-position filename="../cogl/cogl/cogl-color.h" line="575"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="562">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
          <parameter name="hue"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="563">return location for the hue value or %NULL</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="saturation"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="564">return location for the saturation value or %NULL</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="luminance"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="565">return location for the luminance value or %NULL</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unpremultiply"
              c:identifier="cogl_color_unpremultiply"
              version="1.4">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-color.h"
             line="530">Converts a pre-multiplied color to a non-premultiplied color. For
example, semi-transparent red is (0.5, 0, 0, 0.5) when premultiplied
and (1.0, 0, 0, 0.5) when non-premultiplied.</doc>
        <source-position filename="../cogl/cogl/cogl-color.h" line="541"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="532">the color to unpremultiply</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="equal" c:identifier="cogl_color_equal" version="1.0">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-color.h"
             line="543">Compares two #CoglColor&lt;!-- --&gt;s and checks if they are the same.

This function can be passed to g_hash_table_new() as the @key_equal_func
parameter, when using #CoglColor&lt;!-- --&gt;s as keys in a #GHashTable.</doc>
        <source-position filename="../cogl/cogl/cogl-color.h" line="558"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-color.h"
               line="553">%TRUE if the two colors are the same.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="v1"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="545">a #CoglColor</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="v2"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="546">a #CoglColor</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
      <function name="init_from_hsl"
                c:identifier="cogl_color_init_from_hsl"
                version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-color.h"
             line="580">Converts a color expressed in HLS (hue, luminance and saturation)
values into a #CoglColor.</doc>
        <source-position filename="../cogl/cogl/cogl-color.h" line="593"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="color"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="582">return location for a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
          <parameter name="hue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="583">hue value, in the 0 .. 360 range</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="saturation" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="584">saturation value, in the 0 .. 1 range</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="luminance" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-color.h"
                 line="585">luminance value, in the 0 .. 1 range</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <bitfield name="ColorMask" c:type="CoglColorMask">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-types.h"
           line="776">Defines a bit mask of color channels. This can be used with
cogl_pipeline_set_color_mask() for example to define which color
channels should be written to the current framebuffer when
drawing something.</doc>
      <source-position filename="../cogl/cogl/cogl-types.h" line="800"/>
      <member name="none" value="0" c:identifier="COGL_COLOR_MASK_NONE">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="778">None of the color channels are masked</doc>
      </member>
      <member name="red" value="1" c:identifier="COGL_COLOR_MASK_RED">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="779">Masks the red color channel</doc>
      </member>
      <member name="green" value="2" c:identifier="COGL_COLOR_MASK_GREEN">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="780">Masks the green color channel</doc>
      </member>
      <member name="blue" value="4" c:identifier="COGL_COLOR_MASK_BLUE">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="781">Masks the blue color channel</doc>
      </member>
      <member name="alpha" value="8" c:identifier="COGL_COLOR_MASK_ALPHA">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="782">Masks the alpha color channel</doc>
      </member>
      <member name="all" value="15" c:identifier="COGL_COLOR_MASK_ALL">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="783">All of the color channels are masked</doc>
      </member>
    </bitfield>
    <constant name="DEPTH_BIT" value="256" c:type="COGL_DEPTH_BIT">
      <source-position filename="../cogl/cogl/cogl-types.h" line="147"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <callback name="DebugObjectForeachTypeCallback"
              c:type="CoglDebugObjectForeachTypeCallback"
              version="1.8"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-object.h"
           line="160">A callback function to use for cogl_debug_object_foreach_type().</doc>
      <source-position filename="../cogl/cogl/cogl-object.h" line="170"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-object.h"
               line="162">A pointer to a struct containing information about the type.</doc>
          <type name="DebugObjectTypeInfo"
                c:type="const CoglDebugObjectTypeInfo*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="DebugObjectTypeInfo"
            c:type="CoglDebugObjectTypeInfo"
            version="1.8"
            stability="Unstable">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-object.h"
           line="143">This struct is used to pass information to the callback when
cogl_debug_object_foreach_type() is called.</doc>
      <source-position filename="../cogl/cogl/cogl-object.h" line="158"/>
      <field name="name" writable="1">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-object.h"
             line="145">A human readable name for the type.</doc>
        <type name="utf8" c:type="const char*"/>
      </field>
      <field name="instance_count" writable="1">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-object.h"
             line="146">The number of objects of this type that are
  currently in use</doc>
        <type name="gulong" c:type="unsigned long"/>
      </field>
    </record>
    <enumeration name="DepthTestFunction" c:type="CoglDepthTestFunction">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-types.h"
           line="670">When using depth testing one of these functions is used to compare
the depth of an incoming fragment against the depth value currently
stored in the depth buffer. The function is changed using
cogl_depth_state_set_test_function().

The test is only done when depth testing is explicitly enabled. (See
cogl_depth_state_set_test_enabled())</doc>
      <source-position filename="../cogl/cogl/cogl-types.h" line="705"/>
      <member name="never"
              value="512"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_NEVER">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="672">Never passes.</doc>
      </member>
      <member name="less"
              value="513"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_LESS">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="673">Passes if the fragment's depth
value is less than the value currently in the depth buffer.</doc>
      </member>
      <member name="equal"
              value="514"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_EQUAL">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="675">Passes if the fragment's depth
value is equal to the value currently in the depth buffer.</doc>
      </member>
      <member name="lequal"
              value="515"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_LEQUAL">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="677">Passes if the fragment's depth
value is less or equal to the value currently in the depth buffer.</doc>
      </member>
      <member name="greater"
              value="516"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_GREATER">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="679">Passes if the fragment's depth
value is greater than the value currently in the depth buffer.</doc>
      </member>
      <member name="notequal"
              value="517"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_NOTEQUAL">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="681">Passes if the fragment's depth
value is not equal to the value currently in the depth buffer.</doc>
      </member>
      <member name="gequal"
              value="518"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_GEQUAL">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="683">Passes if the fragment's depth
value greater than or equal to the value currently in the depth buffer.</doc>
      </member>
      <member name="always"
              value="519"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_ALWAYS">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="685">Always passes.</doc>
      </member>
    </enumeration>
    <record name="Euler" c:type="CoglEuler" disguised="1">
      <source-position filename="../cogl/cogl/cogl-types.h" line="126"/>
    </record>
    <bitfield name="FeatureFlags" version="0.8" c:type="CoglFeatureFlags">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-types.h"
           line="316">Flags for the supported features.</doc>
      <source-position filename="../cogl/cogl/cogl-types.h" line="387"/>
      <member name="texture_rectangle"
              value="2"
              c:identifier="COGL_FEATURE_TEXTURE_RECTANGLE">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="318">ARB_texture_rectangle support</doc>
      </member>
      <member name="texture_npot"
              value="4"
              c:identifier="COGL_FEATURE_TEXTURE_NPOT">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="319">Non power of two textures are supported
   by the hardware. This is a equivalent to the
   %COGL_FEATURE_TEXTURE_NPOT_BASIC, %COGL_FEATURE_TEXTURE_NPOT_MIPMAP
   and %COGL_FEATURE_TEXTURE_NPOT_REPEAT features combined.</doc>
      </member>
      <member name="texture_yuv"
              value="8"
              c:identifier="COGL_FEATURE_TEXTURE_YUV">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="323">ycbcr conversion support</doc>
      </member>
      <member name="texture_read_pixels"
              value="16"
              c:identifier="COGL_FEATURE_TEXTURE_READ_PIXELS">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="324">glReadPixels() support</doc>
      </member>
      <member name="shaders_glsl"
              value="32"
              c:identifier="COGL_FEATURE_SHADERS_GLSL">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="325">GLSL support</doc>
      </member>
      <member name="offscreen"
              value="64"
              c:identifier="COGL_FEATURE_OFFSCREEN">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="326">FBO support</doc>
      </member>
      <member name="offscreen_multisample"
              value="128"
              c:identifier="COGL_FEATURE_OFFSCREEN_MULTISAMPLE">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="327">Multisample support on FBOs</doc>
      </member>
      <member name="offscreen_blit"
              value="256"
              c:identifier="COGL_FEATURE_OFFSCREEN_BLIT">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="328">Blit support on FBOs</doc>
      </member>
      <member name="four_clip_planes"
              value="512"
              c:identifier="COGL_FEATURE_FOUR_CLIP_PLANES">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="329">At least 4 clip planes available</doc>
      </member>
      <member name="stencil_buffer"
              value="1024"
              c:identifier="COGL_FEATURE_STENCIL_BUFFER">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="330">Stencil buffer support</doc>
      </member>
      <member name="vbos" value="2048" c:identifier="COGL_FEATURE_VBOS">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="331">VBO support</doc>
      </member>
      <member name="pbos" value="4096" c:identifier="COGL_FEATURE_PBOS">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="332">PBO support</doc>
      </member>
      <member name="unsigned_int_indices"
              value="8192"
              c:identifier="COGL_FEATURE_UNSIGNED_INT_INDICES">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="333">Set if
    %COGL_INDICES_TYPE_UNSIGNED_INT is supported in
    cogl_vertex_buffer_indices_new().</doc>
      </member>
      <member name="depth_range"
              value="16384"
              c:identifier="COGL_FEATURE_DEPTH_RANGE">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="336">cogl_material_set_depth_range() support</doc>
      </member>
      <member name="texture_npot_basic"
              value="32768"
              c:identifier="COGL_FEATURE_TEXTURE_NPOT_BASIC">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="337">The hardware supports non power
    of two textures, but you also need to check the
    %COGL_FEATURE_TEXTURE_NPOT_MIPMAP and %COGL_FEATURE_TEXTURE_NPOT_REPEAT
    features to know if the hardware supports npot texture mipmaps
    or repeat modes other than
    %COGL_PIPELINE_WRAP_MODE_CLAMP_TO_EDGE respectively.</doc>
      </member>
      <member name="texture_npot_mipmap"
              value="65536"
              c:identifier="COGL_FEATURE_TEXTURE_NPOT_MIPMAP">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="343">Mipmapping is supported in
    conjuntion with non power of two textures.</doc>
      </member>
      <member name="texture_npot_repeat"
              value="131072"
              c:identifier="COGL_FEATURE_TEXTURE_NPOT_REPEAT">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="345">Repeat modes other than
    %COGL_PIPELINE_WRAP_MODE_CLAMP_TO_EDGE are supported by the
    hardware.</doc>
      </member>
      <member name="point_sprite"
              value="262144"
              c:identifier="COGL_FEATURE_POINT_SPRITE">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="348">Whether
    cogl_material_set_layer_point_sprite_coords_enabled() is supported.</doc>
      </member>
      <member name="texture_3d"
              value="524288"
              c:identifier="COGL_FEATURE_TEXTURE_3D">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="350">3D texture support</doc>
      </member>
      <member name="map_buffer_for_read"
              value="2097152"
              c:identifier="COGL_FEATURE_MAP_BUFFER_FOR_READ">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="351">Whether cogl_buffer_map() is
    supported with CoglBufferAccess including read support.</doc>
      </member>
      <member name="map_buffer_for_write"
              value="4194304"
              c:identifier="COGL_FEATURE_MAP_BUFFER_FOR_WRITE">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="353">Whether cogl_buffer_map() is
    supported with CoglBufferAccess including write support.</doc>
      </member>
      <member name="onscreen_multiple"
              value="8388608"
              c:identifier="COGL_FEATURE_ONSCREEN_MULTIPLE">
      </member>
      <member name="depth_texture"
              value="16777216"
              c:identifier="COGL_FEATURE_DEPTH_TEXTURE">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="355">Whether #CoglFramebuffer support rendering the
    depth buffer to a texture.</doc>
      </member>
    </bitfield>
    <enumeration name="FilterReturn"
                 stability="Unstable"
                 c:type="CoglFilterReturn">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-types.h"
           line="714">Return values for the #CoglXlibFilterFunc and #CoglWin32FilterFunc functions.</doc>
      <source-position filename="../cogl/cogl/cogl-types.h" line="727"/>
      <member name="continue" value="0" c:identifier="COGL_FILTER_CONTINUE">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="716">The event was not handled, continues the
                       processing</doc>
      </member>
      <member name="remove" value="1" c:identifier="COGL_FILTER_REMOVE">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="718">Remove the event, stops the processing</doc>
      </member>
    </enumeration>
    <enumeration name="FogMode" version="1.0" c:type="CoglFogMode">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-types.h"
           line="479">The fog mode determines the equation used to calculate the fogging blend
factor while fogging is enabled. The simplest %COGL_FOG_MODE_LINEAR mode
determines f as:

|[
  f = end - eye_distance / end - start
]|

Where eye_distance is the distance of the current fragment in eye
coordinates from the origin.</doc>
      <source-position filename="../cogl/cogl/cogl-types.h" line="512"/>
      <member name="linear" value="0" c:identifier="COGL_FOG_MODE_LINEAR">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="481">Calculates the fog blend factor as:
|[
  f = end - eye_distance / end - start
]|</doc>
      </member>
      <member name="exponential"
              value="1"
              c:identifier="COGL_FOG_MODE_EXPONENTIAL">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="485">Calculates the fog blend factor as:
|[
  f = e ^ -(density * eye_distance)
]|</doc>
      </member>
      <member name="exponential_squared"
              value="2"
              c:identifier="COGL_FOG_MODE_EXPONENTIAL_SQUARED">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="489">Calculates the fog blend factor as:
|[
  f = e ^ -(density * eye_distance)^2
]|</doc>
      </member>
    </enumeration>
    <callback name="FrameCallback"
              c:type="CoglFrameCallback"
              version="1.14"
              introspectable="0"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-onscreen.h"
           line="413">Is a callback that can be registered via
cogl_onscreen_add_frame_callback() to be called when a frame
progresses in some notable way.

Please see the documentation for #CoglFrameEvent and
cogl_onscreen_add_frame_callback() for more details about what
events can be notified.</doc>
      <source-position filename="../cogl/cogl/cogl-onscreen.h" line="433"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="onscreen" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-onscreen.h"
               line="415">The onscreen that the frame is associated with</doc>
          <type name="Onscreen" c:type="CoglOnscreen*"/>
        </parameter>
        <parameter name="event" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-onscreen.h"
               line="416">A #CoglFrameEvent notifying how the frame has progressed</doc>
          <type name="FrameEvent" c:type="CoglFrameEvent"/>
        </parameter>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-onscreen.h"
               line="417">The meta information, such as timing information, about
       the frame that has progressed.</doc>
          <type c:type="CoglFrameInfo*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="3">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-onscreen.h"
               line="419">The user pointer passed to
            cogl_onscreen_add_frame_callback()</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="FrameClosure"
            c:type="CoglFrameClosure"
            version="1.14"
            stability="Unstable"
            glib:type-name="CoglFrameClosure"
            glib:get-type="cogl_frame_closure_get_gtype"
            c:symbol-prefix="frame_closure">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-onscreen.h"
           line="438">An opaque type that tracks a #CoglFrameCallback and associated user
data. A #CoglFrameClosure pointer will be returned from
cogl_onscreen_add_frame_callback() and it allows you to remove a
callback later using cogl_onscreen_remove_frame_callback().</doc>
      <source-position filename="../cogl/cogl/cogl-onscreen.h" line="449"/>
    </record>
    <enumeration name="FrameEvent"
                 version="1.14"
                 stability="Unstable"
                 c:type="CoglFrameEvent">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-onscreen.h"
           line="376">Identifiers that are passed to #CoglFrameCallback functions
(registered using cogl_onscreen_add_frame_callback()) that
mark the progression of a frame in some way which usually
means that new information will have been accumulated in the
frame's corresponding #CoglFrameInfo object.

The last event that will be sent for a frame will be a
@COGL_FRAME_EVENT_COMPLETE event and so these are a good
opportunity to collect statistics about a frame since the
#CoglFrameInfo should hold the most data at this point.

&lt;note&gt;A frame may not be completed before the next frame can start
so applications should avoid needing to collect all statistics for
a particular frame before they can start a new frame.&lt;/note&gt;</doc>
      <source-position filename="../cogl/cogl/cogl-onscreen.h" line="411"/>
      <member name="sync" value="1" c:identifier="COGL_FRAME_EVENT_SYNC">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-onscreen.h"
             line="378">Notifies that the system compositor has
                        acknowledged a frame and is ready for a
                        new frame to be created.</doc>
      </member>
      <member name="complete"
              value="2"
              c:identifier="COGL_FRAME_EVENT_COMPLETE">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-onscreen.h"
             line="381">Notifies that a frame has ended. This
                            is a good time for applications to
                            collect statistics about the frame
                            since the #CoglFrameInfo should hold
                            the most data at this point. No other
                            events should be expected after a
                            @COGL_FRAME_EVENT_COMPLETE event.</doc>
      </member>
    </enumeration>
    <interface name="Framebuffer"
               c:symbol-prefix="framebuffer"
               c:type="CoglFramebuffer"
               glib:type-name="CoglFramebuffer"
               glib:get-type="cogl_framebuffer_get_gtype">
      <prerequisite name="Object"/>
      <function name="error_quark" c:identifier="cogl_framebuffer_error_quark">
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="1821"/>
        <return-value transfer-ownership="none">
          <type name="guint32" c:type="uint32_t"/>
        </return-value>
      </function>
      <method name="allocate"
              c:identifier="cogl_framebuffer_allocate"
              version="1.8"
              stability="Unstable"
              throws="1">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="106">Explicitly allocates a configured #CoglFramebuffer allowing developers to
check and handle any errors that might arise from an unsupported
configuration so that fallback configurations may be tried.

&lt;note&gt;Many applications don't support any fallback options at least when
they are initially developed and in that case the don't need to use this API
since Cogl will automatically allocate a framebuffer when it first gets
used.  The disadvantage of relying on automatic allocation is that the
program will abort with an error message if there is an error during
automatic allocation.&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="127"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-framebuffer.h"
               line="122">%TRUE if there were no error allocating the framebuffer, else %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="108">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="clear"
              c:identifier="cogl_framebuffer_clear"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="1105">Clears all the auxiliary buffers identified in the @buffers mask, and if
that includes the color buffer then the specified @color is used.</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="1120"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1107">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="buffers" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1108">A mask of #CoglBufferBit&lt;!-- --&gt;'s identifying which auxiliary
  buffers to clear</doc>
            <type name="gulong" c:type="unsigned long"/>
          </parameter>
          <parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1110">The color to clear the color buffer too if specified in
        @buffers.</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear4f"
              c:identifier="cogl_framebuffer_clear4f"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="1124">Clears all the auxiliary buffers identified in the @buffers mask, and if
that includes the color buffer then the specified @color is used.</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="1145"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1126">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="buffers" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1127">A mask of #CoglBufferBit&lt;!-- --&gt;'s identifying which auxiliary
  buffers to clear</doc>
            <type name="gulong" c:type="unsigned long"/>
          </parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1129">The red component of color to clear the color buffer too if
      specified in @buffers.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1131">The green component of color to clear the color buffer too if
        specified in @buffers.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1133">The blue component of color to clear the color buffer too if
       specified in @buffers.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1135">The alpha component of color to clear the color buffer too if
        specified in @buffers.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="discard_buffers"
              c:identifier="cogl_framebuffer_discard_buffers"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="1675">Declares that the specified @buffers no longer need to be referenced
by any further rendering commands. This can be an important
optimization to avoid subsequent frames of rendering depending on
the results of a previous frame.

For example; some tile-based rendering GPUs are able to avoid allocating and
accessing system memory for the depth and stencil buffer so long as these
buffers are not required as input for subsequent frames and that can save a
significant amount of memory bandwidth used to save and restore their
contents to system memory between frames.

It is currently considered an error to try and explicitly discard the color
buffer by passing %COGL_BUFFER_BIT_COLOR. This is because the color buffer is
already implicitly discard when you finish rendering to a #CoglOnscreen
framebuffer, and it's not meaningful to try and discard the color buffer of
a #CoglOffscreen framebuffer since they are single-buffered.</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="1703"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1677">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="buffers" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1678">A #CoglBufferBit mask of which ancillary buffers you want
          to discard.</doc>
            <type name="gulong" c:type="unsigned long"/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_attributes"
              c:identifier="cogl_framebuffer_draw_attributes"
              version="1.10"
              introspectable="0"
              deprecated="1"
              deprecated-version="1.16"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="1223">First defines a geometry primitive by grouping a set of vertex @attributes;
specifying a @first_vertex; a number of vertices (@n_vertices) and
specifying  what kind of topology the vertices have via @mode.

Then the function draws the given @primitive geometry to the specified
destination @framebuffer using the graphics processing pipeline described by
@pipeline.

The list of #CoglAttribute&lt;!-- --&gt;s define the attributes of the vertices to
be drawn, such as positions, colors and normals and the number of attributes
is given as @n_attributes.

This drawing api doesn't support high-level meta texture types such
as #CoglTexture2DSliced so it is the user's responsibility to
ensure that only low-level textures that can be directly sampled by
a GPU such as #CoglTexture2D, #CoglTextureRectangle or #CoglTexture3D
are associated with layers of the given @pipeline.

&lt;note&gt;This api doesn't support any of the legacy global state options such
as cogl_set_depth_test_enabled(), cogl_set_backface_culling_enabled() or
cogl_program_use()&lt;/note&gt;</doc>
        <doc-deprecated xml:space="preserve">Use #CoglPrimitive&lt;!-- --&gt;s and
                  cogl_primitive_draw() instead</doc-deprecated>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="1263"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1225">A destination #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1226">A #CoglPipeline state object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1227">The #CoglVerticesMode defining the topology of vertices</doc>
            <type name="VerticesMode" c:type="CoglVerticesMode"/>
          </parameter>
          <parameter name="first_vertex" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1228">The vertex offset within the given attributes to draw from</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="n_vertices" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1229">The number of vertices to draw from the given attributes</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1230">An array of pointers to #CoglAttribute&lt;-- --&gt;s defining vertex
             geometry</doc>
            <type c:type="CoglAttribute**"/>
          </parameter>
          <parameter name="n_attributes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1232">The number of attributes in the @attributes array.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_indexed_attributes"
              c:identifier="cogl_framebuffer_draw_indexed_attributes"
              version="1.10"
              introspectable="0"
              deprecated="1"
              deprecated-version="1.16"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="1337">Behaves the same as cogl_framebuffer_draw_attributes() except that
instead of reading vertex data sequentially from the specified
@attributes the @indices provide an indirection for how the data
should be indexed allowing a random access order to be
specified.

For example an indices array of [0, 1, 2, 0, 2, 3] could be used
used to draw two triangles (@mode = %COGL_VERTICES_MODE_TRIANGLES +
@n_vertices = 6) but only provide attribute data for the 4 corners
of a rectangle. When the GPU needs to read in each of the 6
vertices it will read the @indices array for each vertex in
sequence and use the index to look up the vertex attribute data. So
here you can see that first and fourth vertex will point to the
same data and third and fifth vertex will also point to shared
data.

Drawing with indices can be a good way of minimizing the size of a
mesh by allowing you to avoid data for duplicate vertices because
multiple entries in the index array can refer back to a single
shared vertex.

&lt;note&gt;The @indices array must be at least as long as @first_vertex
+ @n_vertices otherwise the GPU will overrun the indices array when
looking up vertex data.&lt;/note&gt;

Since it's very common to want to draw a run of rectangles using
indices to avoid duplicating vertex data you can use
cogl_get_rectangle_indices() to get a set of indices that can be
shared.

This drawing api doesn't support high-level meta texture types such
as #CoglTexture2DSliced so it is the user's responsibility to
ensure that only low-level textures that can be directly sampled by
a GPU such as #CoglTexture2D, #CoglTextureRectangle or
#CoglTexture3D are associated with layers of the given @pipeline.

&lt;note&gt;This api doesn't support any of the legacy global state
options such as cogl_set_depth_test_enabled(),
cogl_set_backface_culling_enabled() or cogl_program_use()&lt;/note&gt;</doc>
        <doc-deprecated xml:space="preserve">Use #CoglPrimitive&lt;!-- --&gt;s and
                  cogl_primitive_draw() instead</doc-deprecated>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="1397"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1339">A destination #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1340">A #CoglPipeline state object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1341">The #CoglVerticesMode defining the topology of vertices</doc>
            <type name="VerticesMode" c:type="CoglVerticesMode"/>
          </parameter>
          <parameter name="first_vertex" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1342">The vertex offset within the given attributes to draw from</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="n_vertices" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1343">The number of vertices to draw from the given attributes</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="indices" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1344">The array of indices used by the GPU to lookup attribute
          data for each vertex.</doc>
            <type c:type="CoglIndices*"/>
          </parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1346">An array of pointers to #CoglAttribute&lt;-- --&gt;s defining vertex
             geometry</doc>
            <type c:type="CoglAttribute**"/>
          </parameter>
          <parameter name="n_attributes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1348">The number of attributes in the @attributes array.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_multitextured_rectangle"
              c:identifier="cogl_framebuffer_draw_multitextured_rectangle"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="1498">Draws a textured rectangle to @framebuffer with the given @pipeline
state with the top left corner positioned at (@x_1, @y_1) and the
bottom right corner positioned at (@x_2, @y_2). As a pipeline may
contain multiple texture layers this interface lets you supply
texture coordinates for each layer of the pipeline.

&lt;note&gt;The position is the position before the rectangle has been
transformed by the model-view matrix and the projection
matrix.&lt;/note&gt;

This is a high level drawing api that can handle any kind of
#CoglMetaTexture texture for the first layer such as
#CoglTexture2DSliced textures which may internally be comprised of
multiple low-level textures.  This is unlike low-level drawing apis
such as cogl_primitive_draw() which only support low level texture
types that are directly supported by GPUs such as #CoglTexture2D.

&lt;note&gt;This api can not currently handle multiple high-level meta
texture layers. The first layer may be a high level meta texture
such as #CoglTexture2DSliced but all other layers much be low
level textures such as #CoglTexture2D and additionally they
should be textures that can be sampled using normalized coordinates
(so not #CoglTextureRectangle textures).&lt;/note&gt;

The top left texture coordinate for layer 0 of any pipeline will be
(tex_coords[0], tex_coords[1]) and the bottom right coordinate will
be (tex_coords[2], tex_coords[3]). The coordinates for layer 1
would be (tex_coords[4], tex_coords[5]) (tex_coords[6],
tex_coords[7]) and so on...

The given texture coordinates should always be normalized such that
(0, 0) corresponds to the top left and (1, 1) corresponds to the
bottom right. To map an entire texture across the rectangle pass
in tex_coords[0]=0, tex_coords[1]=0, tex_coords[2]=1,
tex_coords[3]=1.

&lt;note&gt;Even if you have associated a #CoglTextureRectangle texture
which normally implies working with non-normalized texture
coordinates this api should still be passed normalized texture
coordinates.&lt;/note&gt;

The first pair of coordinates are for the first layer (with the
smallest layer index) and if you supply less texture coordinates
than there are layers in the current source material then default
texture coordinates (0.0, 0.0, 1.0, 1.0) are generated.</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="1565"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1500">A destination #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1501">A #CoglPipeline state object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </parameter>
          <parameter name="x_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1502">x coordinate upper left on screen.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1503">y coordinate upper left on screen.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1504">x coordinate lower right on screen.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1505">y coordinate lower right on screen.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="tex_coords" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1506">An array containing groups of
  4 float values: [s_1, t_1, s_2, t_2] that are interpreted as two texture
  coordinates; one for the top left texel, and one for the bottom right
  texel. Each value should be between 0.0 and 1.0, where the coordinate
  (0.0, 0.0) represents the top left of the texture, and (1.0, 1.0) the
  bottom right.</doc>
            <array zero-terminated="0" c:type="const float*">
              <type name="gfloat" c:type="float"/>
            </array>
          </parameter>
          <parameter name="tex_coords_len" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1512">The length of the @tex_coords array. (For one layer
  and one group of texture coordinates, this would be 4)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_primitive"
              c:identifier="cogl_framebuffer_draw_primitive"
              version="1.10"
              introspectable="0"
              deprecated="1"
              deprecated-version="1.16"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="1152">Draws the given @primitive geometry to the specified destination
@framebuffer using the graphics processing state described by @pipeline.

This drawing api doesn't support high-level meta texture types such
as #CoglTexture2DSliced so it is the user's responsibility to
ensure that only low-level textures that can be directly sampled by
a GPU such as #CoglTexture2D, #CoglTextureRectangle or #CoglTexture3D
are associated with layers of the given @pipeline.

&lt;note&gt;This api doesn't support any of the legacy global state options such
as cogl_set_depth_test_enabled(), cogl_set_backface_culling_enabled() or
cogl_program_use()&lt;/note&gt;</doc>
        <doc-deprecated xml:space="preserve">Use #CoglPrimitive&lt;!-- --&gt;s and
                  cogl_primitive_draw() instead</doc-deprecated>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="1178"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1154">A destination #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1155">A #CoglPipeline state object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </parameter>
          <parameter name="primitive" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1156">A #CoglPrimitive geometry object</doc>
            <type c:type="CoglPrimitive*"/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_rectangle"
              c:identifier="cogl_framebuffer_draw_rectangle"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="1406">Draws a rectangle to @framebuffer with the given @pipeline state
and with the top left corner positioned at (@x_1, @y_1) and the
bottom right corner positioned at (@x_2, @y_2).

&lt;note&gt;The position is the position before the rectangle has been
transformed by the model-view matrix and the projection
matrix.&lt;/note&gt;

&lt;note&gt;If you want to describe a rectangle with a texture mapped on
it then you can use
cogl_framebuffer_draw_textured_rectangle().&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="1431"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1408">A destination #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1409">A #CoglPipeline state object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </parameter>
          <parameter name="x_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1410">X coordinate of the top-left corner</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1411">Y coordinate of the top-left corner</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1412">X coordinate of the bottom-right corner</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1413">Y coordinate of the bottom-right corner</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_rectangles"
              c:identifier="cogl_framebuffer_draw_rectangles"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="1574">Draws a series of rectangles to @framebuffer with the given
@pipeline state in the same way that
cogl_framebuffer_draw_rectangle() does.

The top left corner of the first rectangle is positioned at
(coordinates[0], coordinates[1]) and the bottom right corner is
positioned at (coordinates[2], coordinates[3]). The positions for
the second rectangle are (coordinates[4], coordinates[5]) and
(coordinates[6], coordinates[7]) and so on...

&lt;note&gt;The position is the position before the rectangle has been
transformed by the model-view matrix and the projection
matrix.&lt;/note&gt;

As a general rule for better performance its recommended to use
this this API instead of calling
cogl_framebuffer_draw_textured_rectangle() separately for multiple
rectangles if all of the rectangles will be drawn together with the
same @pipeline state.</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="1609"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1576">A destination #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1577">A #CoglPipeline state object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </parameter>
          <parameter name="coordinates" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1578">an array of coordinates
  containing groups of 4 float values: [x_1, y_1, x_2, y_2] that are
  interpreted as two position coordinates; one for the top left of
  the rectangle (x1, y1), and one for the bottom right of the
  rectangle (x2, y2).</doc>
            <array zero-terminated="0" c:type="const float*">
              <type name="gfloat" c:type="float"/>
            </array>
          </parameter>
          <parameter name="n_rectangles" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1583">number of rectangles defined in @coordinates.</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_textured_rectangle"
              c:identifier="cogl_framebuffer_draw_textured_rectangle"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="1438">Draws a textured rectangle to @framebuffer using the given
@pipeline state with the top left corner positioned at (@x_1, @y_1)
and the bottom right corner positioned at (@x_2, @y_2). The top
left corner will have texture coordinates of (@s_1, @t_1) and the
bottom right corner will have texture coordinates of (@s_2, @t_2).

&lt;note&gt;The position is the position before the rectangle has been
transformed by the model-view matrix and the projection
matrix.&lt;/note&gt;

This is a high level drawing api that can handle any kind of
#CoglMetaTexture texture such as #CoglTexture2DSliced textures
which may internally be comprised of multiple low-level textures.
This is unlike low-level drawing apis such as cogl_primitive_draw()
which only support low level texture types that are directly
supported by GPUs such as #CoglTexture2D.

&lt;note&gt;The given texture coordinates will only be used for the first
texture layer of the pipeline and if your pipeline has more than
one layer then all other layers will have default texture
coordinates of @s_1=0.0 @t_1=0.0 @s_2=1.0 @t_2=1.0 &lt;/note&gt;

The given texture coordinates should always be normalized such that
(0, 0) corresponds to the top left and (1, 1) corresponds to the
bottom right. To map an entire texture across the rectangle pass
in @s_1=0, @t_1=0, @s_2=1, @t_2=1.

&lt;note&gt;Even if you have associated a #CoglTextureRectangle texture
with one of your @pipeline layers which normally implies working
with non-normalized texture coordinates this api should still be
passed normalized texture coordinates.&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="1487"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1440">A destination #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1441">A #CoglPipeline state object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </parameter>
          <parameter name="x_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1442">x coordinate upper left on screen.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1443">y coordinate upper left on screen.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1444">x coordinate lower right on screen.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1445">y coordinate lower right on screen.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="s_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1446">S texture coordinate of the top-left coorner</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="t_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1447">T texture coordinate of the top-left coorner</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="s_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1448">S texture coordinate of the bottom-right coorner</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="t_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1449">T texture coordinate of the bottom-right coorner</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_textured_rectangles"
              c:identifier="cogl_framebuffer_draw_textured_rectangles"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="1614">Draws a series of rectangles to @framebuffer with the given
@pipeline state in the same way that
cogl_framebuffer_draw_textured_rectangle() does.

&lt;note&gt;The position is the position before the rectangle has been
transformed by the model-view matrix and the projection
matrix.&lt;/note&gt;

This is a high level drawing api that can handle any kind of
#CoglMetaTexture texture such as #CoglTexture2DSliced textures
which may internally be comprised of multiple low-level textures.
This is unlike low-level drawing apis such as cogl_primitive_draw()
which only support low level texture types that are directly
supported by GPUs such as #CoglTexture2D.

The top left corner of the first rectangle is positioned at
(coordinates[0], coordinates[1]) and the bottom right corner is
positioned at (coordinates[2], coordinates[3]). The top left
texture coordinate is (coordinates[4], coordinates[5]) and the
bottom right texture coordinate is (coordinates[6],
coordinates[7]). The coordinates for subsequent rectangles
are defined similarly by the subsequent coordinates.

As a general rule for better performance its recommended to use
this this API instead of calling
cogl_framebuffer_draw_textured_rectangle() separately for multiple
rectangles if all of the rectangles will be drawn together with the
same @pipeline state.

The given texture coordinates should always be normalized such that
(0, 0) corresponds to the top left and (1, 1) corresponds to the
bottom right. To map an entire texture across the rectangle pass
in tex_coords[0]=0, tex_coords[1]=0, tex_coords[2]=1,
tex_coords[3]=1.

&lt;note&gt;Even if you have associated a #CoglTextureRectangle texture
which normally implies working with non-normalized texture
coordinates this api should still be passed normalized texture
coordinates.&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="1668"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1616">A destination #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1617">A #CoglPipeline state object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </parameter>
          <parameter name="coordinates" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1618">an array containing
  groups of 8 float values: [x_1, y_1, x_2, y_2, s_1, t_1, s_2, t_2]
  that have the same meaning as the arguments for
  cogl_framebuffer_draw_textured_rectangle().</doc>
            <array zero-terminated="0" c:type="const float*">
              <type name="gfloat" c:type="float"/>
            </array>
          </parameter>
          <parameter name="n_rectangles" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1622">number of rectangles to @coordinates to draw</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
        </parameters>
      </method>
      <method name="finish"
              c:identifier="cogl_framebuffer_finish"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="1706">This blocks the CPU until all pending rendering associated with the
specified framebuffer has completed. It's very rare that developers should
ever need this level of synchronization with the GPU and should never be
used unless you clearly understand why you need to explicitly force
synchronization.

One example might be for benchmarking purposes to be sure timing
measurements reflect the time that the GPU is busy for not just the time it
takes to queue rendering commands.</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="1724"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1708">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="frustum"
              c:identifier="cogl_framebuffer_frustum"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="463">Replaces the current projection matrix with a perspective matrix
for a given viewing frustum defined by 4 side clip planes that
all cross through the origin and 2 near and far clip planes.</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="485"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="465">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="466">X position of the left clipping plane where it
  intersects the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="468">X position of the right clipping plane where it
  intersects the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="bottom" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="470">Y position of the bottom clipping plane where it
  intersects the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="top" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="472">Y position of the top clipping plane where it intersects
  the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_near" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="474">The distance to the near clipping plane (Must be positive)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_far" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="475">The distance to the far clipping plane (Must be positive)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_alpha_bits"
              c:identifier="cogl_framebuffer_get_alpha_bits"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="697">Retrieves the number of alpha bits of @framebuffer</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="709"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-framebuffer.h"
               line="703">the number of bits</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="699">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_blue_bits"
              c:identifier="cogl_framebuffer_get_blue_bits"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="683">Retrieves the number of blue bits of @framebuffer</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="695"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-framebuffer.h"
               line="689">the number of bits</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="685">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_color_mask"
              c:identifier="cogl_framebuffer_get_color_mask"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="819">Gets the current #CoglColorMask of which channels would be written to the
current framebuffer. Each bit set in the mask means that the
corresponding color would be written.</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="832"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-framebuffer.h"
               line="827">A #CoglColorMask</doc>
          <type name="ColorMask" c:type="CoglColorMask"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="821">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_context"
              c:identifier="cogl_framebuffer_get_context"
              version="1.8"
              introspectable="0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="1089">Can be used to query the #CoglContext a given @framebuffer was
instantiated within. This is the #CoglContext that was passed to
cogl_onscreen_new() for example.</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="1103"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-framebuffer.h"
               line="1097">The #CoglContext that the given
              @framebuffer was instantiated within.</doc>
          <type c:type="CoglContext*"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1091">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_depth_bits"
              c:identifier="cogl_framebuffer_get_depth_bits"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="711">Retrieves the number of depth bits of @framebuffer</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="723"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-framebuffer.h"
               line="717">the number of bits</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="713">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_depth_texture"
              c:identifier="cogl_framebuffer_get_depth_texture"
              version="1.14"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="925">Retrieves the depth buffer of @framebuffer as a #CoglTexture. You need to
call cogl_framebuffer_get_depth_texture(fb, TRUE); before using this
function.

&lt;note&gt;Calling this function implicitely allocates the framebuffer.&lt;/note&gt;
&lt;note&gt;The texture returned stays valid as long as the framebuffer stays
valid.&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="943"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-framebuffer.h"
               line="937">the depth texture</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="927">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_depth_texture_enabled"
              c:identifier="cogl_framebuffer_get_depth_texture_enabled"
              version="1.14"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="909">Queries whether texture based depth buffer has been enabled via
cogl_framebuffer_set_depth_texture_enabled().</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="923"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-framebuffer.h"
               line="916">%TRUE if a depth texture has been enabled, else
              %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="911">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_depth_write_enabled"
              c:identifier="cogl_framebuffer_get_depth_write_enabled"
              version="1.18"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="786">Queries whether depth buffer writing is enabled for @framebuffer. This
can be controlled via cogl_framebuffer_set_depth_write_enabled().</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="798"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-framebuffer.h"
               line="793">%TRUE if depth writing is enabled or %FALSE if not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="788">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dither_enabled"
              c:identifier="cogl_framebuffer_get_dither_enabled"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="742">Returns whether dithering has been requested for the given @framebuffer.
See cogl_framebuffer_set_dither_enabled() for more details about dithering.

&lt;note&gt;This may return %TRUE even when the underlying @framebuffer
display pipeline does not support dithering. This value only represents
the user's request for dithering.&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="758"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-framebuffer.h"
               line="753">%TRUE if dithering has been requested or %FALSE if not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="744">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_green_bits"
              c:identifier="cogl_framebuffer_get_green_bits"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="669">Retrieves the number of green bits of @framebuffer</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="681"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-framebuffer.h"
               line="675">the number of bits</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="671">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_height"
              c:identifier="cogl_framebuffer_get_height"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="143">Queries the current height of the given @framebuffer.</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="154"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-framebuffer.h"
               line="149">The height of @framebuffer.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="145">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_is_stereo"
              c:identifier="cogl_framebuffer_get_is_stereo">
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="740"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_modelview_matrix"
              c:identifier="cogl_framebuffer_get_modelview_matrix"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="408">Stores the current model-view matrix in @matrix.</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="419"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="410">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="matrix"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="411">return location for the model-view matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_projection_matrix"
              c:identifier="cogl_framebuffer_get_projection_matrix"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="522">Stores the current projection matrix in @matrix.</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="533"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="524">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="matrix"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="525">return location for the projection matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_red_bits"
              c:identifier="cogl_framebuffer_get_red_bits"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="655">Retrieves the number of red bits of @framebuffer</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="667"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-framebuffer.h"
               line="661">the number of bits</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="657">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_samples_per_pixel"
              c:identifier="cogl_framebuffer_get_samples_per_pixel"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="990">Gets the number of points that are sampled per-pixel when
rasterizing geometry. Usually by default this will return 0 which
means that single-sample not multisample rendering has been chosen.
When using a GPU supporting multisample rendering it's possible to
increase the number of samples per pixel using
cogl_framebuffer_set_samples_per_pixel().

Calling cogl_framebuffer_get_samples_per_pixel() before the
framebuffer has been allocated will simply return the value set
using cogl_framebuffer_set_samples_per_pixel(). After the
framebuffer has been allocated the value will reflect the actual
number of samples that will be made by the GPU.</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="1015"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-framebuffer.h"
               line="1007">The number of point samples made per pixel when
         rasterizing geometry or 0 if single-sample rendering
         has been chosen.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="992">A #CoglFramebuffer framebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_stereo_mode"
              c:identifier="cogl_framebuffer_get_stereo_mode"
              version="1.20"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="851">Gets the current #CoglStereoMode, which defines which stereo buffers
should be drawn to. See cogl_framebuffer_set_stereo_mode().</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="863"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-framebuffer.h"
               line="858">A #CoglStereoMode</doc>
          <type name="StereoMode" c:type="CoglStereoMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="853">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_viewport4fv"
              c:identifier="cogl_framebuffer_get_viewport4fv"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="248">Queries the x, y, width and height components of the current viewport as set
using cogl_framebuffer_set_viewport() or the default values which are 0, 0,
framebuffer_width and framebuffer_height.  The values are written into the
given @viewport array.</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="264"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="250">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="viewport"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="251">A pointer to an
           array of 4 floats to receive the (x, y, width, height)
           components of the current viewport.</doc>
            <array zero-terminated="0" c:type="float*" fixed-size="4">
              <type name="gfloat" c:type="float"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="get_viewport_height"
              c:identifier="cogl_framebuffer_get_viewport_height"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="234">Queries the height of the viewport as set using cogl_framebuffer_set_viewport()
or the default value which is the height of the framebuffer.</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="246"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-framebuffer.h"
               line="241">The height of the viewport.</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="236">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_viewport_width"
              c:identifier="cogl_framebuffer_get_viewport_width"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="220">Queries the width of the viewport as set using cogl_framebuffer_set_viewport()
or the default value which is the width of the framebuffer.</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="232"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-framebuffer.h"
               line="227">The width of the viewport.</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="222">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_viewport_x"
              c:identifier="cogl_framebuffer_get_viewport_x"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="192">Queries the x coordinate of the viewport origin as set using cogl_framebuffer_set_viewport()
or the default value which is 0.</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="204"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-framebuffer.h"
               line="199">The x coordinate of the viewport origin.</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="194">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_viewport_y"
              c:identifier="cogl_framebuffer_get_viewport_y"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="206">Queries the y coordinate of the viewport origin as set using cogl_framebuffer_set_viewport()
or the default value which is 0.</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="218"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-framebuffer.h"
               line="213">The y coordinate of the viewport origin.</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="208">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_width"
              c:identifier="cogl_framebuffer_get_width"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="130">Queries the current width of the given @framebuffer.</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="141"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-framebuffer.h"
               line="136">The width of @framebuffer.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="132">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="identity_matrix"
              c:identifier="cogl_framebuffer_identity_matrix"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="290">Resets the current model-view matrix to the identity matrix.</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="300"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="292">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="orthographic"
              c:identifier="cogl_framebuffer_orthographic"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="493">Replaces the current projection matrix with an orthographic projection
matrix.</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="514"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="495">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="x_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="496">The x coordinate for the first vertical clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="497">The y coordinate for the first horizontal clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="498">The x coordinate for the second vertical clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="499">The y coordinate for the second horizontal clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="near" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="500">The &lt;emphasis&gt;distance&lt;/emphasis&gt; to the near clipping
  plane (will be &lt;emphasis&gt;negative&lt;/emphasis&gt; if the plane is
  behind the viewer)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="far" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="503">The &lt;emphasis&gt;distance&lt;/emphasis&gt; to the far clipping
  plane (will be &lt;emphasis&gt;negative&lt;/emphasis&gt; if the plane is
  behind the viewer)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="perspective"
              c:identifier="cogl_framebuffer_perspective"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="436">Replaces the current projection matrix with a perspective matrix
based on the provided values.

&lt;note&gt;You should be careful not to have to great a @z_far / @z_near
ratio since that will reduce the effectiveness of depth testing
since there wont be enough precision to identify the depth of
objects near to each other.&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="457"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="438">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="fov_y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="439">Vertical field of view angle in degrees.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="aspect" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="440">The (width over height) aspect ratio for display</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_near" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="441">The distance to the near clipping plane (Must be positive,
  and must not be 0)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_far" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="443">The distance to the far clipping plane (Must be positive)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="pop_clip"
              c:identifier="cogl_framebuffer_pop_clip"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="641">Reverts the clipping region to the state before the last call to
cogl_framebuffer_push_scissor_clip(), cogl_framebuffer_push_rectangle_clip()
cogl_framebuffer_push_path_clip(), or cogl_framebuffer_push_primitive_clip().</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="653"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="643">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="pop_matrix"
              c:identifier="cogl_framebuffer_pop_matrix"
              version="1.10">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="279">Restores the model-view matrix on the top of the matrix stack.</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="288"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="281">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="push_matrix"
              c:identifier="cogl_framebuffer_push_matrix"
              version="1.10">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="267">Copies the current model-view matrix onto the matrix stack. The matrix
can later be restored with cogl_framebuffer_pop_matrix().</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="277"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="269">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="push_primitive_clip"
              c:identifier="cogl_framebuffer_push_primitive_clip"
              version="1.10"
              introspectable="0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="604">Sets a new clipping area using a 2D shaped described with a
#CoglPrimitive. The shape must not contain self overlapping
geometry and must lie on a single 2D plane. A bounding box of the
2D shape in local coordinates (the same coordinates used to
describe the shape) must be given. It is acceptable for the bounds
to be larger than the true bounds but behaviour is undefined if the
bounds are smaller than the true bounds.

The primitive is transformed by the current model-view matrix and
the silhouette is intersected with the previous clipping area.  To
restore the previous clipping area, call
cogl_framebuffer_pop_clip().</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="634"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="606">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="primitive" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="607">A #CoglPrimitive describing a flat 2D shape</doc>
            <type c:type="CoglPrimitive*"/>
          </parameter>
          <parameter name="bounds_x1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="608">x coordinate for the top-left corner of the primitives
            bounds</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="bounds_y1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="610">y coordinate for the top-left corner of the primitives
            bounds</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="bounds_x2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="612">x coordinate for the bottom-right corner of the
            primitives bounds.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="bounds_y2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="614">y coordinate for the bottom-right corner of the
            primitives bounds.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="push_rectangle_clip"
              c:identifier="cogl_framebuffer_push_rectangle_clip"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="577">Specifies a modelview transformed rectangular clipping area for all
subsequent drawing operations. Any drawing commands that extend
outside the rectangle will be clipped so that only the portion
inside the rectangle will be displayed. The rectangle dimensions
are transformed by the current model-view matrix.

The rectangle is intersected with the current clip region. To undo
the effect of this function, call cogl_framebuffer_pop_clip().</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="598"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="579">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="x_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="580">x coordinate for top left corner of the clip rectangle</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="581">y coordinate for top left corner of the clip rectangle</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="582">x coordinate for bottom right corner of the clip rectangle</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="583">y coordinate for bottom right corner of the clip rectangle</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="push_scissor_clip"
              c:identifier="cogl_framebuffer_push_scissor_clip"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="550">Specifies a rectangular clipping area for all subsequent drawing
operations. Any drawing commands that extend outside the rectangle
will be clipped so that only the portion inside the rectangle will
be displayed. The rectangle dimensions are not transformed by the
current model-view matrix.

The rectangle is intersected with the current clip region. To undo
the effect of this function, call cogl_framebuffer_pop_clip().</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="571"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="552">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="553">left edge of the clip rectangle in window coordinates</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="554">top edge of the clip rectangle in window coordinates</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="555">width of the clip rectangle</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="556">height of the clip rectangle</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_pixels"
              c:identifier="cogl_framebuffer_read_pixels"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="1759">This is a convenience wrapper around
cogl_framebuffer_read_pixels_into_bitmap() which allocates a
temporary #CoglBitmap to read pixel data directly into the given
buffer. The rowstride of the buffer is assumed to be the width of
the region times the bytes per pixel of the format. The source for
the data is always taken from the color buffer. If you want to use
any other rowstride or source, please use the
cogl_framebuffer_read_pixels_into_bitmap() function directly.

The implementation of the function looks like this:

|[
bitmap = cogl_bitmap_new_for_data (context,
                                   width, height,
                                   format,
                                   /&lt;!-- --&gt;* rowstride *&lt;!-- --&gt;/
                                   bpp * width,
                                   pixels);
cogl_framebuffer_read_pixels_into_bitmap (framebuffer,
                                          x, y,
                                          COGL_READ_PIXELS_COLOR_BUFFER,
                                          bitmap);
cogl_object_unref (bitmap);
]|</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="1799"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-framebuffer.h"
               line="1794">%TRUE if the read succeeded or %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1761">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1762">The x position to read from</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1763">The y position to read from</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1764">The width of the region of rectangles to read</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1765">The height of the region of rectangles to read</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1766">The pixel format to store the data in</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="pixels" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1767">The address of the buffer to store the data in</doc>
            <type name="guint8" c:type="uint8_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_pixels_into_bitmap"
              c:identifier="cogl_framebuffer_read_pixels_into_bitmap"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="1726">This reads a rectangle of pixels from the given framebuffer where
position (0, 0) is the top left. The pixel at (x, y) is the first
read, and a rectangle of pixels with the same size as the bitmap is
read right and downwards from that point.

Currently Cogl assumes that the framebuffer is in a premultiplied
format so if the format of @bitmap is non-premultiplied it will
convert it. To read the pixel values without any conversion you
should either specify a format that doesn't use an alpha channel or
use one of the formats ending in PRE.</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="1753"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-framebuffer.h"
               line="1746">%TRUE if the read succeeded or %FALSE otherwise. The
 function is only likely to fail if the bitmap points to a pixel
 buffer and it could not be mapped.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1728">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1729">The x position to read from</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1730">The y position to read from</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1731">Identifies which auxillary buffer you want to read
         (only COGL_READ_PIXELS_COLOR_BUFFER supported currently)</doc>
            <type name="ReadPixelsFlags" c:type="CoglReadPixelsFlags"/>
          </parameter>
          <parameter name="bitmap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1733">The bitmap to store the results in.</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </parameter>
        </parameters>
      </method>
      <method name="resolve_samples"
              c:identifier="cogl_framebuffer_resolve_samples"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="1018">When point sample rendering (also known as multisample rendering)
has been enabled via cogl_framebuffer_set_samples_per_pixel()
then you can optionally call this function (or
cogl_framebuffer_resolve_samples_region()) to explicitly resolve
the point samples into values for the final color buffer.

Some GPUs will implicitly resolve the point samples during
rendering and so this function is effectively a nop, but with other
architectures it is desirable to defer the resolve step until the
end of the frame.

Since Cogl will automatically ensure samples are resolved if the
target color buffer is used as a source this API only needs to be
used if explicit control is desired - perhaps because you want to
ensure that the resolve is completed in advance to avoid later
having to wait for the resolve to complete.

If you are performing incremental updates to a framebuffer you
should consider using cogl_framebuffer_resolve_samples_region()
instead to avoid resolving redundant pixels.</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="1047"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1020">A #CoglFramebuffer framebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="resolve_samples_region"
              c:identifier="cogl_framebuffer_resolve_samples_region"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="1049">When point sample rendering (also known as multisample rendering)
has been enabled via cogl_framebuffer_set_samples_per_pixel()
then you can optionally call this function (or
cogl_framebuffer_resolve_samples()) to explicitly resolve the point
samples into values for the final color buffer.

Some GPUs will implicitly resolve the point samples during
rendering and so this function is effectively a nop, but with other
architectures it is desirable to defer the resolve step until the
end of the frame.

Use of this API is recommended if incremental, small updates to
a framebuffer are being made because by default Cogl will
implicitly resolve all the point samples of the framebuffer which
can result in redundant work if only a small number of samples have
changed.

Because some GPUs implicitly resolve point samples this function
only guarantees that at-least the region specified will be resolved
and if you have rendered to a larger region then it's possible that
other samples may be implicitly resolved.</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="1083"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1051">A #CoglFramebuffer framebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1052">top-left x coordinate of region to resolve</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1053">top-left y coordinate of region to resolve</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1054">width of region to resolve</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1055">height of region to resolve</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="rotate"
              c:identifier="cogl_framebuffer_rotate"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="340">Multiplies the current model-view matrix by one that rotates the
model around the axis-vector specified by @x, @y and @z. The
rotation follows the right-hand thumb rule so for example rotating
by 10 degrees about the axis-vector (0, 0, 1) causes a small
counter-clockwise rotation.</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="358"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="342">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="343">Angle in degrees to rotate.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="344">X-component of vertex to rotate around.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="345">Y-component of vertex to rotate around.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="346">Z-component of vertex to rotate around.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="rotate_euler"
              c:identifier="cogl_framebuffer_rotate_euler"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="379">Multiplies the current model-view matrix by one that rotates
according to the rotation described by @euler.</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="391"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="381">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="euler" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="382">A #CoglEuler</doc>
            <type name="Euler" c:type="const CoglEuler*"/>
          </parameter>
        </parameters>
      </method>
      <method name="rotate_quaternion"
              c:identifier="cogl_framebuffer_rotate_quaternion"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="364">Multiplies the current model-view matrix by one that rotates
according to the rotation described by @quaternion.</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="376"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="366">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="quaternion" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="367">A #CoglQuaternion</doc>
            <type name="Quaternion" c:type="const CoglQuaternion*"/>
          </parameter>
        </parameters>
      </method>
      <method name="scale"
              c:identifier="cogl_framebuffer_scale"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="302">Multiplies the current model-view matrix by one that scales the x,
y and z axes by the given values.</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="316"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="304">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="305">Amount to scale along the x-axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="306">Amount to scale along the y-axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="307">Amount to scale along the z-axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_color_mask"
              c:identifier="cogl_framebuffer_set_color_mask"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="834">Defines a bit mask of which color channels should be written to the
given @framebuffer. If a bit is set in @color_mask that means that
color will be written.</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="848"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="836">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="color_mask" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="837">A #CoglColorMask of which color channels to write to
             the current framebuffer.</doc>
            <type name="ColorMask" c:type="CoglColorMask"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_depth_texture_enabled"
              c:identifier="cogl_framebuffer_set_depth_texture_enabled"
              version="1.14"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="886">If @enabled is #TRUE, the depth buffer used when rendering to @framebuffer
is available as a texture. You can retrieve the texture with
cogl_framebuffer_get_depth_texture().

&lt;note&gt;It's possible that your GPU does not support depth textures. You
should check the %COGL_FEATURE_ID_DEPTH_TEXTURE feature before using this
function.&lt;/note&gt;
&lt;note&gt;It's not valid to call this function after the framebuffer has been
allocated as the creation of the depth texture is done at allocation time.
&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="906"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="888">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="889">TRUE or FALSE</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_depth_write_enabled"
              c:identifier="cogl_framebuffer_set_depth_write_enabled"
              version="1.18"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="800">Enables or disables depth buffer writing when rendering to @framebuffer.
If depth writing is enabled for both the framebuffer and the rendering
pipeline, and the framebuffer has an associated depth buffer, depth
information will be written to this buffer during rendering.

Depth buffer writing is enabled by default.</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="816"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="802">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="depth_write_enabled" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="803">%TRUE to enable depth writing or %FALSE to disable</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_dither_enabled"
              c:identifier="cogl_framebuffer_set_dither_enabled"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="760">Enables or disabled dithering if supported by the hardware.

Dithering is a hardware dependent technique to increase the visible
color resolution beyond what the underlying hardware supports by playing
tricks with the colors placed into the framebuffer to give the illusion
of other colors. (For example this can be compared to half-toning used
by some news papers to show varying levels of grey even though their may
only be black and white are available).

If the current display pipeline for @framebuffer does not support dithering
then this has no affect.

Dithering is enabled by default.</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="783"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="762">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="dither_enabled" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="763">%TRUE to enable dithering or %FALSE to disable</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_modelview_matrix"
              c:identifier="cogl_framebuffer_set_modelview_matrix"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="422">Sets @matrix as the new model-view matrix.</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="433"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="424">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="425">the new model-view matrix</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_projection_matrix"
              c:identifier="cogl_framebuffer_set_projection_matrix"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="536">Sets @matrix as the new projection matrix.</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="547"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="538">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="539">the new projection matrix</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_samples_per_pixel"
              c:identifier="cogl_framebuffer_set_samples_per_pixel"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="945">Requires that when rendering to @framebuffer then @n point samples
should be made per pixel which will all contribute to the final
resolved color for that pixel. The idea is that the hardware aims
to get quality similar to what you would get if you rendered
everything twice as big (for 4 samples per pixel) and then scaled
that image back down with filtering. It can effectively remove the
jagged edges of polygons and should be more efficient than if you
were to manually render at a higher resolution and downscale
because the hardware is often able to take some shortcuts. For
example the GPU may only calculate a single texture sample for all
points of a single pixel, and for tile based architectures all the
extra sample data (such as depth and stencil samples) may be
handled on-chip and so avoid increased demand on system memory
bandwidth.

By default this value is usually set to 0 and that is referred to
as "single-sample" rendering. A value of 1 or greater is referred
to as "multisample" rendering.

&lt;note&gt;There are some semantic differences between single-sample
rendering and multisampling with just 1 point sample such as it
being redundant to use the cogl_framebuffer_resolve_samples() and
cogl_framebuffer_resolve_samples_region() apis with single-sample
rendering.&lt;/note&gt;

&lt;note&gt;It's recommended that
cogl_framebuffer_resolve_samples_region() be explicitly used at the
end of rendering to a point sample buffer to minimize the number of
samples that get resolved. By default Cogl will implicitly resolve
all framebuffer samples but if only a small region of a
framebuffer has changed this can lead to redundant work being
done.&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="987"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="947">A #CoglFramebuffer framebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="samples_per_pixel" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="948">The minimum number of samples per pixel</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_stereo_mode"
              c:identifier="cogl_framebuffer_set_stereo_mode"
              version="1.20"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="865">Sets which stereo buffers should be drawn to. The default
is %COGL_STEREO_BOTH, which means that both the left and
right buffers will be affected by drawing. For this to have
an effect, the display system must support stereo drawables,
and the framebuffer must have been created with stereo
enabled. (See cogl_onscreen_template_set_stereo_enabled(),
cogl_framebuffer_get_is_stereo().)</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="883"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="867">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="stereo_mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="868">A #CoglStereoMode specifying which stereo buffers
              should be drawn tow.</doc>
            <type name="StereoMode" c:type="CoglStereoMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_viewport"
              c:identifier="cogl_framebuffer_set_viewport"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="156">Defines a scale and offset for everything rendered relative to the
top-left of the destination framebuffer.

By default the viewport has an origin of (0,0) and width and height
that match the framebuffer's size. Assuming a default projection and
modelview matrix then you could translate the contents of a window
down and right by leaving the viewport size unchanged by moving the
offset to (10,10). The viewport coordinates are measured in pixels.
If you left the x and y origin as (0,0) you could scale the windows
contents down by specify and width and height that's half the real
size of the framebuffer.

&lt;note&gt;Although the function takes floating point arguments, existing
drivers only allow the use of integer values. In the future floating
point values will be exposed via a checkable feature.&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="186"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="158">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="159">The top-left x coordinate of the viewport origin (only integers
    supported currently)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="161">The top-left y coordinate of the viewport origin (only integers
    supported currently)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="163">The width of the viewport (only integers supported currently)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="164">The height of the viewport (only integers supported currently)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform"
              c:identifier="cogl_framebuffer_transform"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="394">Multiplies the current model-view matrix by the given matrix.</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="405"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="396">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="397">the matrix to multiply with the current model-view</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </parameter>
        </parameters>
      </method>
      <method name="translate"
              c:identifier="cogl_framebuffer_translate"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="321">Multiplies the current model-view matrix by one that translates the
model along all three axes according to the given values.</doc>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="335"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="323">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="324">Distance to translate along the x-axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="325">Distance to translate along the y-axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="326">Distance to translate along the z-axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="vdraw_attributes"
              c:identifier="cogl_framebuffer_vdraw_attributes"
              version="1.10"
              introspectable="0"
              deprecated="1"
              deprecated-version="1.16"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="1182">First defines a geometry primitive by grouping a set of vertex attributes;
specifying a @first_vertex; a number of vertices (@n_vertices) and
specifying  what kind of topology the vertices have via @mode.

Then the function draws the given @primitive geometry to the specified
destination @framebuffer using the graphics processing pipeline described by
@pipeline.

The list of #CoglAttribute&lt;!-- --&gt;s define the attributes of the vertices to
be drawn, such as positions, colors and normals and should be %NULL
terminated.

This drawing api doesn't support high-level meta texture types such
as #CoglTexture2DSliced so it is the user's responsibility to
ensure that only low-level textures that can be directly sampled by
a GPU such as #CoglTexture2D, #CoglTextureRectangle or #CoglTexture3D
are associated with layers of the given @pipeline.</doc>
        <doc-deprecated xml:space="preserve">Use #CoglPrimitive&lt;!-- --&gt;s and
                  cogl_primitive_draw() instead</doc-deprecated>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="1216"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1184">A destination #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1185">A #CoglPipeline state object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1186">The #CoglVerticesMode defining the topology of vertices</doc>
            <type name="VerticesMode" c:type="CoglVerticesMode"/>
          </parameter>
          <parameter name="first_vertex" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1187">The vertex offset within the given attributes to draw from</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="n_vertices" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1188">The number of vertices to draw from the given attributes</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1189">A set of vertex #CoglAttribute&lt;!-- --&gt;s defining vertex geometry</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="vdraw_indexed_attributes"
              c:identifier="cogl_framebuffer_vdraw_indexed_attributes"
              version="1.10"
              introspectable="0"
              deprecated="1"
              deprecated-version="1.16"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="1271">Behaves the same as cogl_framebuffer_vdraw_attributes() except that
instead of reading vertex data sequentially from the specified
attributes the @indices provide an indirection for how the data
should be indexed allowing a random access order to be
specified.

For example an indices array of [0, 1, 2, 0, 2, 3] could be used
used to draw two triangles (@mode = %COGL_VERTICES_MODE_TRIANGLES +
@n_vertices = 6) but only provide attribute data for the 4 corners
of a rectangle. When the GPU needs to read in each of the 6
vertices it will read the @indices array for each vertex in
sequence and use the index to look up the vertex attribute data. So
here you can see that first and fourth vertex will point to the
same data and third and fifth vertex will also point to shared
data.

Drawing with indices can be a good way of minimizing the size of a
mesh by allowing you to avoid data for duplicate vertices because
multiple entries in the index array can refer back to a single
shared vertex.

&lt;note&gt;The @indices array must be at least as long as @first_vertex
+ @n_vertices otherwise the GPU will overrun the indices array when
looking up vertex data.&lt;/note&gt;

Since it's very common to want to draw a run of rectangles using
indices to avoid duplicating vertex data you can use
cogl_get_rectangle_indices() to get a set of indices that can be
shared.

This drawing api doesn't support high-level meta texture types such
as #CoglTexture2DSliced so it is the user's responsibility to
ensure that only low-level textures that can be directly sampled by
a GPU such as #CoglTexture2D, #CoglTextureRectangle or
#CoglTexture3D are associated with layers of the given @pipeline.

&lt;note&gt;This api doesn't support any of the legacy global state
options such as cogl_set_depth_test_enabled(),
cogl_set_backface_culling_enabled() or cogl_program_use()&lt;/note&gt;</doc>
        <doc-deprecated xml:space="preserve">Use #CoglPrimitive&lt;!-- --&gt;s and
                  cogl_primitive_draw() instead</doc-deprecated>
        <source-position filename="../cogl/cogl/cogl-framebuffer.h"
                         line="1329"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1273">A destination #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1274">A #CoglPipeline state object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1275">The #CoglVerticesMode defining the topology of vertices</doc>
            <type name="VerticesMode" c:type="CoglVerticesMode"/>
          </parameter>
          <parameter name="first_vertex" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1276">The vertex offset within the given attributes to draw from</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="n_vertices" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1277">The number of vertices to draw from the given attributes</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="indices" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1278">The array of indices used by the GPU to lookup attribute
          data for each vertex.</doc>
            <type c:type="CoglIndices*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-framebuffer.h"
                 line="1280">A set of vertex #CoglAttribute&lt;!-- --&gt;s defining vertex geometry</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <enumeration name="FramebufferError" c:type="CoglFramebufferError">
      <source-position filename="../cogl/cogl/cogl-framebuffer.h" line="1833"/>
      <member name="framebuffer_error_allocate"
              value="0"
              c:identifier="COGL_FRAMEBUFFER_ERROR_ALLOCATE">
      </member>
    </enumeration>
    <enumeration name="IndicesType" c:type="CoglIndicesType">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-types.h"
           line="610">You should aim to use the smallest data type that gives you enough
range, since it reduces the size of your index array and can help
reduce the demand on memory bandwidth.

Note that %COGL_INDICES_TYPE_UNSIGNED_INT is only supported if the
%COGL_FEATURE_ID_UNSIGNED_INT_INDICES feature is available. This
should always be available on OpenGL but on OpenGL ES it will only
be available if the GL_OES_element_index_uint extension is
advertized.</doc>
      <source-position filename="../cogl/cogl/cogl-types.h" line="631"/>
      <member name="byte"
              value="0"
              c:identifier="COGL_INDICES_TYPE_UNSIGNED_BYTE">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="612">Your indices are unsigned bytes</doc>
      </member>
      <member name="short"
              value="1"
              c:identifier="COGL_INDICES_TYPE_UNSIGNED_SHORT">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="613">Your indices are unsigned shorts</doc>
      </member>
      <member name="int"
              value="2"
              c:identifier="COGL_INDICES_TYPE_UNSIGNED_INT">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="614">Your indices are unsigned ints</doc>
      </member>
    </enumeration>
    <record name="Material"
            c:type="CoglMaterial"
            glib:type-name="CoglMaterial"
            glib:get-type="cogl_material_get_type"
            c:symbol-prefix="material">
      <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                       line="57"/>
      <constructor name="new"
                   c:identifier="cogl_material_new"
                   deprecated="1"
                   deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="145">Allocates and initializes a blank white material</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_new() instead</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="155"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-material-compat.h"
               line="150">a pointer to a new #CoglMaterial</doc>
          <type name="Material" c:type="CoglMaterial*"/>
        </return-value>
      </constructor>
      <method name="copy"
              c:identifier="cogl_material_copy"
              version="1.2"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="157">Creates a new material with the configuration copied from the
source material.

We would strongly advise developers to always aim to use
cogl_material_copy() instead of cogl_material_new() whenever there will
be any similarity between two materials. Copying a material helps Cogl
keep track of a materials ancestry which we may use to help minimize GPU
state changes.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_copy() instead</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="177"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-material-compat.h"
               line="170">a pointer to the newly allocated #CoglMaterial</doc>
          <type name="Material" c:type="CoglMaterial*"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="159">a #CoglMaterial object to copy</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="foreach_layer"
              c:identifier="cogl_material_foreach_layer"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="1374">Iterates all the layer indices of the given @material.</doc>
        <doc-deprecated xml:space="preserve">No replacement</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="1389"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1376">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1377">A #CoglMaterialLayerCallback to be called for each
           layer index</doc>
            <type name="MaterialLayerCallback"
                  c:type="CoglMaterialLayerCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1379">Private data that will be passed to the callback</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_ambient"
              c:identifier="cogl_material_get_ambient"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="328">Retrieves the current ambient color for @material</doc>
        <doc-deprecated xml:space="preserve">Use the #CoglSnippet shader api for lighting</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="340"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="330">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="ambient" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="331">The location to store the ambient color</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_color"
              c:identifier="cogl_material_get_color"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="291">Retrieves the current material color.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_get_color() instead</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="303"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="293">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="color"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="294">The location to store the color</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_depth_state"
              c:identifier="cogl_material_get_depth_state"
              version="2.0"
              introspectable="0"
              deprecated="1"
              deprecated-version="1.16"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="1340">Retrieves the current depth state configuration for the given
@pipeline as previously set using cogl_pipeline_set_depth_state().</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_get_depth_state() instead</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="1354"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1342">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="state_out" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1343">A destination #CoglDepthState struct</doc>
            <type c:type="CoglDepthState*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_diffuse"
              c:identifier="cogl_material_get_diffuse"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="362">Retrieves the current diffuse color for @material</doc>
        <doc-deprecated xml:space="preserve">Use the #CoglSnippet shader api for lighting</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="374"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="364">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="diffuse" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="365">The location to store the diffuse color</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_emission"
              c:identifier="cogl_material_get_emission"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="485">Retrieves the materials current emission color.</doc>
        <doc-deprecated xml:space="preserve">Use the #CoglSnippet shader api for lighting</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="497"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="487">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="emission" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="488">The location to store the emission color</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_layer_point_sprite_coords_enabled"
              c:identifier="cogl_material_get_layer_point_sprite_coords_enabled"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="1115">Gets whether point sprite coordinate generation is enabled for this
texture layer.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_get_layer_point_sprite_coords_enabled()
                 instead</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="1132"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-material-compat.h"
               line="1123">whether the texture coordinates will be replaced with
point sprite coordinates.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1117">a #CoglHandle to a material.</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1118">the layer number to check.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_layer_wrap_mode_p"
              c:identifier="cogl_material_get_layer_wrap_mode_p"
              version="1.6"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="1208">Returns the wrap mode for the 'p' coordinate of texture lookups on this
layer.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_get_layer_wrap_mode_p() instead</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="1224"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-material-compat.h"
               line="1216">the wrap mode for the 'p' coordinate of texture lookups on
this layer.</doc>
          <type name="MaterialWrapMode" c:type="CoglMaterialWrapMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1210">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1211">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_layer_wrap_mode_s"
              c:identifier="cogl_material_get_layer_wrap_mode_s"
              version="1.6"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="1135">Returns the wrap mode for the 's' coordinate of texture lookups on this
layer.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_get_layer_wrap_mode_s() instead</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="1151"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-material-compat.h"
               line="1143">the wrap mode for the 's' coordinate of texture lookups on
this layer.</doc>
          <type name="MaterialWrapMode" c:type="CoglMaterialWrapMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1137">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1138">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_layer_wrap_mode_t"
              c:identifier="cogl_material_get_layer_wrap_mode_t"
              version="1.6"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="1171">Returns the wrap mode for the 't' coordinate of texture lookups on this
layer.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_get_layer_wrap_mode_t() instead</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="1187"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-material-compat.h"
               line="1179">the wrap mode for the 't' coordinate of texture lookups on
this layer.</doc>
          <type name="MaterialWrapMode" c:type="CoglMaterialWrapMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1173">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1174">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_layers" c:identifier="cogl_material_get_layers">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="947">This function lets you access a material's internal list of layers
for iteration.

&lt;note&gt;You should avoid using this API if possible since it was only
made public by mistake and will be deprecated when we have
suitable alternative.&lt;/note&gt;

&lt;note&gt;It's important to understand that the list returned may not
remain valid if you modify the material or any of the layers in any
way and so you would have to re-get the list in that
situation.&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="971"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-material-compat.h"
               line="963">A
   list of #CoglMaterialLayer&lt;!-- --&gt;'s that can be passed to the
   cogl_material_layer_* functions. The list is owned by Cogl and it
   should not be modified or freed
   Deprecated: 1.16: Use cogl_pipeline_get_layers() instead</doc>
          <type name="GLib.List" c:type="const GList*">
            <type name="MaterialLayer"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="949">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_n_layers"
              c:identifier="cogl_material_get_n_layers"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="973">Retrieves the number of layers defined for the given @material</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_get_n_layers() instead</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="986"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-material-compat.h"
               line="979">the number of layers</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="975">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_point_size"
              c:identifier="cogl_material_get_point_size"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="686">Get the size of points drawn when %COGL_VERTICES_MODE_POINTS is
used with the vertex buffer API.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_get_point_size() instead</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="700"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-material-compat.h"
               line="693">the point size of the material.</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="688">a #CoglHandle to a material.</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_shininess"
              c:identifier="cogl_material_get_shininess"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="451">Retrieves the materials current emission color.</doc>
        <doc-deprecated xml:space="preserve">Use the #CoglSnippet shader api for lighting</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="464"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-material-compat.h"
               line="457">The materials current shininess value</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="453">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_specular"
              c:identifier="cogl_material_get_specular"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="416">Retrieves the materials current specular color.</doc>
        <doc-deprecated xml:space="preserve">Use the #CoglSnippet shader api for lighting</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="428"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="418">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="specular" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="419">The location to store the specular color</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_user_program"
              c:identifier="cogl_material_get_user_program"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="702">Queries what user program has been associated with the given
@material using cogl_material_set_user_program().</doc>
        <doc-deprecated xml:space="preserve">Use #CoglSnippet api instead instead</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="717"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-material-compat.h"
               line="709">The current user program
  or %COGL_INVALID_HANDLE.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="704">a #CoglMaterial object.</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_layer"
              c:identifier="cogl_material_remove_layer"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="797">This function removes a layer from your material</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_remove_layer() instead</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="807"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="799">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="800">Specifies the layer you want to remove</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_alpha_test_function"
              c:identifier="cogl_material_set_alpha_test_function"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="534">Before a primitive is blended with the framebuffer, it goes through an
alpha test stage which lets you discard fragments based on the current
alpha value. This function lets you change the function used to evaluate
the alpha channel, and thus determine which fragments are discarded
and which continue on to the blending stage.

The default is %COGL_MATERIAL_ALPHA_FUNC_ALWAYS</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_alpha_test_function() instead</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="554"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="536">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="alpha_func" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="537">A @CoglMaterialAlphaFunc constant</doc>
            <type name="MaterialAlphaFunc" c:type="CoglMaterialAlphaFunc"/>
          </parameter>
          <parameter name="alpha_reference" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="538">A reference point that the chosen alpha function uses
  to compare incoming fragments to.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ambient"
              c:identifier="cogl_material_set_ambient"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="306">Sets the material's ambient color, in the standard OpenGL lighting
model. The ambient color affects the overall color of the object.

Since the diffuse color will be intense when the light hits the surface
directly, the ambient will be most apparent where the light hits at a
slant.

The default value is (0.2, 0.2, 0.2, 1.0)</doc>
        <doc-deprecated xml:space="preserve">Use the #CoglSnippet shader api for lighting</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="325"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="308">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="ambient" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="309">The components of the desired ambient color</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ambient_and_diffuse"
              c:identifier="cogl_material_set_ambient_and_diffuse"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="377">Conveniently sets the diffuse and ambient color of @material at the same
time. See cogl_material_set_ambient() and cogl_material_set_diffuse().

The default ambient color is (0.2, 0.2, 0.2, 1.0)

The default diffuse color is (0.8, 0.8, 0.8, 1.0)</doc>
        <doc-deprecated xml:space="preserve">Use the #CoglSnippet shader api for lighting</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="394"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="379">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="380">The components of the desired ambient and diffuse colors</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blend"
              c:identifier="cogl_material_set_blend"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16"
              throws="1">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="558">If not already familiar; please refer &lt;link linkend="cogl-Blend-Strings"&gt;here&lt;/link&gt;
for an overview of what blend strings are, and their syntax.

Blending occurs after the alpha test function, and combines fragments with
the framebuffer.

Currently the only blend function Cogl exposes is ADD(). So any valid
blend statements will be of the form:

|[
  &amp;lt;channel-mask&amp;gt;=ADD(SRC_COLOR*(&amp;lt;factor&amp;gt;), DST_COLOR*(&amp;lt;factor&amp;gt;))
]|

&lt;warning&gt;The brackets around blend factors are currently not
optional!&lt;/warning&gt;

This is the list of source-names usable as blend factors:
&lt;itemizedlist&gt;
  &lt;listitem&gt;&lt;para&gt;SRC_COLOR: The color of the in comming fragment&lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;DST_COLOR: The color of the framebuffer&lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;CONSTANT: The constant set via cogl_material_set_blend_constant()&lt;/para&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;

The source names can be used according to the
&lt;link linkend="cogl-Blend-String-syntax"&gt;color-source and factor syntax&lt;/link&gt;,
so for example "(1-SRC_COLOR[A])" would be a valid factor, as would
"(CONSTANT[RGB])"

These can also be used as factors:
&lt;itemizedlist&gt;
  &lt;listitem&gt;0: (0, 0, 0, 0)&lt;/listitem&gt;
  &lt;listitem&gt;1: (1, 1, 1, 1)&lt;/listitem&gt;
  &lt;listitem&gt;SRC_ALPHA_SATURATE_FACTOR: (f,f,f,1) where f = MIN(SRC_COLOR[A],1-DST_COLOR[A])&lt;/listitem&gt;
&lt;/itemizedlist&gt;

&lt;note&gt;Remember; all color components are normalized to the range [0, 1]
before computing the result of blending.&lt;/note&gt;

&lt;example id="cogl-Blend-Strings-blend-unpremul"&gt;
  &lt;title&gt;Blend Strings/1&lt;/title&gt;
  &lt;para&gt;Blend a non-premultiplied source over a destination with
  premultiplied alpha:&lt;/para&gt;
  &lt;programlisting&gt;
"RGB = ADD(SRC_COLOR*(SRC_COLOR[A]), DST_COLOR*(1-SRC_COLOR[A]))"
"A   = ADD(SRC_COLOR, DST_COLOR*(1-SRC_COLOR[A]))"
  &lt;/programlisting&gt;
&lt;/example&gt;

&lt;example id="cogl-Blend-Strings-blend-premul"&gt;
  &lt;title&gt;Blend Strings/2&lt;/title&gt;
  &lt;para&gt;Blend a premultiplied source over a destination with
  premultiplied alpha&lt;/para&gt;
  &lt;programlisting&gt;
"RGBA = ADD(SRC_COLOR, DST_COLOR*(1-SRC_COLOR[A]))"
  &lt;/programlisting&gt;
&lt;/example&gt;

The default blend string is:
|[
   RGBA = ADD (SRC_COLOR, DST_COLOR*(1-SRC_COLOR[A]))
]|

That gives normal alpha-blending when the calculated color for the material
is in premultiplied form.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_blend() instead</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="645"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-material-compat.h"
               line="635">%TRUE if the blend string was successfully parsed, and the
  described blending is supported by the underlying driver/hardware. If
  there was an error, %FALSE is returned and @error is set accordingly (if
  present).</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="560">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="blend_string" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="561">A &lt;link linkend="cogl-Blend-Strings"&gt;Cogl blend string&lt;/link&gt;
  describing the desired blend function.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blend_constant"
              c:identifier="cogl_material_set_blend_constant"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="649">When blending is setup to reference a CONSTANT blend factor then
blending will depend on the constant set with this function.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_blend_constant() instead</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="662"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="651">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="constant_color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="652">The constant color you want</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_color"
              c:identifier="cogl_material_set_color"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="223">Sets the basic color of the material, used when no lighting is enabled.

Note that if you don't add any layers to the material then the color
will be blended unmodified with the destination; the default blend
expects premultiplied colors: for example, use (0.5, 0.0, 0.0, 0.5) for
semi-transparent red. See cogl_color_premultiply().

The default value is (1.0, 1.0, 1.0, 1.0)</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_color() instead</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="242"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="225">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="226">The components of the color</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_color4f"
              c:identifier="cogl_material_set_color4f"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="268">Sets the basic color of the material, used when no lighting is enabled.

The default value is (1.0, 1.0, 1.0, 1.0)</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_color4f() instead</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="285"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="270">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="271">The red component</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="272">The green component</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="273">The blue component</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="274">The alpha component</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_color4ub"
              c:identifier="cogl_material_set_color4ub"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="245">Sets the basic color of the material, used when no lighting is enabled.

The default value is (0xff, 0xff, 0xff, 0xff)</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_color4ub() instead</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="262"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="247">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="248">The red component</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="249">The green component</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="250">The blue component</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="251">The alpha component</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_depth_state"
              c:identifier="cogl_material_set_depth_state"
              version="1.8"
              introspectable="0"
              deprecated="1"
              deprecated-version="1.16"
              stability="Unstable"
              throws="1">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="1313">This commits all the depth state configured in @state struct to the
given @material. The configuration values are copied into the
material so there is no requirement to keep the #CoglDepthState
struct around if you don't need it any more.

Note: Since some platforms do not support the depth range feature
it is possible for this function to fail and report an @error.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_depth_state() instead</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="1336"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-material-compat.h"
               line="1327">TRUE if the GPU supports all the given @state else %FALSE
         and returns an @error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1315">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="state" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1316">A #CoglDepthState struct</doc>
            <type c:type="const CoglDepthState*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_diffuse"
              c:identifier="cogl_material_set_diffuse"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="343">Sets the material's diffuse color, in the standard OpenGL lighting
model. The diffuse color is most intense where the light hits the
surface directly - perpendicular to the surface.

The default value is (0.8, 0.8, 0.8, 1.0)</doc>
        <doc-deprecated xml:space="preserve">Use the #CoglSnippet shader api for lighting</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="359"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="345">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="diffuse" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="346">The components of the desired diffuse color</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_emission"
              c:identifier="cogl_material_set_emission"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="466">Sets the material's emissive color, in the standard OpenGL lighting
model. It will look like the surface is a light source emitting this
color.

The default value is (0.0, 0.0, 0.0, 1.0)</doc>
        <doc-deprecated xml:space="preserve">Use the #CoglSnippet shader api for lighting</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="482"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="468">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="emission" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="469">The components of the desired emissive color</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer"
              c:identifier="cogl_material_set_layer"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="771">In addition to the standard OpenGL lighting model a Cogl material may have
one or more layers comprised of textures that can be blended together in
order, with a number of different texture combine modes. This function
defines a new texture layer.

The index values of multiple layers do not have to be consecutive; it is
only their relative order that is important.

&lt;note&gt;In the future, we may define other types of material layers, such
as purely GLSL based layers.&lt;/note&gt;</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_layer() instead</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="793"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="773">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="774">the index of the layer</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="775">a #CoglHandle for the layer object</doc>
            <type name="Handle" c:type="CoglHandle"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_combine"
              c:identifier="cogl_material_set_layer_combine"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16"
              throws="1">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="811">If not already familiar; you can refer
&lt;link linkend="cogl-Blend-Strings"&gt;here&lt;/link&gt; for an overview of what blend
strings are and there syntax.

These are all the functions available for texture combining:
&lt;itemizedlist&gt;
  &lt;listitem&gt;REPLACE(arg0) = arg0&lt;/listitem&gt;
  &lt;listitem&gt;MODULATE(arg0, arg1) = arg0 x arg1&lt;/listitem&gt;
  &lt;listitem&gt;ADD(arg0, arg1) = arg0 + arg1&lt;/listitem&gt;
  &lt;listitem&gt;ADD_SIGNED(arg0, arg1) = arg0 + arg1 - 0.5&lt;/listitem&gt;
  &lt;listitem&gt;INTERPOLATE(arg0, arg1, arg2) = arg0 x arg2 + arg1 x (1 - arg2)&lt;/listitem&gt;
  &lt;listitem&gt;SUBTRACT(arg0, arg1) = arg0 - arg1&lt;/listitem&gt;
  &lt;listitem&gt;
    &lt;programlisting&gt;
 DOT3_RGB(arg0, arg1) = 4 x ((arg0[R] - 0.5)) * (arg1[R] - 0.5) +
                             (arg0[G] - 0.5)) * (arg1[G] - 0.5) +
                             (arg0[B] - 0.5)) * (arg1[B] - 0.5))
    &lt;/programlisting&gt;
  &lt;/listitem&gt;
  &lt;listitem&gt;
    &lt;programlisting&gt;
 DOT3_RGBA(arg0, arg1) = 4 x ((arg0[R] - 0.5)) * (arg1[R] - 0.5) +
                              (arg0[G] - 0.5)) * (arg1[G] - 0.5) +
                              (arg0[B] - 0.5)) * (arg1[B] - 0.5))
    &lt;/programlisting&gt;
  &lt;/listitem&gt;
&lt;/itemizedlist&gt;

Refer to the
&lt;link linkend="cogl-Blend-String-syntax"&gt;color-source syntax&lt;/link&gt; for
describing the arguments. The valid source names for texture combining
are:
&lt;variablelist&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;TEXTURE&lt;/term&gt;
    &lt;listitem&gt;Use the color from the current texture layer&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;TEXTURE_0, TEXTURE_1, etc&lt;/term&gt;
    &lt;listitem&gt;Use the color from the specified texture layer&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;CONSTANT&lt;/term&gt;
    &lt;listitem&gt;Use the color from the constant given with
    cogl_material_set_layer_constant()&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;PRIMARY&lt;/term&gt;
    &lt;listitem&gt;Use the color of the material as set with
    cogl_material_set_color()&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;PREVIOUS&lt;/term&gt;
    &lt;listitem&gt;Either use the texture color from the previous layer, or
    if this is layer 0, use the color of the material as set with
    cogl_material_set_color()&lt;/listitem&gt;
  &lt;/varlistentry&gt;
&lt;/variablelist&gt;

&lt;refsect2 id="cogl-Layer-Combine-Examples"&gt;
  &lt;title&gt;Layer Combine Examples&lt;/title&gt;
  &lt;para&gt;This is effectively what the default blending is:&lt;/para&gt;
  &lt;informalexample&gt;&lt;programlisting&gt;
  RGBA = MODULATE (PREVIOUS, TEXTURE)
  &lt;/programlisting&gt;&lt;/informalexample&gt;
  &lt;para&gt;This could be used to cross-fade between two images, using
  the alpha component of a constant as the interpolator. The constant
  color is given by calling cogl_material_set_layer_constant.&lt;/para&gt;
  &lt;informalexample&gt;&lt;programlisting&gt;
  RGBA = INTERPOLATE (PREVIOUS, TEXTURE, CONSTANT[A])
  &lt;/programlisting&gt;&lt;/informalexample&gt;
&lt;/refsect2&gt;

&lt;note&gt;You can't give a multiplication factor for arguments as you can
with blending.&lt;/note&gt;</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_layer_combine() instead</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="906"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-material-compat.h"
               line="897">%TRUE if the blend string was successfully parsed, and the
  described texture combining is supported by the underlying driver and
  or hardware. On failure, %FALSE is returned and @error is set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="813">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="814">Specifies the layer you want define a combine function for</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="blend_string" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="815">A &lt;link linkend="cogl-Blend-Strings"&gt;Cogl blend string&lt;/link&gt;
   describing the desired texture combine function.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_combine_constant"
              c:identifier="cogl_material_set_layer_combine_constant"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="911">When you are using the 'CONSTANT' color source in a layer combine
description then you can use this function to define its value.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_layer_combine_constant()
instead</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="927"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="913">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="914">Specifies the layer you want to specify a constant used
              for texture combining</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="constant" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="916">The constant color you want</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_filters"
              c:identifier="cogl_material_set_layer_filters"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="1067">Changes the decimation and interpolation filters used when a texture is
drawn at other scales than 100%.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_layer_filters() instead</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="1080"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1069">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1070">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="min_filter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1071">the filter used when scaling a texture down.</doc>
            <type name="MaterialFilter" c:type="CoglMaterialFilter"/>
          </parameter>
          <parameter name="mag_filter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1072">the filter used when magnifying a texture.</doc>
            <type name="MaterialFilter" c:type="CoglMaterialFilter"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_matrix"
              c:identifier="cogl_material_set_layer_matrix"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="931">This function lets you set a matrix that can be used to e.g. translate
and rotate a single layer of a material used to fill your geometry.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_layer_matrix() instead</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="943"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="933">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="934">the index for the layer inside @material</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="935">the transformation matrix for the layer</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_point_sprite_coords_enabled"
              c:identifier="cogl_material_set_layer_point_sprite_coords_enabled"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16"
              throws="1">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="1085">When rendering points, if @enable is %TRUE then the texture
coordinates for this layer will be replaced with coordinates that
vary from 0.0 to 1.0 across the primitive. The top left of the
point will have the coordinates 0.0,0.0 and the bottom right will
have 1.0,1.0. If @enable is %FALSE then the coordinates will be
fixed for the entire point.

This function will only work if %COGL_FEATURE_POINT_SPRITE is
available. If the feature is not available then the function will
return %FALSE and set @error.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_layer_point_sprite_coords_enabled()
                 instead</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="1110"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-material-compat.h"
               line="1103">%TRUE if the function succeeds, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1087">a #CoglHandle to a material.</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1088">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="enable" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1089">whether to enable point sprite coord generation.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_wrap_mode"
              c:identifier="cogl_material_set_layer_wrap_mode"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="1245">Sets the wrap mode for all three coordinates of texture lookups on
this layer. This is equivalent to calling
cogl_material_set_layer_wrap_mode_s(),
cogl_material_set_layer_wrap_mode_t() and
cogl_material_set_layer_wrap_mode_p() separately.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_layer_wrap_mode() instead</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="1262"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1247">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1248">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1249">the new wrap mode</doc>
            <type name="MaterialWrapMode" c:type="CoglMaterialWrapMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_wrap_mode_p"
              c:identifier="cogl_material_set_layer_wrap_mode_p"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="1227">Sets the wrap mode for the 'p' coordinate of texture lookups on
this layer. 'p' is the third coordinate.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_layer_wrap_mode_p() instead</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="1241"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1229">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1230">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1231">the new wrap mode</doc>
            <type name="MaterialWrapMode" c:type="CoglMaterialWrapMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_wrap_mode_s"
              c:identifier="cogl_material_set_layer_wrap_mode_s"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="1154">Sets the wrap mode for the 's' coordinate of texture lookups on this layer.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_layer_wrap_mode_s() instead</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="1167"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1156">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1157">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1158">the new wrap mode</doc>
            <type name="MaterialWrapMode" c:type="CoglMaterialWrapMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_wrap_mode_t"
              c:identifier="cogl_material_set_layer_wrap_mode_t"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="1191">Sets the wrap mode for the 't' coordinate of texture lookups on this layer.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_layer_wrap_mode_t() instead</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="1204"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1193">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1194">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1195">the new wrap mode</doc>
            <type name="MaterialWrapMode" c:type="CoglMaterialWrapMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_point_size"
              c:identifier="cogl_material_set_point_size"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="665">Changes the size of points drawn when %COGL_VERTICES_MODE_POINTS is
used with the vertex buffer API. Note that typically the GPU will
only support a limited minimum and maximum range of point sizes. If
the chosen point size is outside that range then the nearest value
within that range will be used instead. The size of a point is in
screen space so it will be the same regardless of any
transformations. The default point size is 1.0.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_point_size() instead</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="683"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="667">a material.</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="point_size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="668">the new point size.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_shininess"
              c:identifier="cogl_material_set_shininess"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="431">Sets the shininess of the material, in the standard OpenGL lighting
model, which determines the size of the specular highlights. A
higher @shininess will produce smaller highlights which makes the
object appear more shiny.

The default value is 0.0</doc>
        <doc-deprecated xml:space="preserve">Use the #CoglSnippet shader api for lighting</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="448"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="433">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="shininess" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="434">The desired shininess; must be &gt;= 0.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_specular"
              c:identifier="cogl_material_set_specular"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="397">Sets the material's specular color, in the standard OpenGL lighting
model. The intensity of the specular color depends on the viewport
position, and is brightest along the lines of reflection.

The default value is (0.0, 0.0, 0.0, 1.0)</doc>
        <doc-deprecated xml:space="preserve">Use the #CoglSnippet shader api for lighting</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="413"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="399">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="specular" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="400">The components of the desired specular color</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_user_program"
              c:identifier="cogl_material_set_user_program"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="719">Associates a linked CoglProgram with the given material so that the
program can take full control of vertex and/or fragment processing.

This is an example of how it can be used to associate an ARBfp
program with a #CoglMaterial:
|[
CoglHandle shader;
CoglHandle program;
CoglMaterial *material;

shader = cogl_create_shader (COGL_SHADER_TYPE_FRAGMENT);
cogl_shader_source (shader,
                    "!!ARBfp1.0\n"
                    "MOV result.color,fragment.color;\n"
                    "END\n");
cogl_shader_compile (shader);

program = cogl_create_program ();
cogl_program_attach_shader (program, shader);
cogl_program_link (program);

material = cogl_material_new ();
cogl_material_set_user_program (material, program);

cogl_set_source_color4ub (0xff, 0x00, 0x00, 0xff);
cogl_rectangle (0, 0, 100, 100);
]|

It is possibly worth keeping in mind that this API is not part of
the long term design for how we want to expose shaders to Cogl
developers (We are planning on deprecating the cogl_program and
cogl_shader APIs in favour of a "snippet" framework) but in the
meantime we hope this will handle most practical GLSL and ARBfp
requirements.

Also remember you need to check for either the
%COGL_FEATURE_SHADERS_GLSL or %COGL_FEATURE_SHADERS_ARBFP before
using the cogl_program or cogl_shader API.</doc>
        <doc-deprecated xml:space="preserve">Use #CoglSnippet api instead instead</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="768"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="721">a #CoglMaterial object.</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="program" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="722">A #CoglHandle to a linked CoglProgram</doc>
            <type name="Handle" c:type="CoglHandle"/>
          </parameter>
        </parameters>
      </method>
      <function name="ref"
                c:identifier="cogl_material_ref"
                version="1.0"
                deprecated="1"
                deprecated-version="1.2">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="179">Increment the reference count for a #CoglMaterial.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_object_ref() instead</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="193"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-material-compat.h"
               line="185">the @material.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </return-value>
        <parameters>
          <parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="181">a #CoglMaterial object.</doc>
            <type name="Handle" c:type="CoglHandle"/>
          </parameter>
        </parameters>
      </function>
      <function name="unref"
                c:identifier="cogl_material_unref"
                version="1.0"
                deprecated="1"
                deprecated-version="1.2">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="195">Decrement the reference count for a #CoglMaterial.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_object_unref() instead</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="207"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="197">a #CoglMaterial object.</doc>
            <type name="Handle" c:type="CoglHandle"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <enumeration name="MaterialAlphaFunc" c:type="CoglMaterialAlphaFunc">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-material-compat.h"
           line="500">Alpha testing happens before blending primitives with the framebuffer and
gives an opportunity to discard fragments based on a comparison with the
incoming alpha value and a reference alpha value. The #CoglMaterialAlphaFunc
determines how the comparison is done.</doc>
      <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                       line="532"/>
      <member name="never"
              value="512"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_NEVER">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="502">Never let the fragment through.</doc>
      </member>
      <member name="less"
              value="513"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_LESS">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="503">Let the fragment through if the incoming
  alpha value is less than the reference alpha value</doc>
      </member>
      <member name="equal"
              value="514"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_EQUAL">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="505">Let the fragment through if the incoming
  alpha value equals the reference alpha value</doc>
      </member>
      <member name="lequal"
              value="515"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_LEQUAL">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="507">Let the fragment through if the incoming
  alpha value is less than or equal to the reference alpha value</doc>
      </member>
      <member name="greater"
              value="516"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_GREATER">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="509">Let the fragment through if the incoming
  alpha value is greater than the reference alpha value</doc>
      </member>
      <member name="notequal"
              value="517"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_NOTEQUAL">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="511">Let the fragment through if the incoming
  alpha value does not equal the reference alpha value</doc>
      </member>
      <member name="gequal"
              value="518"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_GEQUAL">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="513">Let the fragment through if the incoming
  alpha value is greater than or equal to the reference alpha value.</doc>
      </member>
      <member name="always"
              value="519"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_ALWAYS">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="515">Always let the fragment through.</doc>
      </member>
    </enumeration>
    <enumeration name="MaterialFilter" c:type="CoglMaterialFilter">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-material-compat.h"
           line="65">Texture filtering is used whenever the current pixel maps either to more
than one texture element (texel) or less than one. These filter enums
correspond to different strategies used to come up with a pixel color, by
possibly referring to multiple neighbouring texels and taking a weighted
average or simply using the nearest texel.</doc>
      <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                       line="100"/>
      <member name="nearest"
              value="9728"
              c:identifier="COGL_MATERIAL_FILTER_NEAREST">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="67">Measuring in manhatten distance from the,
  current pixel center, use the nearest texture texel</doc>
      </member>
      <member name="linear"
              value="9729"
              c:identifier="COGL_MATERIAL_FILTER_LINEAR">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="69">Use the weighted average of the 4 texels
  nearest the current pixel center</doc>
      </member>
      <member name="nearest_mipmap_nearest"
              value="9984"
              c:identifier="COGL_MATERIAL_FILTER_NEAREST_MIPMAP_NEAREST">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="71">Select the mimap level whose
  texel size most closely matches the current pixel, and use the
  %COGL_MATERIAL_FILTER_NEAREST criterion</doc>
      </member>
      <member name="linear_mipmap_nearest"
              value="9985"
              c:identifier="COGL_MATERIAL_FILTER_LINEAR_MIPMAP_NEAREST">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="74">Select the mimap level whose
  texel size most closely matches the current pixel, and use the
  %COGL_MATERIAL_FILTER_LINEAR criterion</doc>
      </member>
      <member name="nearest_mipmap_linear"
              value="9986"
              c:identifier="COGL_MATERIAL_FILTER_NEAREST_MIPMAP_LINEAR">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="77">Select the two mimap levels
  whose texel size most closely matches the current pixel, use
  the %COGL_MATERIAL_FILTER_NEAREST criterion on each one and take
  their weighted average</doc>
      </member>
      <member name="linear_mipmap_linear"
              value="9987"
              c:identifier="COGL_MATERIAL_FILTER_LINEAR_MIPMAP_LINEAR">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="81">Select the two mimap levels
  whose texel size most closely matches the current pixel, use
  the %COGL_MATERIAL_FILTER_LINEAR criterion on each one and take
  their weighted average</doc>
      </member>
    </enumeration>
    <record name="MaterialLayer" c:type="CoglMaterialLayer" disguised="1">
      <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                       line="58"/>
      <method name="get_mag_filter"
              c:identifier="cogl_material_layer_get_mag_filter"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="1054">Queries the currently set downscaling filter for a material later</doc>
        <doc-deprecated xml:space="preserve">No replacement</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="1065"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-material-compat.h"
               line="1060">the current downscaling filter</doc>
          <type name="MaterialFilter" c:type="CoglMaterialFilter"/>
        </return-value>
        <parameters>
          <instance-parameter name="layer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1056">A #CoglMaterialLayer object</doc>
            <type name="MaterialLayer" c:type="CoglMaterialLayer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_min_filter"
              c:identifier="cogl_material_layer_get_min_filter"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="1041">Queries the currently set downscaling filter for a material layer</doc>
        <doc-deprecated xml:space="preserve">No replacement</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="1052"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-material-compat.h"
               line="1047">the current downscaling filter</doc>
          <type name="MaterialFilter" c:type="CoglMaterialFilter"/>
        </return-value>
        <parameters>
          <instance-parameter name="layer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1043">a #CoglHandle for a material layer</doc>
            <type name="MaterialLayer" c:type="CoglMaterialLayer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_texture"
              c:identifier="cogl_material_layer_get_texture"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="1022">Extracts a texture handle for a specific layer.

&lt;note&gt;In the future Cogl may support purely GLSL based layers; for those
layers this function which will likely return %COGL_INVALID_HANDLE if you
try to get the texture handle from them. Considering this scenario, you
should call cogl_material_layer_get_type() first in order check it is of
type %COGL_MATERIAL_LAYER_TYPE_TEXTURE before calling this function.&lt;/note&gt;</doc>
        <doc-deprecated xml:space="preserve">No replacement</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="1039"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-material-compat.h"
               line="1034">a #CoglHandle for the texture inside the layer</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </return-value>
        <parameters>
          <instance-parameter name="layer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1024">A #CoglMaterialLayer object</doc>
            <type name="MaterialLayer" c:type="CoglMaterialLayer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_type"
              c:identifier="cogl_material_layer_get_type"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="1004">Retrieves the type of the layer

Currently there is only one type of layer defined:
%COGL_MATERIAL_LAYER_TYPE_TEXTURE, but considering we may add purely GLSL
based layers in the future, you should write code that checks the type
first.</doc>
        <doc-deprecated xml:space="preserve">No replacement</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="1020"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-material-compat.h"
               line="1015">the type of the layer</doc>
          <type name="MaterialLayerType" c:type="CoglMaterialLayerType"/>
        </return-value>
        <parameters>
          <instance-parameter name="layer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1006">A #CoglMaterialLayer object</doc>
            <type name="MaterialLayer" c:type="CoglMaterialLayer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_wrap_mode_p"
              c:identifier="cogl_material_layer_get_wrap_mode_p"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="1297">Gets the wrap mode for the 'p' coordinate of texture lookups on
this layer. 'p' is the third coordinate.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_layer_get_wrap_mode_p() instead</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="1311"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-material-compat.h"
               line="1304">the wrap mode value for the p coordinate.</doc>
          <type name="MaterialWrapMode" c:type="CoglMaterialWrapMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="layer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1299">A #CoglMaterialLayer object</doc>
            <type name="MaterialLayer" c:type="CoglMaterialLayer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_wrap_mode_s"
              c:identifier="cogl_material_layer_get_wrap_mode_s"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="1266">Gets the wrap mode for the 's' coordinate of texture lookups on this layer.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_layer_get_wrap_mode_s() instead</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="1279"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-material-compat.h"
               line="1272">the wrap mode value for the s coordinate.</doc>
          <type name="MaterialWrapMode" c:type="CoglMaterialWrapMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="layer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1268">A #CoglMaterialLayer object</doc>
            <type name="MaterialLayer" c:type="CoglMaterialLayer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_wrap_mode_t"
              c:identifier="cogl_material_layer_get_wrap_mode_t"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="1281">Gets the wrap mode for the 't' coordinate of texture lookups on this layer.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_layer_get_wrap_mode_t() instead</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                         line="1295"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-material-compat.h"
               line="1287">the wrap mode value for the t coordinate.</doc>
          <type name="MaterialWrapMode" c:type="CoglMaterialWrapMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="layer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                 line="1283">A #CoglMaterialLayer object</doc>
            <type name="MaterialLayer" c:type="CoglMaterialLayer*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <callback name="MaterialLayerCallback"
              c:type="CoglMaterialLayerCallback"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-material-compat.h"
           line="1357">The callback prototype used with cogl_material_foreach_layer() for
iterating all the layers of a @material.</doc>
      <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                       line="1370"/>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="material" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-material-compat.h"
               line="1359">The #CoglMaterial whos layers are being iterated</doc>
          <type name="Material" c:type="CoglMaterial*"/>
        </parameter>
        <parameter name="layer_index" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-material-compat.h"
               line="1360">The current layer index</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="2">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-material-compat.h"
               line="1361">The private data passed to cogl_material_foreach_layer()</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="MaterialLayerType"
                 version="1.0"
                 c:type="CoglMaterialLayerType">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-material-compat.h"
           line="988">Available types of layers for a #CoglMaterial. This enumeration
might be expanded in later versions.</doc>
      <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                       line="1001"/>
      <member name="material_layer_type_texture"
              value="0"
              c:identifier="COGL_MATERIAL_LAYER_TYPE_TEXTURE">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="990">The layer represents a
  &lt;link linkend="cogl-Textures"&gt;texture&lt;/link&gt;</doc>
      </member>
    </enumeration>
    <enumeration name="MaterialWrapMode"
                 version="1.4"
                 c:type="CoglMaterialWrapMode">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-material-compat.h"
           line="103">The wrap mode specifies what happens when texture coordinates
outside the range 01 are used. Note that if the filter mode is
anything but %COGL_MATERIAL_FILTER_NEAREST then texels outside the
range 01 might be used even when the coordinate is exactly 0 or 1
because OpenGL will try to sample neighbouring pixels. For example
if you are trying to render the full texture then you may get
artifacts around the edges when the pixels from the other side are
merged in if the wrap mode is set to repeat.</doc>
      <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                       line="142"/>
      <member name="repeat"
              value="10497"
              c:identifier="COGL_MATERIAL_WRAP_MODE_REPEAT">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="105">The texture will be repeated. This
  is useful for example to draw a tiled background.</doc>
      </member>
      <member name="clamp_to_edge"
              value="33071"
              c:identifier="COGL_MATERIAL_WRAP_MODE_CLAMP_TO_EDGE">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="107">The coordinates outside the
  range 01 will sample copies of the edge pixels of the
  texture. This is useful to avoid artifacts if only one copy of
  the texture is being rendered.</doc>
      </member>
      <member name="automatic"
              value="519"
              c:identifier="COGL_MATERIAL_WRAP_MODE_AUTOMATIC">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="111">Cogl will try to automatically
  decide which of the above two to use. For cogl_rectangle(), it
  will use repeat mode if any of the texture coordinates are
  outside the range 01, otherwise it will use clamp to edge. For
  cogl_polygon() it will always use repeat mode. For
  cogl_vertex_buffer_draw() it will use repeat mode except for
  layers that have point sprite coordinate generation enabled. This
  is the default value.</doc>
      </member>
    </enumeration>
    <record name="Matrix"
            c:type="CoglMatrix"
            glib:type-name="CoglMatrix"
            glib:get-type="cogl_matrix_get_gtype"
            c:symbol-prefix="matrix">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-matrix.h"
           line="58">A CoglMatrix holds a 4x4 transform matrix. This is a single precision,
column-major matrix which means it is compatible with what OpenGL expects.

A CoglMatrix can represent transforms such as, rotations, scaling,
translation, sheering, and linear projections. You can combine these
transforms by multiplying multiple matrices in the order you want them
applied.

The transformation of a vertex (x, y, z, w) by a CoglMatrix is given by:

|[
  x_new = xx * x + xy * y + xz * z + xw * w
  y_new = yx * x + yy * y + yz * z + yw * w
  z_new = zx * x + zy * y + zz * z + zw * w
  w_new = wx * x + wy * y + wz * z + ww * w
]|

Where w is normally 1

&lt;note&gt;You must consider the members of the CoglMatrix structure read only,
and all matrix modifications must be done via the cogl_matrix API. This
allows Cogl to annotate the matrices internally. Violation of this will give
undefined results. If you need to initialize a matrix with a constant other
than the identity matrix you can use cogl_matrix_init_from_array().&lt;/note&gt;</doc>
      <source-position filename="../cogl/cogl/cogl-matrix.h" line="120"/>
      <field name="xx" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="yx" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="zx" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="wx" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="xy" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="yy" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="zy" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="wy" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="xz" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="yz" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="zz" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="wz" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="xw" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="yw" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="zw" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="ww" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="private_member_inv" readable="0" private="1">
        <array zero-terminated="0" fixed-size="16">
          <type name="gfloat" c:type="float"/>
        </array>
      </field>
      <field name="private_member_type" readable="0" private="1">
        <type name="gulong" c:type="unsigned long"/>
      </field>
      <field name="private_member_flags" readable="0" private="1">
        <type name="gulong" c:type="unsigned long"/>
      </field>
      <field name="private_member__padding3" readable="0" private="1">
        <type name="gulong" c:type="unsigned long"/>
      </field>
      <method name="copy" c:identifier="cogl_matrix_copy" version="1.6">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-matrix.h"
             line="555">Allocates a new #CoglMatrix on the heap and initializes it with
the same values as @matrix.</doc>
        <source-position filename="../cogl/cogl/cogl-matrix.h" line="568"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-matrix.h"
               line="562">A newly allocated #CoglMatrix which
should be freed using cogl_matrix_free()</doc>
          <type name="Matrix" c:type="CoglMatrix*"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="557">A 4x4 transformation matrix you want to copy</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="cogl_matrix_free" version="1.6">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-matrix.h"
             line="570">Frees a #CoglMatrix that was previously allocated via a call to
cogl_matrix_copy().</doc>
        <source-position filename="../cogl/cogl/cogl-matrix.h" line="580"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="572">A 4x4 transformation matrix you want to free</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="frustum" c:identifier="cogl_matrix_frustum">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-matrix.h"
             line="314">Multiplies @matrix by the given frustum perspective matrix.</doc>
        <source-position filename="../cogl/cogl/cogl-matrix.h" line="331"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="316">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="317">X position of the left clipping plane where it
  intersects the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="319">X position of the right clipping plane where it
  intersects the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="bottom" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="321">Y position of the bottom clipping plane where it
  intersects the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="top" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="323">Y position of the top clipping plane where it intersects
  the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_near" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="325">The distance to the near clipping plane (Must be positive)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_far" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="326">The distance to the far clipping plane (Must be positive)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_array" c:identifier="cogl_matrix_get_array">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-matrix.h"
             line="507">Casts @matrix to a float array which can be directly passed to OpenGL.</doc>
        <source-position filename="../cogl/cogl/cogl-matrix.h" line="516"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-matrix.h"
               line="513">a pointer to the float array</doc>
          <type name="gfloat" c:type="const float*"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="509">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_inverse"
              c:identifier="cogl_matrix_get_inverse"
              version="1.2">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-matrix.h"
             line="582">Gets the inverse transform of a given matrix and uses it to initialize
a new #CoglMatrix.

&lt;note&gt;Although the first parameter is annotated as const to indicate
that the transform it represents isn't modified this function may
technically save a copy of the inverse transform within the given
#CoglMatrix so that subsequent requests for the inverse transform may
avoid costly inversion calculations.&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/cogl-matrix.h" line="603"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-matrix.h"
               line="596">%TRUE if the inverse was successfully calculated or %FALSE
  for degenerate transformations that can't be inverted (in this case the
  @inverse matrix will simply be initialized with the identity matrix)</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="584">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </instance-parameter>
          <parameter name="inverse"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="585">The destination for a 4x4 inverse transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_array"
              c:identifier="cogl_matrix_init_from_array">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-matrix.h"
             line="496">Initializes @matrix with the contents of @array</doc>
        <source-position filename="../cogl/cogl/cogl-matrix.h" line="504"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="498">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="499">A linear array of 16 floats (column-major order)</doc>
            <type name="gfloat" c:type="const float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_euler"
              c:identifier="cogl_matrix_init_from_euler">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-matrix.h"
             line="529">Initializes @matrix from a #CoglEuler rotation.</doc>
        <source-position filename="../cogl/cogl/cogl-matrix.h" line="537"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="531">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="euler" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="532">A #CoglEuler</doc>
            <type name="Euler" c:type="const CoglEuler*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_quaternion"
              c:identifier="cogl_matrix_init_from_quaternion">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-matrix.h"
             line="518">Initializes @matrix from a #CoglQuaternion rotation.</doc>
        <source-position filename="../cogl/cogl/cogl-matrix.h" line="526"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="520">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="quaternion" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="521">A #CoglQuaternion</doc>
            <type name="Quaternion" c:type="const CoglQuaternion*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_identity" c:identifier="cogl_matrix_init_identity">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-matrix.h"
             line="124">Resets matrix to the identity matrix:

|[
  .xx=1; .xy=0; .xz=0; .xw=0;
  .yx=0; .yy=1; .yz=0; .yw=0;
  .zx=0; .zy=0; .zz=1; .zw=0;
  .wx=0; .wy=0; .wz=0; .ww=1;
]|</doc>
        <source-position filename="../cogl/cogl/cogl-matrix.h" line="138"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="126">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init_translation"
              c:identifier="cogl_matrix_init_translation"
              version="2.0">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-matrix.h"
             line="140">Resets matrix to the (tx, ty, tz) translation matrix:

|[
  .xx=1; .xy=0; .xz=0; .xw=tx;
  .yx=0; .yy=1; .yz=0; .yw=ty;
  .zx=0; .zy=0; .zz=1; .zw=tz;
  .wx=0; .wy=0; .wz=0; .ww=1;
]|</doc>
        <source-position filename="../cogl/cogl/cogl-matrix.h" line="159"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="142">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="tx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="143">x coordinate of the translation vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="ty" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="144">y coordinate of the translation vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="tz" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="145">z coordinate of the translation vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_identity"
              c:identifier="cogl_matrix_is_identity"
              version="1.8">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-matrix.h"
             line="741">Determines if the given matrix is an identity matrix.</doc>
        <source-position filename="../cogl/cogl/cogl-matrix.h" line="751"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-matrix.h"
               line="747">%TRUE if @matrix is an identity matrix else %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="743">A #CoglMatrix</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="look_at"
              c:identifier="cogl_matrix_look_at"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-matrix.h"
             line="259">Applies a view transform @matrix that positions the camera at
the coordinate (@eye_position_x, @eye_position_y, @eye_position_z)
looking towards an object at the coordinate (@object_x, @object_y,
@object_z). The top of the camera is aligned to the given world up
vector, which is normally simply (0, 1, 0) to map up to the
positive direction of the y axis.

Because there is a lot of missleading documentation online for
gluLookAt regarding the up vector we want to try and be a bit
clearer here.

The up vector should simply be relative to your world coordinates
and does not need to change as you move the eye and object
positions.  Many online sources may claim that the up vector needs
to be perpendicular to the vector between the eye and object
position (partly because the man page is somewhat missleading) but
that is not necessary for this function.

&lt;note&gt;You should never look directly along the world-up
vector.&lt;/note&gt;

&lt;note&gt;It is assumed you are using a typical projection matrix where
your origin maps to the center of your viewport.&lt;/note&gt;

&lt;note&gt;Almost always when you use this function it should be the first
transform applied to a new modelview transform&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/cogl-matrix.h" line="303"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="261">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="eye_position_x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="262">The X coordinate to look from</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="eye_position_y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="263">The Y coordinate to look from</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="eye_position_z" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="264">The Z coordinate to look from</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="object_x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="265">The X coordinate of the object to look at</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="object_y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="266">The Y coordinate of the object to look at</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="object_z" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="267">The Z coordinate of the object to look at</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="world_up_x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="268">The X component of the world's up direction vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="world_up_y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="269">The Y component of the world's up direction vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="world_up_z" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="270">The Z component of the world's up direction vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="multiply" c:identifier="cogl_matrix_multiply">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-matrix.h"
             line="164">Multiplies the two supplied matrices together and stores
the resulting matrix inside @result.

&lt;note&gt;It is possible to multiply the @a matrix in-place, so
@result can be equal to @a but can't be equal to @b.&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/cogl-matrix.h" line="177"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="166">The address of a 4x4 matrix to store the result in</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="167">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="168">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ortho"
              c:identifier="cogl_matrix_ortho"
              deprecated="1"
              deprecated-version="1.10">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-matrix.h"
             line="390">Multiplies @matrix by a parallel projection matrix.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_matrix_orthographic()</doc-deprecated>
        <source-position filename="../cogl/cogl/cogl-matrix.h" line="410"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="392">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="393">The coordinate for the left clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="394">The coordinate for the right clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="bottom" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="395">The coordinate for the bottom clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="top" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="396">The coordinate for the top clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="near" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="397">The &lt;emphasis&gt;distance&lt;/emphasis&gt; to the near clipping
  plane (will be &lt;emphasis&gt;negative&lt;/emphasis&gt; if the plane is
  behind the viewer)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="far" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="400">The &lt;emphasis&gt;distance&lt;/emphasis&gt; to the far clipping
  plane (will be &lt;emphasis&gt;negative&lt;/emphasis&gt; if the plane is
  behind the viewer)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="orthographic"
              c:identifier="cogl_matrix_orthographic"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-matrix.h"
             line="362">Multiplies @matrix by a parallel projection matrix.</doc>
        <source-position filename="../cogl/cogl/cogl-matrix.h" line="382"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="364">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="x_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="365">The x coordinate for the first vertical clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="366">The y coordinate for the first horizontal clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="367">The x coordinate for the second vertical clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="368">The y coordinate for the second horizontal clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="near" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="369">The &lt;emphasis&gt;distance&lt;/emphasis&gt; to the near clipping
  plane (will be &lt;emphasis&gt;negative&lt;/emphasis&gt; if the plane is
  behind the viewer)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="far" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="372">The &lt;emphasis&gt;distance&lt;/emphasis&gt; to the far clipping
  plane (will be &lt;emphasis&gt;negative&lt;/emphasis&gt; if the plane is
  behind the viewer)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="perspective" c:identifier="cogl_matrix_perspective">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-matrix.h"
             line="339">Multiplies @matrix by the described perspective matrix

&lt;note&gt;You should be careful not to have to great a @z_far / @z_near
ratio since that will reduce the effectiveness of depth testing
since there wont be enough precision to identify the depth of
objects near to each other.&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/cogl-matrix.h" line="356"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="341">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="fov_y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="342">Vertical field of view angle in degrees.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="aspect" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="343">The (width over height) aspect ratio for display</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_near" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="344">The distance to the near clipping plane (Must be positive,
  and must not be 0)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_far" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="346">The distance to the far clipping plane (Must be positive)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="project_points"
              c:identifier="cogl_matrix_project_points"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-matrix.h"
             line="686">Projects an array of input points and writes the result to another
array of output points. The input points can either have 2, 3 or 4
components each. The output points always have 4 components (known
as homogenous coordinates). The output array can simply point to
the input array to do the transform in-place.

Here's an example with differing input/output strides:
|[
typedef struct {
  float x,y;
  uint8_t r,g,b,a;
  float s,t,p;
} MyInVertex;
typedef struct {
  uint8_t r,g,b,a;
  float x,y,z;
} MyOutVertex;
MyInVertex vertices[N_VERTICES];
MyOutVertex results[N_VERTICES];
CoglMatrix matrix;

my_load_vertices (vertices);
my_get_matrix (&amp;matrix);

cogl_matrix_project_points (&amp;matrix,
                            2,
                            sizeof (MyInVertex),
                            &amp;vertices[0].x,
                            sizeof (MyOutVertex),
                            &amp;results[0].x,
                            N_VERTICES);
]|</doc>
        <source-position filename="../cogl/cogl/cogl-matrix.h" line="733"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="688">A projection matrix</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </instance-parameter>
          <parameter name="n_components" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="689">The number of position components for each input point.
               (either 2, 3 or 4)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="stride_in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="691">The stride in bytes between input points.</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
          <parameter name="points_in"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="692">A pointer to the first component of the first input point.</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="stride_out" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="693">The stride in bytes between output points.</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
          <parameter name="points_out"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="694">A pointer to the first component of the first output point.</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="n_points" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="695">The number of points to transform.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="rotate" c:identifier="cogl_matrix_rotate">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-matrix.h"
             line="181">Multiplies @matrix with a rotation matrix that applies a rotation
of @angle degrees around the specified 3D vector.</doc>
        <source-position filename="../cogl/cogl/cogl-matrix.h" line="193"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="183">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="184">The angle you want to rotate in degrees</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="185">X component of your rotation vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="186">Y component of your rotation vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="187">Z component of your rotation vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="rotate_euler"
              c:identifier="cogl_matrix_rotate_euler"
              version="2.0">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-matrix.h"
             line="213">Multiplies @matrix with a rotation transformation described by the
given #CoglEuler.</doc>
        <source-position filename="../cogl/cogl/cogl-matrix.h" line="224"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="215">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="euler" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="216">A euler describing a rotation</doc>
            <type name="Euler" c:type="const CoglEuler*"/>
          </parameter>
        </parameters>
      </method>
      <method name="rotate_quaternion"
              c:identifier="cogl_matrix_rotate_quaternion"
              version="2.0">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-matrix.h"
             line="199">Multiplies @matrix with a rotation transformation described by the
given #CoglQuaternion.</doc>
        <source-position filename="../cogl/cogl/cogl-matrix.h" line="210"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="201">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="quaternion" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="202">A quaternion describing a rotation</doc>
            <type name="Quaternion" c:type="const CoglQuaternion*"/>
          </parameter>
        </parameters>
      </method>
      <method name="scale" c:identifier="cogl_matrix_scale">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-matrix.h"
             line="243">Multiplies @matrix with a transform matrix that scales along the X,
Y and Z axis.</doc>
        <source-position filename="../cogl/cogl/cogl-matrix.h" line="254"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="245">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="sx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="246">The X scale factor</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="sy" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="247">The Y scale factor</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="sz" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="248">The Z scale factor</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform_point"
              c:identifier="cogl_matrix_transform_point">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-matrix.h"
             line="610">Transforms a point whos position is given and returned as four float
components.</doc>
        <source-position filename="../cogl/cogl/cogl-matrix.h" line="622"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="612">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </instance-parameter>
          <parameter name="x"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="613">The X component of your points position</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="y"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="614">The Y component of your points position</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="z"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="615">The Z component of your points position</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="w"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="616">The W component of your points position</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform_points"
              c:identifier="cogl_matrix_transform_points"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-matrix.h"
             line="628">Transforms an array of input points and writes the result to
another array of output points. The input points can either have 2
or 3 components each. The output points always have 3 components.
The output array can simply point to the input array to do the
transform in-place.

If you need to transform 4 component points see
cogl_matrix_project_points().

Here's an example with differing input/output strides:
|[
typedef struct {
  float x,y;
  uint8_t r,g,b,a;
  float s,t,p;
} MyInVertex;
typedef struct {
  uint8_t r,g,b,a;
  float x,y,z;
} MyOutVertex;
MyInVertex vertices[N_VERTICES];
MyOutVertex results[N_VERTICES];
CoglMatrix matrix;

my_load_vertices (vertices);
my_get_matrix (&amp;matrix);

cogl_matrix_transform_points (&amp;matrix,
                              2,
                              sizeof (MyInVertex),
                              &amp;vertices[0].x,
                              sizeof (MyOutVertex),
                              &amp;results[0].x,
                              N_VERTICES);
]|</doc>
        <source-position filename="../cogl/cogl/cogl-matrix.h" line="678"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="630">A transformation matrix</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </instance-parameter>
          <parameter name="n_components" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="631">The number of position components for each input point.
               (either 2 or 3)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="stride_in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="633">The stride in bytes between input points.</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
          <parameter name="points_in"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="634">A pointer to the first component of the first input point.</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="stride_out" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="635">The stride in bytes between output points.</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
          <parameter name="points_out"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="636">A pointer to the first component of the first output point.</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="n_points" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="637">The number of points to transform.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="translate" c:identifier="cogl_matrix_translate">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-matrix.h"
             line="227">Multiplies @matrix with a transform matrix that translates along
the X, Y and Z axis.</doc>
        <source-position filename="../cogl/cogl/cogl-matrix.h" line="238"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="229">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="230">The X translation you want to apply</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="231">The Y translation you want to apply</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="232">The Z translation you want to apply</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="transpose"
              c:identifier="cogl_matrix_transpose"
              version="1.10">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-matrix.h"
             line="753">Replaces @matrix with its transpose. Ie, every element (i,j) in the
new matrix is taken from element (j,i) in the old matrix.</doc>
        <source-position filename="../cogl/cogl/cogl-matrix.h" line="763"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="755">A #CoglMatrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="view_2d_in_frustum"
              c:identifier="cogl_matrix_view_2d_in_frustum"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-matrix.h"
             line="418">Multiplies @matrix by a view transform that maps the 2D coordinates
(0,0) top left and (@width_2d,@height_2d) bottom right the full viewport
size. Geometry at a depth of 0 will now lie on this 2D plane.

Note: this doesn't multiply the matrix by any projection matrix,
but it assumes you have a perspective projection as defined by
passing the corresponding arguments to cogl_matrix_frustum().

Toolkits such as Clutter that mix 2D and 3D drawing can use this to
create a 2D coordinate system within a 3D perspective projected
view frustum.</doc>
        <source-position filename="../cogl/cogl/cogl-matrix.h" line="449"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="420">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="421">coord of left vertical clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="422">coord of right vertical clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="bottom" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="423">coord of bottom horizontal clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="top" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="424">coord of top horizontal clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_near" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="425">The distance to the near clip plane. Never pass 0 and always pass
  a positive number.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_2d" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="427">The distance to the 2D plane. (Should always be positive and
  be between @z_near and the z_far value that was passed to
  cogl_matrix_frustum())</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="width_2d" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="430">The width of the 2D coordinate system</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="height_2d" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="431">The height of the 2D coordinate system</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="view_2d_in_perspective"
              c:identifier="cogl_matrix_view_2d_in_perspective"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-matrix.h"
             line="459">Multiplies @matrix by a view transform that maps the 2D coordinates
(0,0) top left and (@width_2d,@height_2d) bottom right the full viewport
size. Geometry at a depth of 0 will now lie on this 2D plane.

Note: this doesn't multiply the matrix by any projection matrix,
but it assumes you have a perspective projection as defined by
passing the corresponding arguments to cogl_matrix_perspective().

Toolkits such as Clutter that mix 2D and 3D drawing can use this to
create a 2D coordinate system within a 3D perspective projected
view frustum.</doc>
        <source-position filename="../cogl/cogl/cogl-matrix.h" line="488"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="fov_y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="461">A field of view angle for the Y axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="aspect" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="462">The ratio of width to height determining the field of view angle
  for the x axis.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_near" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="464">The distance to the near clip plane. Never pass 0 and always pass
  a positive number.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_2d" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="466">The distance to the 2D plane. (Should always be positive and
  be between @z_near and the z_far value that was passed to
  cogl_matrix_frustum())</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="width_2d" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="469">The width of the 2D coordinate system</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="height_2d" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="470">The height of the 2D coordinate system</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <function name="equal" c:identifier="cogl_matrix_equal" version="1.4">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-matrix.h"
             line="540">Compares two matrices to see if they represent the same
transformation. Although internally the matrices may have different
annotations associated with them and may potentially have a cached
inverse matrix these are not considered in the comparison.</doc>
        <source-position filename="../cogl/cogl/cogl-matrix.h" line="553"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="v1"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="542">A 4x4 transformation matrix</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="v2"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-matrix.h"
                 line="543">A 4x4 transformation matrix</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <class name="Object"
           c:symbol-prefix="object"
           c:type="CoglObject"
           abstract="1"
           glib:type-name="CoglObject"
           glib:get-type="cogl_object_get_gtype"
           glib:fundamental="1"
           glib:ref-func="cogl_object_ref"
           glib:unref-func="cogl_object_unref"
           glib:set-value-func="cogl_object_value_set_object"
           glib:get-value-func="cogl_object_value_get_object">
      <function name="ref" c:identifier="cogl_object_ref" introspectable="0">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-object.h"
             line="57">Increases the reference count of @object by 1</doc>
        <source-position filename="../cogl/cogl/cogl-object.h" line="66"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-object.h"
               line="63">the @object, with its reference count increased</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <parameter name="object"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-object.h"
                 line="59">a #CoglObject</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
      <function name="unref"
                c:identifier="cogl_object_unref"
                introspectable="0">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-object.h"
             line="68">Drecreases the reference count of @object by 1; if the reference
count reaches 0, the resources allocated by @object will be freed</doc>
        <source-position filename="../cogl/cogl/cogl-object.h" line="76"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-object.h"
                 line="70">a #CoglObject</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
      <method name="get_user_data"
              c:identifier="cogl_object_get_user_data"
              version="1.4"
              introspectable="0">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-object.h"
             line="196">Finds the user data previously associated with @object using
the given @key. If no user data has been associated with @object
for the given @key this function returns NULL.</doc>
        <source-position filename="../cogl/cogl/cogl-object.h" line="213"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-object.h"
               line="206">The user data previously associated
  with @object using the given @key; or %NULL if no associated
  data is found.</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-object.h"
                 line="198">The object with associated private data to query</doc>
            <type name="Object" c:type="CoglObject*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-object.h"
                 line="199">The address of a #CoglUserDataKey which provides a unique value
      with which to index the private data.</doc>
            <type name="UserDataKey" c:type="CoglUserDataKey*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_user_data"
              c:identifier="cogl_object_set_user_data"
              version="1.4"
              introspectable="0">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-object.h"
             line="173">Associates some private @user_data with a given #CoglObject. To
later remove the association call cogl_object_set_user_data() with
the same @key but NULL for the @user_data.</doc>
        <source-position filename="../cogl/cogl/cogl-object.h" line="191"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-object.h"
                 line="175">The object to associate private data with</doc>
            <type name="Object" c:type="CoglObject*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-object.h"
                 line="176">The address of a #CoglUserDataKey which provides a unique value
  with which to index the private data.</doc>
            <type name="UserDataKey" c:type="CoglUserDataKey*"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-object.h"
                 line="178">The data to associate with the given object,
  or %NULL to remove a previous association.</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-object.h"
                 line="180">A #CoglUserDataDestroyCallback to call if the object is
  destroyed or if the association is removed by later setting
  %NULL data for the same key.</doc>
            <type name="UserDataDestroyCallback"
                  c:type="CoglUserDataDestroyCallback"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <class name="Offscreen"
           c:symbol-prefix="offscreen"
           c:type="CoglOffscreen"
           parent="Object"
           glib:type-name="CoglOffscreen"
           glib:get-type="cogl_offscreen_get_gtype"
           glib:fundamental="1">
      <implements name="Framebuffer"/>
      <constructor name="new_to_texture"
                   c:identifier="cogl_offscreen_new_to_texture"
                   deprecated="1"
                   deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-offscreen.h"
             line="101">This creates an offscreen buffer object using the given @texture as the
primary color buffer. It doesn't just initialize the contents of the
offscreen buffer with the @texture; they are tightly bound so that
drawing to the offscreen buffer effectivly updates the contents of the
given texture. You don't need to destroy the offscreen buffer before
you can use the @texture again.

&lt;note&gt;This only works with low-level #CoglTexture types such as
#CoglTexture2D, #CoglTexture3D and #CoglTextureRectangle, and not
with meta-texture types such as #CoglTexture2DSliced.&lt;/note&gt;</doc>
        <doc-deprecated xml:space="preserve">Use cogl_offscreen_new_with_texture instead.</doc-deprecated>
        <source-position filename="../cogl/cogl/cogl-offscreen.h" line="123"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-offscreen.h"
               line="116">a newly instantiated #CoglOffscreen
  framebuffer or %NULL if it wasn't possible to create the
  buffer.</doc>
          <type name="Offscreen" c:type="CoglOffscreen*"/>
        </return-value>
        <parameters>
          <parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-offscreen.h"
                 line="103">A #CoglTexture pointer</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_texture"
                   c:identifier="cogl_offscreen_new_with_texture">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-offscreen.h"
             line="66">This creates an offscreen framebuffer object using the given
@texture as the primary color buffer. It doesn't just initialize
the contents of the offscreen buffer with the @texture; they are
tightly bound so that drawing to the offscreen buffer effectively
updates the contents of the given texture. You don't need to
destroy the offscreen buffer before you can use the @texture again.

&lt;note&gt;This api only works with low-level #CoglTexture types such as
#CoglTexture2D, #CoglTexture3D and #CoglTextureRectangle, and not
with meta-texture types such as #CoglTexture2DSliced.&lt;/note&gt;

The storage for the framebuffer is actually allocated lazily
so this function will never return %NULL to indicate a runtime
error. This means it is still possible to configure the framebuffer
before it is really allocated.

Simple applications without full error handling can simply rely on
Cogl to lazily allocate the storage of framebuffers but you should
be aware that if Cogl encounters an error (such as running out of
GPU memory) then your application will simply abort with an error
message. If you need to be able to catch such exceptions at runtime
then you can explicitly allocate your framebuffer when you have
finished configuring it by calling cogl_framebuffer_allocate() and
passing in a #CoglError argument to catch any exceptions.</doc>
        <source-position filename="../cogl/cogl/cogl-offscreen.h" line="99"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-offscreen.h"
               line="95">a newly instantiated #CoglOffscreen
  framebuffer.</doc>
          <type name="Offscreen" c:type="CoglOffscreen*"/>
        </return-value>
        <parameters>
          <parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-offscreen.h"
                 line="68">A #CoglTexture pointer</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="ref"
                c:identifier="cogl_offscreen_ref"
                deprecated="1"
                deprecated-version="1.2">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-offscreen.h"
             line="138">Increments the reference count on the @offscreen framebuffer.</doc>
        <doc-deprecated xml:space="preserve">cogl_object_ref() should be used in new code.</doc-deprecated>
        <source-position filename="../cogl/cogl/cogl-offscreen.h" line="151"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-offscreen.h"
               line="144">For convenience it returns the
                               given @offscreen</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <parameter name="offscreen"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-offscreen.h"
                 line="140">A pointer to a #CoglOffscreen framebuffer</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
      <function name="unref"
                c:identifier="cogl_offscreen_unref"
                deprecated="1"
                deprecated-version="1.2">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-offscreen.h"
             line="153">Decreases the reference count for the @offscreen buffer and frees it when
the count reaches 0.</doc>
        <doc-deprecated xml:space="preserve">cogl_object_unref() should be used in new code.</doc-deprecated>
        <source-position filename="../cogl/cogl/cogl-offscreen.h" line="164"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="offscreen"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-offscreen.h"
                 line="155">A pointer to a #CoglOffscreen framebuffer</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
      <method name="get_texture"
              c:identifier="cogl_offscreen_get_texture"
              introspectable="0">
        <source-position filename="../cogl/cogl/cogl-offscreen.h" line="170"/>
        <return-value>
          <type name="Texture" c:type="CoglTexture*"/>
        </return-value>
        <parameters>
          <instance-parameter name="offscreen" transfer-ownership="none">
            <type name="Offscreen" c:type="CoglOffscreen*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="Onscreen"
           c:symbol-prefix="onscreen"
           c:type="CoglOnscreen"
           parent="Object"
           glib:type-name="CoglOnscreen"
           glib:get-type="cogl_onscreen_get_gtype"
           glib:fundamental="1">
      <implements name="Framebuffer"/>
      <constructor name="new"
                   c:identifier="cogl_onscreen_new"
                   version="1.8"
                   introspectable="0"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-onscreen.h"
             line="60">Instantiates an "unallocated" #CoglOnscreen framebuffer that may be
configured before later being allocated, either implicitly when
it is first used or explicitly via cogl_framebuffer_allocate().</doc>
        <source-position filename="../cogl/cogl/cogl-onscreen.h" line="75"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-onscreen.h"
               line="70">A newly instantiated #CoglOnscreen framebuffer</doc>
          <type name="Onscreen" c:type="CoglOnscreen*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-onscreen.h"
                 line="62">A #CoglContext</doc>
            <type c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-onscreen.h"
                 line="63">The desired framebuffer width</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-onscreen.h"
                 line="64">The desired framebuffer height</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="clutter_backend_set_size_CLUTTER"
                c:identifier="cogl_onscreen_clutter_backend_set_size_CLUTTER">
        <source-position filename="../cogl/cogl/deprecated/cogl-clutter.h"
                         line="50"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="width" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </function>
      <method name="add_dirty_callback"
              c:identifier="cogl_onscreen_add_dirty_callback"
              version="1.16"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-onscreen.h"
             line="796">Installs a @callback function that will be called whenever the
window system has lost the contents of a region of the onscreen
buffer and the application should redraw it to repair the buffer.
For example this may happen in a window system without a compositor
if a window that was previously covering up the onscreen window has
been moved causing a region of the onscreen to be exposed.

The @callback will be passed a #CoglOnscreenDirtyInfo struct which
decribes a rectangle containing the newly dirtied region. Note that
this may be called multiple times to describe a non-rectangular
region composed of multiple smaller rectangles.

The dirty events are separate from %COGL_FRAME_EVENT_SYNC events so
the application should also listen for this event before rendering
the dirty region to ensure that the framebuffer is actually ready
for rendering.</doc>
        <source-position filename="../cogl/cogl/cogl-onscreen.h" line="827"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-onscreen.h"
               line="821">a #CoglOnscreenDirtyClosure pointer that can be used to
              remove the callback and associated @user_data later.</doc>
          <type name="OnscreenDirtyClosure"
                c:type="CoglOnscreenDirtyClosure*"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-onscreen.h"
                 line="798">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-onscreen.h"
                 line="799">A callback function to call for dirty events</doc>
            <type name="OnscreenDirtyCallback"
                  c:type="CoglOnscreenDirtyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-onscreen.h"
                 line="800">A private pointer to be passed to @callback</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="destroy"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-onscreen.h"
                 line="801">An optional callback to destroy @user_data when the
          @callback is removed or @onscreen is freed.</doc>
            <type name="UserDataDestroyCallback"
                  c:type="CoglUserDataDestroyCallback"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_frame_callback"
              c:identifier="cogl_onscreen_add_frame_callback"
              version="1.14"
              introspectable="0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-onscreen.h"
             line="458">Installs a @callback function that will be called for significant
events relating to the given @onscreen framebuffer.

The @callback will be used to notify when the system compositor is
ready for this application to render a new frame. In this case
%COGL_FRAME_EVENT_SYNC will be passed as the event argument to the
given @callback in addition to the #CoglFrameInfo corresponding to
the frame beeing acknowledged by the compositor.

The @callback will also be called to notify when the frame has
ended. In this case %COGL_FRAME_EVENT_COMPLETE will be passed as
the event argument to the given @callback in addition to the
#CoglFrameInfo corresponding to the newly presented frame.  The
meaning of "ended" here simply means that no more timing
information will be collected within the corresponding
#CoglFrameInfo and so this is a good opportunity to analyse the
given info. It does not necessarily mean that the GPU has finished
rendering the corresponding frame.

We highly recommend throttling your application according to
%COGL_FRAME_EVENT_SYNC events so that your application can avoid
wasting resources, drawing more frames than your system compositor
can display.</doc>
        <source-position filename="../cogl/cogl/cogl-onscreen.h" line="496"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-onscreen.h"
               line="490">a #CoglFrameClosure pointer that can be used to
              remove the callback and associated @user_data later.</doc>
          <type name="FrameClosure" c:type="CoglFrameClosure*"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-onscreen.h"
                 line="460">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-onscreen.h"
                 line="461">A callback function to call for frame events</doc>
            <type name="FrameCallback" c:type="CoglFrameCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-onscreen.h"
                 line="462">A private pointer to be passed to @callback</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="destroy"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-onscreen.h"
                 line="463">An optional callback to destroy @user_data
          when the @callback is removed or @onscreen is freed.</doc>
            <type name="UserDataDestroyCallback"
                  c:type="CoglUserDataDestroyCallback"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_resize_callback"
              c:identifier="cogl_onscreen_add_resize_callback"
              version="2.0">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-onscreen.h"
             line="682">Registers a @callback with @onscreen that will be called whenever
the @onscreen framebuffer changes size.

The @callback can be removed using
cogl_onscreen_remove_resize_callback() passing the returned closure
pointer.

&lt;note&gt;Since Cogl automatically updates the viewport of an @onscreen
framebuffer that is resized, a resize callback can also be used to
track when the viewport has been changed automatically by Cogl in
case your application needs more specialized control over the
viewport.&lt;/note&gt;

&lt;note&gt;A resize callback will only ever be called while dispatching
Cogl events from the system mainloop; so for example during
cogl_poll_renderer_dispatch(). This is so that callbacks shouldn't
occur while an application might have arbitrary locks held for
example.&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/cogl-onscreen.h" line="715"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-onscreen.h"
               line="710">a #CoglOnscreenResizeClosure pointer that can be used to
              remove the callback and associated @user_data later.</doc>
          <type name="OnscreenResizeClosure"
                c:type="CoglOnscreenResizeClosure*"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-onscreen.h"
                 line="684">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-onscreen.h"
                 line="685">A #CoglOnscreenResizeCallback to call when
           the @onscreen changes size.</doc>
            <type name="OnscreenResizeCallback"
                  c:type="CoglOnscreenResizeCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-onscreen.h"
                 line="687">Private data to be passed to @callback.</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="destroy"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-onscreen.h"
                 line="688">An optional callback to destroy @user_data
          when the @callback is removed or @onscreen is freed.</doc>
            <type name="UserDataDestroyCallback"
                  c:type="CoglUserDataDestroyCallback"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_swap_buffers_callback"
              c:identifier="cogl_onscreen_add_swap_buffers_callback"
              version="1.10"
              deprecated="1"
              deprecated-version="1.14"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-onscreen.h"
             line="524">Installs a @callback function that should be called whenever a swap buffers
request (made using cogl_onscreen_swap_buffers()) for the given
@onscreen completes.

&lt;note&gt;Applications should check for the %COGL_FEATURE_ID_SWAP_BUFFERS_EVENT
feature before using this API. It's currently undefined when and if
registered callbacks will be called if this feature is not supported.&lt;/note&gt;

We recommend using this mechanism when available to manually throttle your
applications so your application will be able to avoid long blocks in the
driver caused by throttling when you request to swap buffers too quickly.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_onscreen_add_frame_callback() instead</doc-deprecated>
        <source-position filename="../cogl/cogl/cogl-onscreen.h" line="551"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-onscreen.h"
               line="543">a unique identifier that can be used to remove to remove
              the callback later.</doc>
          <type name="guint" c:type="unsigned int"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-onscreen.h"
                 line="526">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-onscreen.h"
                 line="527">A callback function to call when a swap
           has completed</doc>
            <type name="SwapBuffersNotify" c:type="CoglSwapBuffersNotify"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-onscreen.h"
                 line="529">A private pointer to be passed to @callback</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_buffer_age"
              c:identifier="cogl_onscreen_get_buffer_age"
              version="1.14"
              stability="Stable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-onscreen.h"
             line="246">Gets the current age of the buffer contents.

This function allows applications to query the age of the current
back buffer contents for a #CoglOnscreen as the number of frames
elapsed since the contents were most recently defined.

These age values exposes enough information to applications about
how Cogl internally manages back buffers to allow applications to
re-use the contents of old frames and minimize how much must be
redrawn for the next frame.

The back buffer contents can either be reported as invalid (has an
age of 0) or it may be reported to be the same contents as from n
frames prior to the current frame.

The queried value remains valid until the next buffer swap.

&lt;note&gt;One caveat is that under X11 the buffer age does not reflect
changes to buffer contents caused by the window systems. X11
applications must track Expose events to determine what buffer
regions need to additionally be repaired each frame.&lt;/note&gt;

The recommended way to take advantage of this buffer age api is to
build up a circular buffer of length 3 for tracking damage regions
over the last 3 frames and when starting a new frame look at the
age of the buffer and combine the damage regions for the current
frame with the damage regions of previous @age frames so you know
everything that must be redrawn to update the old contents for the
new frame.

&lt;note&gt;If the system doesn't not support being able to track the age
of back buffers then this function will always return 0 which
implies that the contents are undefined.&lt;/note&gt;

&lt;note&gt;The %COGL_FEATURE_ID_BUFFER_AGE feature can optionally be
explicitly checked to determine if Cogl is currently tracking the
age of #CoglOnscreen back buffer contents. If this feature is
missing then this function will always return 0.&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/cogl-onscreen.h" line="296"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-onscreen.h"
               line="289">The age of the buffer contents or 0 when the buffer
              contents are undefined.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-onscreen.h"
                 line="248">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_frame_counter"
              c:identifier="cogl_onscreen_get_frame_counter"
              version="1.14"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-onscreen.h"
             line="866">Gets the value of the framebuffers frame counter. This is
a counter that increases by one each time
cogl_onscreen_swap_buffers() or cogl_onscreen_swap_region()
is called.</doc>
        <source-position filename="../cogl/cogl/cogl-onscreen.h" line="879"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-onscreen.h"
               line="874">the current frame counter value</doc>
          <type name="gint64" c:type="int64_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_resizable"
              c:identifier="cogl_onscreen_get_resizable"
              version="2.0">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-onscreen.h"
             line="606">Lets you query whether @onscreen has been marked as resizable via
the cogl_onscreen_set_resizable() api.

By default, if possible, a @onscreen will be created by Cogl
as non resizable, but it is not guaranteed that this is always
possible for all window systems.

&lt;note&gt;If cogl_onscreen_set_resizable(@onscreen, %TRUE) has been
previously called then this function will return %TRUE, but it's
possible that the current windowing system being used does not
support window resizing (consider fullscreen windows on a phone or
a TV). This function is not aware of whether resizing is truly
meaningful with your window system, only whether the @onscreen has
been marked as resizable.&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/cogl-onscreen.h" line="630"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-onscreen.h"
               line="625">Returns whether @onscreen has been marked as
              resizable or not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-onscreen.h"
                 line="608">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="hide"
              c:identifier="cogl_onscreen_hide"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-onscreen.h"
             line="196">This requests to make @onscreen invisible to the user.

Actually the precise semantics of this function depend on the
window system currently in use, and if you don't have a
multi-windowining system this function may in-fact do nothing.

This function does not implicitly allocate the given @onscreen
framebuffer before hiding it.

&lt;note&gt;Since Cogl doesn't explicitly track the visibility status of
onscreen framebuffers it wont try to avoid redundant window system
requests e.g. to show an already visible window. This also means
that it's acceptable to alternatively use native APIs to show and
hide windows without confusing Cogl.&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/cogl-onscreen.h" line="219"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-onscreen.h"
                 line="198">The onscreen framebuffer to make invisible</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_dirty_callback"
              c:identifier="cogl_onscreen_remove_dirty_callback"
              version="1.16"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-onscreen.h"
             line="832">Removes a callback and associated user data that were previously
registered using cogl_onscreen_add_dirty_callback().

If a destroy callback was passed to
cogl_onscreen_add_dirty_callback() to destroy the user data then
this will also get called.</doc>
        <source-position filename="../cogl/cogl/cogl-onscreen.h" line="849"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-onscreen.h"
                 line="834">A #CoglOnscreen</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-onscreen.h"
                 line="835">A #CoglOnscreenDirtyClosure returned from
          cogl_onscreen_add_dirty_callback()</doc>
            <type name="OnscreenDirtyClosure"
                  c:type="CoglOnscreenDirtyClosure*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_frame_callback"
              c:identifier="cogl_onscreen_remove_frame_callback"
              version="1.14"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-onscreen.h"
             line="501">Removes a callback and associated user data that were previously
registered using cogl_onscreen_add_frame_callback().

If a destroy callback was passed to
cogl_onscreen_add_frame_callback() to destroy the user data then
this will get called.</doc>
        <source-position filename="../cogl/cogl/cogl-onscreen.h" line="518"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-onscreen.h"
                 line="503">A #CoglOnscreen</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-onscreen.h"
                 line="504">A #CoglFrameClosure returned from
          cogl_onscreen_add_frame_callback()</doc>
            <type name="FrameClosure" c:type="CoglFrameClosure*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_resize_callback"
              c:identifier="cogl_onscreen_remove_resize_callback"
              version="2.0">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-onscreen.h"
             line="720">Removes a resize @callback and @user_data pair that were previously
associated with @onscreen via cogl_onscreen_add_resize_callback().</doc>
        <source-position filename="../cogl/cogl/cogl-onscreen.h" line="731"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-onscreen.h"
                 line="722">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-onscreen.h"
                 line="723">An identifier returned from cogl_onscreen_add_resize_callback()</doc>
            <type name="OnscreenResizeClosure"
                  c:type="CoglOnscreenResizeClosure*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_swap_buffers_callback"
              c:identifier="cogl_onscreen_remove_swap_buffers_callback"
              version="1.10"
              deprecated="1"
              deprecated-version="1.14"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-onscreen.h"
             line="555">Removes a callback that was previously registered
using cogl_onscreen_add_swap_buffers_callback().</doc>
        <doc-deprecated xml:space="preserve">Use cogl_onscreen_remove_frame_callback() instead</doc-deprecated>
        <source-position filename="../cogl/cogl/cogl-onscreen.h" line="570"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-onscreen.h"
                 line="557">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-onscreen.h"
                 line="558">An identifier returned from cogl_onscreen_add_swap_buffers_callback()</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_resizable"
              c:identifier="cogl_onscreen_set_resizable"
              version="2.0">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-onscreen.h"
             line="573">Lets you request Cogl to mark an @onscreen framebuffer as
resizable or not.

By default, if possible, a @onscreen will be created by Cogl
as non resizable, but it is not guaranteed that this is always
possible for all window systems.

&lt;note&gt;Cogl does not know whether marking the @onscreen framebuffer
is truly meaningful for your current window system (consider
applications being run fullscreen on a phone or TV) so this
function may not have any useful effect. If you are running on a
multi windowing system such as X11 or Win32 or OSX then Cogl will
request to the window system that users be allowed to resize the
@onscreen, although it's still possible that some other window
management policy will block this possibility.&lt;/note&gt;

&lt;note&gt;Whenever an @onscreen framebuffer is resized the viewport
will be automatically updated to match the new size of the
framebuffer with an origin of (0,0). If your application needs more
specialized control of the viewport it will need to register a
resize handler using cogl_onscreen_add_resize_callback() so that it
can track when the viewport has been changed automatically.&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/cogl-onscreen.h" line="603"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-onscreen.h"
                 line="575">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="resizable" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="show"
              c:identifier="cogl_onscreen_show"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-onscreen.h"
             line="165">This requests to make @onscreen visible to the user.

Actually the precise semantics of this function depend on the
window system currently in use, and if you don't have a
multi-windowining system this function may in-fact do nothing.

This function will implicitly allocate the given @onscreen
framebuffer before showing it if it hasn't already been allocated.

When using the Wayland winsys calling this will set the surface to
a toplevel type which will make it appear. If the application wants
to set a different type for the surface, it can avoid calling
cogl_onscreen_show() and set its own type directly with the Wayland
client API via cogl_wayland_onscreen_get_surface().

&lt;note&gt;Since Cogl doesn't explicitly track the visibility status of
onscreen framebuffers it wont try to avoid redundant window system
requests e.g. to show an already visible window. This also means
that it's acceptable to alternatively use native APIs to show and
hide windows without confusing Cogl.&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/cogl-onscreen.h" line="194"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-onscreen.h"
                 line="167">The onscreen framebuffer to make visible</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="swap_buffers"
              c:identifier="cogl_onscreen_swap_buffers"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-onscreen.h"
             line="221">Swaps the current back buffer being rendered too, to the front for display.

This function also implicitly discards the contents of the color, depth and
stencil buffers as if cogl_framebuffer_discard_buffers() were used. The
significance of the discard is that you should not expect to be able to
start a new frame that incrementally builds on the contents of the previous
frame.

&lt;note&gt;It is highly recommended that applications use
cogl_onscreen_swap_buffers_with_damage() instead whenever possible
and also use the cogl_onscreen_get_buffer_age() api so they can
perform incremental updates to older buffers instead of having to
render a full buffer for every frame.&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/cogl-onscreen.h" line="243"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-onscreen.h"
                 line="223">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="swap_buffers_with_damage"
              c:identifier="cogl_onscreen_swap_buffers_with_damage"
              version="1.16"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-onscreen.h"
             line="298">Swaps the current back buffer being rendered too, to the front for
display and provides information to any system compositor about
what regions of the buffer have changed (damage) with respect to
the last swapped buffer.

This function has the same semantics as
cogl_framebuffer_swap_buffers() except that it additionally allows
applications to pass a list of damaged rectangles which may be
passed on to a compositor so that it can minimize how much of the
screen is redrawn in response to this applications newly swapped
front buffer.

For example if your application is only animating a small object in
the corner of the screen and everything else is remaining static
then it can help the compositor to know that only the bottom right
corner of your newly swapped buffer has really changed with respect
to your previously swapped front buffer.

If @n_rectangles is 0 then the whole buffer will implicitly be
reported as damaged as if cogl_onscreen_swap_buffers() had been
called.

This function also implicitly discards the contents of the color,
depth and stencil buffers as if cogl_framebuffer_discard_buffers()
were used. The significance of the discard is that you should not
expect to be able to start a new frame that incrementally builds on
the contents of the previous frame. If you want to perform
incremental updates to older back buffers then please refer to the
cogl_onscreen_get_buffer_age() api.

Whenever possible it is recommended that applications use this
function instead of cogl_onscreen_swap_buffers() to improve
performance when running under a compositor.

&lt;note&gt;It is highly recommended to use this API in conjunction with
the cogl_onscreen_get_buffer_age() api so that your application can
perform incremental rendering based on old back buffers.&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/cogl-onscreen.h" line="347"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-onscreen.h"
                 line="300">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="rectangles" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-onscreen.h"
                 line="301">An array of integer 4-tuples representing damaged
             rectangles as (x, y, width, height) tuples.</doc>
            <type name="gint" c:type="const int*"/>
          </parameter>
          <parameter name="n_rectangles" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-onscreen.h"
                 line="303">The number of 4-tuples to be read from @rectangles</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="swap_region"
              c:identifier="cogl_onscreen_swap_region"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-onscreen.h"
             line="351">Swaps a region of the back buffer being rendered too, to the front for
display.  @rectangles represents the region as array of @n_rectangles each
defined by 4 sequential (x, y, width, height) integers.

This function also implicitly discards the contents of the color, depth and
stencil buffers as if cogl_framebuffer_discard_buffers() were used. The
significance of the discard is that you should not expect to be able to
start a new frame that incrementally builds on the contents of the previous
frame.</doc>
        <source-position filename="../cogl/cogl/cogl-onscreen.h" line="372"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-onscreen.h"
                 line="353">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="rectangles" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-onscreen.h"
                 line="354">An array of integer 4-tuples representing rectangles as
             (x, y, width, height) tuples.</doc>
            <type name="gint" c:type="const int*"/>
          </parameter>
          <parameter name="n_rectangles" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-onscreen.h"
                 line="356">The number of 4-tuples to be read from @rectangles</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <callback name="OnscreenDirtyCallback"
              c:type="CoglOnscreenDirtyCallback"
              version="1.16"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-onscreen.h"
           line="756">Is a callback that can be registered via
cogl_onscreen_add_dirty_callback() to be called when the windowing
system determines that a region of the onscreen window has been
lost and the application should redraw it.</doc>
      <source-position filename="../cogl/cogl/cogl-onscreen.h" line="772"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="onscreen" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-onscreen.h"
               line="758">The onscreen that the frame is associated with</doc>
          <type name="Onscreen" c:type="CoglOnscreen*"/>
        </parameter>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-onscreen.h"
               line="759">A #CoglOnscreenDirtyInfo struct containing the details of the
  dirty area</doc>
          <type name="OnscreenDirtyInfo"
                c:type="const CoglOnscreenDirtyInfo*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="2">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-onscreen.h"
               line="761">The user pointer passed to
            cogl_onscreen_add_frame_callback()</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="OnscreenDirtyClosure"
            c:type="CoglOnscreenDirtyClosure"
            version="1.16"
            stability="Unstable"
            glib:type-name="CoglOnscreenDirtyClosure"
            glib:get-type="cogl_onscreen_dirty_closure_get_gtype"
            c:symbol-prefix="onscreen_dirty_closure">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-onscreen.h"
           line="776">An opaque type that tracks a #CoglOnscreenDirtyCallback and associated
user data. A #CoglOnscreenDirtyClosure pointer will be returned from
cogl_onscreen_add_dirty_callback() and it allows you to remove a
callback later using cogl_onscreen_remove_dirty_callback().</doc>
      <source-position filename="../cogl/cogl/cogl-onscreen.h" line="787"/>
    </record>
    <record name="OnscreenDirtyInfo"
            c:type="CoglOnscreenDirtyInfo"
            version="1.16"
            stability="Unstable">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-onscreen.h"
           line="734">A structure passed to callbacks registered using
cogl_onscreen_add_dirty_callback(). The members describe a
rectangle within the onscreen buffer that should be redrawn.</doc>
      <source-position filename="../cogl/cogl/cogl-onscreen.h" line="754"/>
      <field name="x" writable="1">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-onscreen.h"
             line="736">Left edge of the dirty rectangle</doc>
        <type name="gint" c:type="int"/>
      </field>
      <field name="y" writable="1">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-onscreen.h"
             line="737">Top edge of the dirty rectangle, measured from the top of the window</doc>
        <type name="gint" c:type="int"/>
      </field>
      <field name="width" writable="1">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-onscreen.h"
             line="738">Width of the dirty rectangle</doc>
        <type name="gint" c:type="int"/>
      </field>
      <field name="height" writable="1">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-onscreen.h"
             line="739">Height of the dirty rectangle</doc>
        <type name="gint" c:type="int"/>
      </field>
    </record>
    <callback name="OnscreenResizeCallback"
              c:type="CoglOnscreenResizeCallback"
              version="2.0">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-onscreen.h"
           line="632">Is a callback type used with the
cogl_onscreen_add_resize_callback() allowing applications to be
notified whenever an @onscreen framebuffer is resized.

&lt;note&gt;Cogl automatically updates the viewport of an @onscreen
framebuffer that is resized so this callback is also an indication
that the viewport has been modified too&lt;/note&gt;

&lt;note&gt;A resize callback will only ever be called while dispatching
Cogl events from the system mainloop; so for example during
cogl_poll_renderer_dispatch(). This is so that callbacks shouldn't
occur while an application might have arbitrary locks held for
example.&lt;/note&gt;</doc>
      <source-position filename="../cogl/cogl/cogl-onscreen.h" line="656"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="onscreen" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-onscreen.h"
               line="634">A #CoglOnscreen framebuffer that was resized</doc>
          <type name="Onscreen" c:type="CoglOnscreen*"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-onscreen.h"
               line="635">The new width of @onscreen</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-onscreen.h"
               line="636">The new height of @onscreen</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="3">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-onscreen.h"
               line="637">The private passed to
            cogl_onscreen_add_resize_callback()</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="OnscreenResizeClosure"
            c:type="CoglOnscreenResizeClosure"
            version="2.0"
            stability="Unstable"
            glib:type-name="CoglOnscreenResizeClosure"
            glib:get-type="cogl_onscreen_resize_closure_get_gtype"
            c:symbol-prefix="onscreen_resize_closure">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-onscreen.h"
           line="661">An opaque type that tracks a #CoglOnscreenResizeCallback and
associated user data. A #CoglOnscreenResizeClosure pointer will be
returned from cogl_onscreen_add_resize_callback() and it allows you
to remove a callback later using
cogl_onscreen_remove_resize_callback().</doc>
      <source-position filename="../cogl/cogl/cogl-onscreen.h" line="673"/>
    </record>
    <callback name="OnscreenX11MaskCallback"
              c:type="CoglOnscreenX11MaskCallback">
      <source-position filename="../cogl/cogl/cogl-onscreen.h" line="78"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="onscreen" transfer-ownership="none">
          <type name="Onscreen" c:type="CoglOnscreen*"/>
        </parameter>
        <parameter name="event_mask" transfer-ownership="none">
          <type name="guint32" c:type="uint32_t"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="2">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <constant name="PREMULT_BIT" value="128" c:type="COGL_PREMULT_BIT">
      <source-position filename="../cogl/cogl/cogl-types.h" line="146"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="Pipeline"
           c:symbol-prefix="pipeline"
           c:type="CoglPipeline"
           parent="Object"
           glib:type-name="CoglPipeline"
           glib:get-type="cogl_pipeline_get_gtype"
           glib:fundamental="1">
      <constructor name="new"
                   c:identifier="cogl_pipeline_new"
                   version="2.0"
                   introspectable="0"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline.h"
             line="74">Allocates and initializes a default simple pipeline that will color
a primitive white.</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline.h" line="87"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-pipeline.h"
               line="81">a pointer to a new #CoglPipeline</doc>
          <type name="Pipeline" c:type="CoglPipeline*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline.h"
                 line="76">a #CoglContext</doc>
            <type c:type="CoglContext*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add_layer_snippet"
              c:identifier="cogl_pipeline_add_layer_snippet"
              version="1.10"
              introspectable="0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-layer-state.h"
             line="596">Adds a shader snippet that will hook on to the given layer of the
pipeline. The exact part of the pipeline that the snippet wraps
around depends on the hook that is given to
cogl_snippet_new(). Note that some hooks can't be used with a layer
and need to be added with cogl_pipeline_add_snippet() instead.</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                         line="612"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="598">A #CoglPipeline</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="599">The layer to hook the snippet to</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="snippet" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="600">A #CoglSnippet</doc>
            <type c:type="CoglSnippet*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_snippet"
              c:identifier="cogl_pipeline_add_snippet"
              version="1.10"
              introspectable="0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="958">Adds a shader snippet to @pipeline. The snippet will wrap around or
replace some part of the pipeline as defined by the hook point in
@snippet. Note that some hook points are specific to a layer and
must be added with cogl_pipeline_add_layer_snippet() instead.</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="972"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="960">A #CoglPipeline</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="snippet" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="961">The #CoglSnippet to add to the vertex processing hook</doc>
            <type c:type="CoglSnippet*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy"
              c:identifier="cogl_pipeline_copy"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline.h"
             line="89">Creates a new pipeline with the configuration copied from the
source pipeline.

We would strongly advise developers to always aim to use
cogl_pipeline_copy() instead of cogl_pipeline_new() whenever there will
be any similarity between two pipelines. Copying a pipeline helps Cogl
keep track of a pipelines ancestry which we may use to help minimize GPU
state changes.</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline.h" line="108"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-pipeline.h"
               line="102">a pointer to the newly allocated #CoglPipeline</doc>
          <type name="Pipeline" c:type="CoglPipeline*"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline.h"
                 line="91">a #CoglPipeline object to copy</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="foreach_layer"
              c:identifier="cogl_pipeline_foreach_layer"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline.h"
             line="141">Iterates all the layer indices of the given @pipeline.</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline.h" line="155"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline.h"
                 line="143">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline.h"
                 line="144">A #CoglPipelineLayerCallback to be
           called for each layer index</doc>
            <type name="PipelineLayerCallback"
                  c:type="CoglPipelineLayerCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline.h"
                 line="146">Private data that will be passed to the
            callback</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_alpha_test_function"
              c:identifier="cogl_pipeline_get_alpha_test_function"
              version="2.0"
              stability="Unstable">
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="374"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-pipeline-state.h"
               line="368">The alpha test function of @pipeline.</doc>
          <type name="PipelineAlphaFunc" c:type="CoglPipelineAlphaFunc"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="366">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_alpha_test_reference"
              c:identifier="cogl_pipeline_get_alpha_test_reference"
              version="2.0"
              stability="Unstable">
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="386"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-pipeline-state.h"
               line="380">The alpha test reference value of @pipeline.</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="378">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ambient"
              c:identifier="cogl_pipeline_get_ambient"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="144">Retrieves the current ambient color for @pipeline</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="155"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="146">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="ambient" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="147">The location to store the ambient color</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_color"
              c:identifier="cogl_pipeline_get_color"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="109">Retrieves the current pipeline color.</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="120"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="111">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="color"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="112">The location to store the color</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_color_mask"
              c:identifier="cogl_pipeline_get_color_mask"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="574">Gets the current #CoglColorMask of which channels would be written to the
current framebuffer. Each bit set in the mask means that the
corresponding color would be written.</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="587"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-pipeline-state.h"
               line="582">A #CoglColorMask</doc>
          <type name="ColorMask" c:type="CoglColorMask"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="576">a #CoglPipeline object.</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_cull_face_mode"
              c:identifier="cogl_pipeline_get_cull_face_mode"
              version="2.0">
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="766"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-pipeline-state.h"
               line="759">the cull face mode that was previously set with
cogl_pipeline_set_cull_face_mode().

Status: Unstable</doc>
          <type name="PipelineCullFaceMode" c:type="CoglPipelineCullFaceMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_depth_state"
              c:identifier="cogl_pipeline_get_depth_state"
              version="2.0"
              introspectable="0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="697">Retrieves the current depth state configuration for the given
@pipeline as previously set using cogl_pipeline_set_depth_state().</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="709"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="699">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="state_out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="700">A destination #CoglDepthState struct</doc>
            <type c:type="CoglDepthState*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_diffuse"
              c:identifier="cogl_pipeline_get_diffuse"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="176">Retrieves the current diffuse color for @pipeline</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="187"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="178">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="diffuse" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="179">The location to store the diffuse color</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_emission"
              c:identifier="cogl_pipeline_get_emission"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="292">Retrieves the pipelines current emission color.</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="303"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="294">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="emission" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="295">The location to store the emission color</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_front_face_winding"
              c:identifier="cogl_pipeline_get_front_face_winding"
              version="2.0">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="788">The order of the vertices within a primitive specifies whether it
is considered to be front or back facing. This function specifies
which order is considered to be the front
faces. %COGL_WINDING_COUNTER_CLOCKWISE sets the front faces to
primitives with vertices in a counter-clockwise order and
%COGL_WINDING_CLOCKWISE sets them to be clockwise. The default is
%COGL_WINDING_COUNTER_CLOCKWISE.</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="806"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-pipeline-state.h"
               line="800">The @pipeline front face winding

Status: Unstable</doc>
          <type name="Winding" c:type="CoglWinding"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="790">a #CoglPipeline</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_layer_mag_filter"
              c:identifier="cogl_pipeline_get_layer_mag_filter"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-layer-state.h"
             line="405">Retrieves the currently set magnification #CoglPipelineFilter set on
the specified layer. The magnification filter determines how the
layer should be sampled when up-scaled.

The default filter is %COGL_PIPELINE_FILTER_LINEAR but this can be
changed using cogl_pipeline_set_layer_filters().</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                         line="423"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-pipeline-layer-state.h"
               line="417">The magnification #CoglPipelineFilter for the
              specified layer.</doc>
          <type name="PipelineFilter" c:type="CoglPipelineFilter"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="407">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="408">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_layer_min_filter"
              c:identifier="cogl_pipeline_get_layer_min_filter"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-layer-state.h"
             line="384">Retrieves the currently set minification #CoglPipelineFilter set on
the specified layer. The miniifcation filter determines how the
layer should be sampled when down-scaled.

The default filter is %COGL_PIPELINE_FILTER_LINEAR but this can be
changed using cogl_pipeline_set_layer_filters().</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                         line="402"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-pipeline-layer-state.h"
               line="396">The minification #CoglPipelineFilter for the
              specified layer.</doc>
          <type name="PipelineFilter" c:type="CoglPipelineFilter"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="386">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="387">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_layer_point_sprite_coords_enabled"
              c:identifier="cogl_pipeline_get_layer_point_sprite_coords_enabled"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-layer-state.h"
             line="454">Gets whether point sprite coordinate generation is enabled for this
texture layer.</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                         line="469"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-pipeline-layer-state.h"
               line="462">whether the texture coordinates will be replaced with
point sprite coordinates.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="456">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="457">the layer number to check.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_layer_texture"
              c:identifier="cogl_pipeline_get_layer_texture"
              version="1.10"
              stability="Unstable">
        <source-position filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                         line="195"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-pipeline-layer-state.h"
               line="189">the texture that was set for the
  given layer of the pipeline or %NULL if no texture was set.</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="186">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="187">the index of the layer</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_layer_wrap_mode_p"
              c:identifier="cogl_pipeline_get_layer_wrap_mode_p"
              version="1.6"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-layer-state.h"
             line="541">Returns the wrap mode for the 'p' coordinate of texture lookups on this
layer.</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                         line="556"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-pipeline-layer-state.h"
               line="549">the wrap mode for the 'p' coordinate of texture lookups on
this layer.</doc>
          <type name="PipelineWrapMode" c:type="CoglPipelineWrapMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="543">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="544">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_layer_wrap_mode_s"
              c:identifier="cogl_pipeline_get_layer_wrap_mode_s"
              version="1.6"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-layer-state.h"
             line="472">Returns the wrap mode for the 's' coordinate of texture lookups on this
layer.</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                         line="487"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-pipeline-layer-state.h"
               line="480">the wrap mode for the 's' coordinate of texture lookups on
this layer.</doc>
          <type name="PipelineWrapMode" c:type="CoglPipelineWrapMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="474">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="475">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_layer_wrap_mode_t"
              c:identifier="cogl_pipeline_get_layer_wrap_mode_t"
              version="1.6"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-layer-state.h"
             line="506">Returns the wrap mode for the 't' coordinate of texture lookups on this
layer.</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                         line="521"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-pipeline-layer-state.h"
               line="514">the wrap mode for the 't' coordinate of texture lookups on
this layer.</doc>
          <type name="PipelineWrapMode" c:type="CoglPipelineWrapMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="508">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="509">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_n_layers"
              c:identifier="cogl_pipeline_get_n_layers"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-layer-state.h"
             line="346">Retrieves the number of layers defined for the given @pipeline</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                         line="358"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-pipeline-layer-state.h"
               line="352">the number of layers</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="348">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_per_vertex_point_size"
              c:identifier="cogl_pipeline_get_per_vertex_point_size"
              version="2.0"
              stability="Unstable">
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="572"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-pipeline-state.h"
               line="567">%TRUE if the pipeline has per-vertex point size
  enabled or %FALSE otherwise. The per-vertex point size can be
  enabled with cogl_pipeline_set_per_vertex_point_size().</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="563">a #CoglPipeline pointer</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_point_size"
              c:identifier="cogl_pipeline_get_point_size"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="515">Get the size of points drawn when %COGL_VERTICES_MODE_POINTS is
used with the vertex buffer API.</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="528"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-pipeline-state.h"
               line="522">the point size of the @pipeline.</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="517">a #CoglPipeline pointer</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_shininess"
              c:identifier="cogl_pipeline_get_shininess"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="260">Retrieves the pipelines current emission color.</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="272"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-pipeline-state.h"
               line="266">The pipelines current shininess value</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="262">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_specular"
              c:identifier="cogl_pipeline_get_specular"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="227">Retrieves the pipelines current specular color.</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="238"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="229">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="specular" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="230">The location to store the specular color</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uniform_location"
              c:identifier="cogl_pipeline_get_uniform_location"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline.h"
             line="159">This is used to get an integer representing the uniform with the
name @uniform_name. The integer can be passed to functions such as
cogl_pipeline_set_uniform_1f() to set the value of a uniform.

This function will always return a valid integer. Ie, unlike
OpenGL, it does not return -1 if the uniform is not available in
this pipeline so it can not be used to test whether uniforms are
present. It is not necessary to set the program on the pipeline
before calling this function.</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline.h" line="180"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-pipeline.h"
               line="174">A integer representing the location of the given uniform.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline.h"
                 line="161">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="uniform_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline.h"
                 line="162">The name of a uniform</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_user_program"
              c:identifier="cogl_pipeline_get_user_program"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="606">Queries what user program has been associated with the given
@pipeline using cogl_pipeline_set_user_program().</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="619"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-pipeline-state.h"
               line="613">The current user program or %COGL_INVALID_HANDLE.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="608">a #CoglPipeline object.</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_layer"
              c:identifier="cogl_pipeline_remove_layer"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-layer-state.h"
             line="198">This function removes a layer from your pipeline</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                         line="208"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="200">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="201">Specifies the layer you want to remove</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_alpha_test_function"
              c:identifier="cogl_pipeline_set_alpha_test_function"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="341">Before a primitive is blended with the framebuffer, it goes through an
alpha test stage which lets you discard fragments based on the current
alpha value. This function lets you change the function used to evaluate
the alpha channel, and thus determine which fragments are discarded
and which continue on to the blending stage.

The default is %COGL_PIPELINE_ALPHA_FUNC_ALWAYS</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="360"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="343">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="alpha_func" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="344">A @CoglPipelineAlphaFunc constant</doc>
            <type name="PipelineAlphaFunc" c:type="CoglPipelineAlphaFunc"/>
          </parameter>
          <parameter name="alpha_reference" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="345">A reference point that the chosen alpha function uses
  to compare incoming fragments to.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ambient"
              c:identifier="cogl_pipeline_set_ambient"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="123">Sets the pipeline's ambient color, in the standard OpenGL lighting
model. The ambient color affects the overall color of the object.

Since the diffuse color will be intense when the light hits the surface
directly, the ambient will be most apparent where the light hits at a
slant.

The default value is (0.2, 0.2, 0.2, 1.0)</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="141"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="125">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="ambient" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="126">The components of the desired ambient color</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ambient_and_diffuse"
              c:identifier="cogl_pipeline_set_ambient_and_diffuse"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="190">Conveniently sets the diffuse and ambient color of @pipeline at the same
time. See cogl_pipeline_set_ambient() and cogl_pipeline_set_diffuse().

The default ambient color is (0.2, 0.2, 0.2, 1.0)

The default diffuse color is (0.8, 0.8, 0.8, 1.0)</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="206"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="192">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="193">The components of the desired ambient and diffuse colors</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blend"
              c:identifier="cogl_pipeline_set_blend"
              version="2.0"
              stability="Unstable"
              throws="1">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="388">If not already familiar; please refer &lt;link linkend="cogl-Blend-Strings"&gt;here&lt;/link&gt;
for an overview of what blend strings are, and their syntax.

Blending occurs after the alpha test function, and combines fragments with
the framebuffer.

Currently the only blend function Cogl exposes is ADD(). So any valid
blend statements will be of the form:

|[
  &amp;lt;channel-mask&amp;gt;=ADD(SRC_COLOR*(&amp;lt;factor&amp;gt;), DST_COLOR*(&amp;lt;factor&amp;gt;))
]|

This is the list of source-names usable as blend factors:
&lt;itemizedlist&gt;
  &lt;listitem&gt;&lt;para&gt;SRC_COLOR: The color of the in comming fragment&lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;DST_COLOR: The color of the framebuffer&lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;CONSTANT: The constant set via cogl_pipeline_set_blend_constant()&lt;/para&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;

The source names can be used according to the
&lt;link linkend="cogl-Blend-String-syntax"&gt;color-source and factor syntax&lt;/link&gt;,
so for example "(1-SRC_COLOR[A])" would be a valid factor, as would
"(CONSTANT[RGB])"

These can also be used as factors:
&lt;itemizedlist&gt;
  &lt;listitem&gt;0: (0, 0, 0, 0)&lt;/listitem&gt;
  &lt;listitem&gt;1: (1, 1, 1, 1)&lt;/listitem&gt;
  &lt;listitem&gt;SRC_ALPHA_SATURATE_FACTOR: (f,f,f,1) where f = MIN(SRC_COLOR[A],1-DST_COLOR[A])&lt;/listitem&gt;
&lt;/itemizedlist&gt;

&lt;note&gt;Remember; all color components are normalized to the range [0, 1]
before computing the result of blending.&lt;/note&gt;

&lt;example id="cogl-Blend-Strings-blend-unpremul"&gt;
  &lt;title&gt;Blend Strings/1&lt;/title&gt;
  &lt;para&gt;Blend a non-premultiplied source over a destination with
  premultiplied alpha:&lt;/para&gt;
  &lt;programlisting&gt;
"RGB = ADD(SRC_COLOR*(SRC_COLOR[A]), DST_COLOR*(1-SRC_COLOR[A]))"
"A   = ADD(SRC_COLOR, DST_COLOR*(1-SRC_COLOR[A]))"
  &lt;/programlisting&gt;
&lt;/example&gt;

&lt;example id="cogl-Blend-Strings-blend-premul"&gt;
  &lt;title&gt;Blend Strings/2&lt;/title&gt;
  &lt;para&gt;Blend a premultiplied source over a destination with
  premultiplied alpha&lt;/para&gt;
  &lt;programlisting&gt;
"RGBA = ADD(SRC_COLOR, DST_COLOR*(1-SRC_COLOR[A]))"
  &lt;/programlisting&gt;
&lt;/example&gt;

The default blend string is:
|[
   RGBA = ADD (SRC_COLOR, DST_COLOR*(1-SRC_COLOR[A]))
]|

That gives normal alpha-blending when the calculated color for the pipeline
is in premultiplied form.</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="471"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-pipeline-state.h"
               line="462">%TRUE if the blend string was successfully parsed, and the
  described blending is supported by the underlying driver/hardware. If
  there was an error, %FALSE is returned and @error is set accordingly (if
  present).</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="390">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="blend_string" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="391">A &lt;link linkend="cogl-Blend-Strings"&gt;Cogl blend string&lt;/link&gt;
  describing the desired blend function.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blend_constant"
              c:identifier="cogl_pipeline_set_blend_constant"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="475">When blending is setup to reference a CONSTANT blend factor then
blending will depend on the constant set with this function.</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="487"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="477">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="constant_color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="478">The constant color you want</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_color"
              c:identifier="cogl_pipeline_set_color"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="44">Sets the basic color of the pipeline, used when no lighting is enabled.

Note that if you don't add any layers to the pipeline then the color
will be blended unmodified with the destination; the default blend
expects premultiplied colors: for example, use (0.5, 0.0, 0.0, 0.5) for
semi-transparent red. See cogl_color_premultiply().

The default value is (1.0, 1.0, 1.0, 1.0)</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="62"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="46">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="47">The components of the color</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_color4f"
              c:identifier="cogl_pipeline_set_color4f"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="87">Sets the basic color of the pipeline, used when no lighting is enabled.

The default value is (1.0, 1.0, 1.0, 1.0)</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="103"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="89">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="90">The red component</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="91">The green component</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="92">The blue component</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="93">The alpha component</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_color4ub"
              c:identifier="cogl_pipeline_set_color4ub"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="65">Sets the basic color of the pipeline, used when no lighting is enabled.

The default value is (0xff, 0xff, 0xff, 0xff)</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="81"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="67">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="68">The red component</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="69">The green component</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="70">The blue component</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="71">The alpha component</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_color_mask"
              c:identifier="cogl_pipeline_set_color_mask"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="589">Defines a bit mask of which color channels should be written to the
current framebuffer. If a bit is set in @color_mask that means that
color will be written.</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="603"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="591">a #CoglPipeline object.</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="color_mask" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="592">A #CoglColorMask of which color channels to write to
             the current framebuffer.</doc>
            <type name="ColorMask" c:type="CoglColorMask"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_cull_face_mode"
              c:identifier="cogl_pipeline_set_cull_face_mode"
              version="2.0">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="731">Sets which faces will be culled when drawing. Face culling can be
used to increase efficiency by avoiding drawing faces that would
get overridden. For example, if a model has gaps so that it is
impossible to see the inside then faces which are facing away from
the screen will never be seen so there is no point in drawing
them. This can be acheived by setting the cull face mode to
%COGL_PIPELINE_CULL_FACE_MODE_BACK.

Face culling relies on the primitives being drawn with a specific
order to represent which faces are facing inside and outside the
model. This order can be specified by calling
cogl_pipeline_set_front_face_winding().

Status: Unstable</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="753"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="733">A #CoglPipeline</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="cull_face_mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="734">The new mode to set</doc>
            <type name="PipelineCullFaceMode"
                  c:type="CoglPipelineCullFaceMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_depth_state"
              c:identifier="cogl_pipeline_set_depth_state"
              version="2.0"
              introspectable="0"
              stability="Unstable"
              throws="1">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="672">This commits all the depth state configured in @state struct to the
given @pipeline. The configuration values are copied into the
pipeline so there is no requirement to keep the #CoglDepthState
struct around if you don't need it any more.

Note: Since some platforms do not support the depth range feature
it is possible for this function to fail and report an @error.</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="693"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-pipeline-state.h"
               line="686">TRUE if the GPU supports all the given @state else %FALSE
         and returns an @error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="674">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="state" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="675">A #CoglDepthState struct</doc>
            <type c:type="const CoglDepthState*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_diffuse"
              c:identifier="cogl_pipeline_set_diffuse"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="158">Sets the pipeline's diffuse color, in the standard OpenGL lighting
model. The diffuse color is most intense where the light hits the
surface directly - perpendicular to the surface.

The default value is (0.8, 0.8, 0.8, 1.0)</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="173"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="160">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="diffuse" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="161">The components of the desired diffuse color</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_emission"
              c:identifier="cogl_pipeline_set_emission"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="274">Sets the pipeline's emissive color, in the standard OpenGL lighting
model. It will look like the surface is a light source emitting this
color.

The default value is (0.0, 0.0, 0.0, 1.0)</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="289"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="276">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="emission" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="277">The components of the desired emissive color</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_front_face_winding"
              c:identifier="cogl_pipeline_set_front_face_winding"
              version="2.0">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="768">The order of the vertices within a primitive specifies whether it
is considered to be front or back facing. This function specifies
which order is considered to be the front
faces. %COGL_WINDING_COUNTER_CLOCKWISE sets the front faces to
primitives with vertices in a counter-clockwise order and
%COGL_WINDING_CLOCKWISE sets them to be clockwise. The default is
%COGL_WINDING_COUNTER_CLOCKWISE.

Status: Unstable</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="785"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="770">a #CoglPipeline</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="front_winding" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="771">the winding order</doc>
            <type name="Winding" c:type="CoglWinding"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_combine"
              c:identifier="cogl_pipeline_set_layer_combine"
              version="2.0"
              stability="Unstable"
              throws="1">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-layer-state.h"
             line="211">If not already familiar; you can refer
&lt;link linkend="cogl-Blend-Strings"&gt;here&lt;/link&gt; for an overview of what blend
strings are and there syntax.

These are all the functions available for texture combining:
&lt;itemizedlist&gt;
  &lt;listitem&gt;REPLACE(arg0) = arg0&lt;/listitem&gt;
  &lt;listitem&gt;MODULATE(arg0, arg1) = arg0 x arg1&lt;/listitem&gt;
  &lt;listitem&gt;ADD(arg0, arg1) = arg0 + arg1&lt;/listitem&gt;
  &lt;listitem&gt;ADD_SIGNED(arg0, arg1) = arg0 + arg1 - 0.5&lt;/listitem&gt;
  &lt;listitem&gt;INTERPOLATE(arg0, arg1, arg2) = arg0 x arg2 + arg1 x (1 - arg2)&lt;/listitem&gt;
  &lt;listitem&gt;SUBTRACT(arg0, arg1) = arg0 - arg1&lt;/listitem&gt;
  &lt;listitem&gt;
    &lt;programlisting&gt;
 DOT3_RGB(arg0, arg1) = 4 x ((arg0[R] - 0.5)) * (arg1[R] - 0.5) +
                             (arg0[G] - 0.5)) * (arg1[G] - 0.5) +
                             (arg0[B] - 0.5)) * (arg1[B] - 0.5))
    &lt;/programlisting&gt;
  &lt;/listitem&gt;
  &lt;listitem&gt;
    &lt;programlisting&gt;
 DOT3_RGBA(arg0, arg1) = 4 x ((arg0[R] - 0.5)) * (arg1[R] - 0.5) +
                              (arg0[G] - 0.5)) * (arg1[G] - 0.5) +
                              (arg0[B] - 0.5)) * (arg1[B] - 0.5))
    &lt;/programlisting&gt;
  &lt;/listitem&gt;
&lt;/itemizedlist&gt;

Refer to the
&lt;link linkend="cogl-Blend-String-syntax"&gt;color-source syntax&lt;/link&gt; for
describing the arguments. The valid source names for texture combining
are:
&lt;variablelist&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;TEXTURE&lt;/term&gt;
    &lt;listitem&gt;Use the color from the current texture layer&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;TEXTURE_0, TEXTURE_1, etc&lt;/term&gt;
    &lt;listitem&gt;Use the color from the specified texture layer&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;CONSTANT&lt;/term&gt;
    &lt;listitem&gt;Use the color from the constant given with
    cogl_pipeline_set_layer_combine_constant()&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;PRIMARY&lt;/term&gt;
    &lt;listitem&gt;Use the color of the pipeline as set with
    cogl_pipeline_set_color()&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;PREVIOUS&lt;/term&gt;
    &lt;listitem&gt;Either use the texture color from the previous layer, or
    if this is layer 0, use the color of the pipeline as set with
    cogl_pipeline_set_color()&lt;/listitem&gt;
  &lt;/varlistentry&gt;
&lt;/variablelist&gt;

&lt;refsect2 id="cogl-Layer-Combine-Examples"&gt;
  &lt;title&gt;Layer Combine Examples&lt;/title&gt;
  &lt;para&gt;This is effectively what the default blending is:&lt;/para&gt;
  &lt;informalexample&gt;&lt;programlisting&gt;
  RGBA = MODULATE (PREVIOUS, TEXTURE)
  &lt;/programlisting&gt;&lt;/informalexample&gt;
  &lt;para&gt;This could be used to cross-fade between two images, using
  the alpha component of a constant as the interpolator. The constant
  color is given by calling
  cogl_pipeline_set_layer_combine_constant().&lt;/para&gt;
  &lt;informalexample&gt;&lt;programlisting&gt;
  RGBA = INTERPOLATE (PREVIOUS, TEXTURE, CONSTANT[A])
  &lt;/programlisting&gt;&lt;/informalexample&gt;
&lt;/refsect2&gt;

&lt;note&gt;You can't give a multiplication factor for arguments as you can
with blending.&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                         line="306"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-pipeline-layer-state.h"
               line="298">%TRUE if the blend string was successfully parsed, and the
  described texture combining is supported by the underlying driver and
  or hardware. On failure, %FALSE is returned and @error is set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="213">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="214">Specifies the layer you want define a combine function for</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="blend_string" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="215">A &lt;link linkend="cogl-Blend-Strings"&gt;Cogl blend string&lt;/link&gt;
   describing the desired texture combine function.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_combine_constant"
              c:identifier="cogl_pipeline_set_layer_combine_constant"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-layer-state.h"
             line="311">When you are using the 'CONSTANT' color source in a layer combine
description then you can use this function to define its value.</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                         line="325"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="313">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="314">Specifies the layer you want to specify a constant used
              for texture combining</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="constant" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="316">The constant color you want</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_filters"
              c:identifier="cogl_pipeline_set_layer_filters"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-layer-state.h"
             line="360">Changes the decimation and interpolation filters used when a texture is
drawn at other scales than 100%.

&lt;note&gt;It is an error to pass anything other than
%COGL_PIPELINE_FILTER_NEAREST or %COGL_PIPELINE_FILTER_LINEAR as
magnification filters since magnification doesn't ever need to
reference values stored in the mipmap chain.&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                         line="379"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="362">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="363">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="min_filter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="364">the filter used when scaling a texture down.</doc>
            <type name="PipelineFilter" c:type="CoglPipelineFilter"/>
          </parameter>
          <parameter name="mag_filter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="365">the filter used when magnifying a texture.</doc>
            <type name="PipelineFilter" c:type="CoglPipelineFilter"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_matrix"
              c:identifier="cogl_pipeline_set_layer_matrix"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-layer-state.h"
             line="329">This function lets you set a matrix that can be used to e.g. translate
and rotate a single layer of a pipeline used to fill your geometry.</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                         line="342"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="331">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="332">the index for the layer inside @pipeline</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="333">the transformation matrix for the layer</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_null_texture"
              c:identifier="cogl_pipeline_set_layer_null_texture"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-layer-state.h"
             line="158">Sets the texture for this layer to be the default texture for the
given type. This is equivalent to calling
cogl_pipeline_set_layer_texture() with %NULL for the texture
argument except that you can also specify the type of default
texture to use. The default texture is a 1x1 pixel white texture.

This function is mostly useful if you want to create a base
pipeline that you want to create multiple copies from using
cogl_pipeline_copy(). In that case this function can be used to
specify the texture type so that any pipeline copies can share the
internal texture type state for efficiency.</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                         line="180"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="160">A #CoglPipeline</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="161">The layer number to modify</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="texture_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="162">The type of the default texture to use</doc>
            <type name="TextureType" c:type="CoglTextureType"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_point_sprite_coords_enabled"
              c:identifier="cogl_pipeline_set_layer_point_sprite_coords_enabled"
              version="2.0"
              stability="Unstable"
              throws="1">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-layer-state.h"
             line="426">When rendering points, if @enable is %TRUE then the texture
coordinates for this layer will be replaced with coordinates that
vary from 0.0 to 1.0 across the primitive. The top left of the
point will have the coordinates 0.0,0.0 and the bottom right will
have 1.0,1.0. If @enable is %FALSE then the coordinates will be
fixed for the entire point.

This function will only work if %COGL_FEATURE_ID_POINT_SPRITE is
available. If the feature is not available then the function will
return %FALSE and set @error.</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                         line="449"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-pipeline-layer-state.h"
               line="444">%TRUE if the function succeeds, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="428">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="429">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="enable" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="430">whether to enable point sprite coord generation.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_texture"
              c:identifier="cogl_pipeline_set_layer_texture">
        <source-position filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                         line="154"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="texture" transfer-ownership="none">
            <type name="Texture" c:type="CoglTexture*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_wrap_mode"
              c:identifier="cogl_pipeline_set_layer_wrap_mode"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-layer-state.h"
             line="576">Sets the wrap mode for all three coordinates of texture lookups on
this layer. This is equivalent to calling
cogl_pipeline_set_layer_wrap_mode_s(),
cogl_pipeline_set_layer_wrap_mode_t() and
cogl_pipeline_set_layer_wrap_mode_p() separately.</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                         line="592"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="578">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="579">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="580">the new wrap mode</doc>
            <type name="PipelineWrapMode" c:type="CoglPipelineWrapMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_wrap_mode_p"
              c:identifier="cogl_pipeline_set_layer_wrap_mode_p"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-layer-state.h"
             line="559">Sets the wrap mode for the 'p' coordinate of texture lookups on
this layer. 'p' is the third coordinate.</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                         line="572"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="561">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="562">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="563">the new wrap mode</doc>
            <type name="PipelineWrapMode" c:type="CoglPipelineWrapMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_wrap_mode_s"
              c:identifier="cogl_pipeline_set_layer_wrap_mode_s"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-layer-state.h"
             line="490">Sets the wrap mode for the 's' coordinate of texture lookups on this layer.</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                         line="502"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="492">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="493">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="494">the new wrap mode</doc>
            <type name="PipelineWrapMode" c:type="CoglPipelineWrapMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_wrap_mode_t"
              c:identifier="cogl_pipeline_set_layer_wrap_mode_t"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-layer-state.h"
             line="525">Sets the wrap mode for the 't' coordinate of texture lookups on this layer.</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                         line="537"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="527">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="528">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                 line="529">the new wrap mode</doc>
            <type name="PipelineWrapMode" c:type="CoglPipelineWrapMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_per_vertex_point_size"
              c:identifier="cogl_pipeline_set_per_vertex_point_size"
              version="2.0"
              stability="Unstable"
              throws="1">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="530">Sets whether to use a per-vertex point size or to use the value set
by cogl_pipeline_set_point_size(). If per-vertex point size is
enabled then the point size can be set for an individual point
either by drawing with a #CoglAttribute with the name
cogl_point_size_in or by writing to the GLSL builtin
cogl_point_size_out from a vertex shader snippet.

If per-vertex point size is enabled and this attribute is not used
and cogl_point_size_out is not written to then the results are
undefined.

Note that enabling this will only work if the
%COGL_FEATURE_ID_PER_VERTEX_POINT_SIZE feature is available. If
this is not available then the function will return %FALSE and set
a #CoglError.</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="557"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-pipeline-state.h"
               line="554">%TRUE if the change suceeded or %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="532">a #CoglPipeline pointer</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="enable" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="533">whether to enable per-vertex point size</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_point_size"
              c:identifier="cogl_pipeline_set_point_size"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="490">Changes the size of points drawn when %COGL_VERTICES_MODE_POINTS is
used with the attribute buffer API. Note that typically the GPU
will only support a limited minimum and maximum range of point
sizes. If the chosen point size is outside that range then the
nearest value within that range will be used instead. The size of a
point is in screen space so it will be the same regardless of any
transformations.

If the point size is set to 0.0 then drawing points with the
pipeline will have undefined results. This is the default value so
if an application wants to draw points it must make sure to use a
pipeline that has an explicit point size set on it.</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="512"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="492">a #CoglPipeline pointer</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="point_size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="493">the new point size.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_shininess"
              c:identifier="cogl_pipeline_set_shininess"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="241">Sets the shininess of the pipeline, in the standard OpenGL lighting
model, which determines the size of the specular highlights. A
higher @shininess will produce smaller highlights which makes the
object appear more shiny.

The default value is 0.0</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="257"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="243">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="shininess" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="244">The desired shininess; must be &gt;= 0.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_specular"
              c:identifier="cogl_pipeline_set_specular"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="209">Sets the pipeline's specular color, in the standard OpenGL lighting
model. The intensity of the specular color depends on the viewport
position, and is brightest along the lines of reflection.

The default value is (0.0, 0.0, 0.0, 1.0)</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="224"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="211">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="specular" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="212">The components of the desired specular color</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_1f"
              c:identifier="cogl_pipeline_set_uniform_1f"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="808">Sets a new value for the uniform at @uniform_location. If this
pipeline has a user program attached and is later used as a source
for drawing, the given value will be assigned to the uniform which
can be accessed from the shader's source. The value for
@uniform_location should be retrieved from the string name of the
uniform by calling cogl_pipeline_get_uniform_location().

This function should be used to set uniforms that are of type
float. It can also be used to set a single member of a float array
uniform.</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="829"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="810">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="uniform_location" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="811">The uniform's location identifier</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="812">The new value for the uniform</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_1i"
              c:identifier="cogl_pipeline_set_uniform_1i"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="833">Sets a new value for the uniform at @uniform_location. If this
pipeline has a user program attached and is later used as a source
for drawing, the given value will be assigned to the uniform which
can be accessed from the shader's source. The value for
@uniform_location should be retrieved from the string name of the
uniform by calling cogl_pipeline_get_uniform_location().

This function should be used to set uniforms that are of type
int. It can also be used to set a single member of a int array
uniform or a sampler uniform.</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="854"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="835">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="uniform_location" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="836">The uniform's location identifier</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="837">The new value for the uniform</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_float"
              c:identifier="cogl_pipeline_set_uniform_float"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="858">Sets new values for the uniform at @uniform_location. If this
pipeline has a user program attached and is later used as a source
for drawing, the given values will be assigned to the uniform which
can be accessed from the shader's source. The value for
@uniform_location should be retrieved from the string name of the
uniform by calling cogl_pipeline_get_uniform_location().

This function can be used to set any floating point type uniform,
including float arrays and float vectors. For example, to set a
single vec4 uniform you would use 4 for @n_components and 1 for
@count. To set an array of 8 float values, you could use 1 for
@n_components and 8 for @count.</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="883"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="860">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="uniform_location" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="861">The uniform's location identifier</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="n_components" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="862">The number of components in the corresponding uniform's type</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="863">The number of values to set</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="864">Pointer to the new values to set</doc>
            <type name="gfloat" c:type="const float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_int"
              c:identifier="cogl_pipeline_set_uniform_int"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="889">Sets new values for the uniform at @uniform_location. If this
pipeline has a user program attached and is later used as a source
for drawing, the given values will be assigned to the uniform which
can be accessed from the shader's source. The value for
@uniform_location should be retrieved from the string name of the
uniform by calling cogl_pipeline_get_uniform_location().

This function can be used to set any integer type uniform,
including int arrays and int vectors. For example, to set a single
ivec4 uniform you would use 4 for @n_components and 1 for
@count. To set an array of 8 int values, you could use 1 for
@n_components and 8 for @count.</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="914"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="891">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="uniform_location" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="892">The uniform's location identifier</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="n_components" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="893">The number of components in the corresponding uniform's type</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="894">The number of values to set</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="895">Pointer to the new values to set</doc>
            <type name="gint" c:type="const int*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_matrix"
              c:identifier="cogl_pipeline_set_uniform_matrix"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="920">Sets new values for the uniform at @uniform_location. If this
pipeline has a user program attached and is later used as a source
for drawing, the given values will be assigned to the uniform which
can be accessed from the shader's source. The value for
@uniform_location should be retrieved from the string name of the
uniform by calling cogl_pipeline_get_uniform_location().

This function can be used to set any matrix type uniform, including
matrix arrays. For example, to set a single mat4 uniform you would
use 4 for @dimensions and 1 for @count. To set an array of 8
mat3 values, you could use 3 for @dimensions and 8 for @count.

If @transpose is %FALSE then the matrix is expected to be in
column-major order or if it is %TRUE then the matrix is in
row-major order. You can pass a #CoglMatrix by calling by passing
the result of cogl_matrix_get_array() in @value and setting
@transpose to %FALSE.</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="951"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="922">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="uniform_location" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="923">The uniform's location identifier</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dimensions" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="924">The size of the matrix</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="925">The number of values to set</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="transpose" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="926">Whether to transpose the matrix</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="927">Pointer to the new values to set</doc>
            <type name="gfloat" c:type="const float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_user_program"
              c:identifier="cogl_pipeline_set_user_program"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="621">Associates a linked CoglProgram with the given pipeline so that the
program can take full control of vertex and/or fragment processing.

This is an example of how it can be used to associate an ARBfp
program with a #CoglPipeline:
|[
CoglHandle shader;
CoglHandle program;
CoglPipeline *pipeline;

shader = cogl_create_shader (COGL_SHADER_TYPE_FRAGMENT);
cogl_shader_source (shader,
                    "!!ARBfp1.0\n"
                    "MOV result.color,fragment.color;\n"
                    "END\n");
cogl_shader_compile (shader);

program = cogl_create_program ();
cogl_program_attach_shader (program, shader);
cogl_program_link (program);

pipeline = cogl_pipeline_new ();
cogl_pipeline_set_user_program (pipeline, program);

cogl_set_source_color4ub (0xff, 0x00, 0x00, 0xff);
cogl_rectangle (0, 0, 100, 100);
]|

It is possibly worth keeping in mind that this API is not part of
the long term design for how we want to expose shaders to Cogl
developers (We are planning on deprecating the cogl_program and
cogl_shader APIs in favour of a "snippet" framework) but in the
meantime we hope this will handle most practical GLSL and ARBfp
requirements.

Also remember you need to check for either the
%COGL_FEATURE_SHADERS_GLSL or %COGL_FEATURE_SHADERS_ARBFP before
using the cogl_program or cogl_shader API.</doc>
        <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                         line="669"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="623">a #CoglPipeline object.</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="program" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-pipeline-state.h"
                 line="624">A #CoglHandle to a linked CoglProgram</doc>
            <type name="Handle" c:type="CoglHandle"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <enumeration name="PipelineAlphaFunc" c:type="CoglPipelineAlphaFunc">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-pipeline-state.h"
           line="306">Alpha testing happens before blending primitives with the framebuffer and
gives an opportunity to discard fragments based on a comparison with the
incoming alpha value and a reference alpha value. The #CoglPipelineAlphaFunc
determines how the comparison is done.</doc>
      <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                       line="338"/>
      <member name="never"
              value="512"
              c:identifier="COGL_PIPELINE_ALPHA_FUNC_NEVER">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="308">Never let the fragment through.</doc>
      </member>
      <member name="less"
              value="513"
              c:identifier="COGL_PIPELINE_ALPHA_FUNC_LESS">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="309">Let the fragment through if the incoming
  alpha value is less than the reference alpha value</doc>
      </member>
      <member name="equal"
              value="514"
              c:identifier="COGL_PIPELINE_ALPHA_FUNC_EQUAL">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="311">Let the fragment through if the incoming
  alpha value equals the reference alpha value</doc>
      </member>
      <member name="lequal"
              value="515"
              c:identifier="COGL_PIPELINE_ALPHA_FUNC_LEQUAL">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="313">Let the fragment through if the incoming
  alpha value is less than or equal to the reference alpha value</doc>
      </member>
      <member name="greater"
              value="516"
              c:identifier="COGL_PIPELINE_ALPHA_FUNC_GREATER">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="315">Let the fragment through if the incoming
  alpha value is greater than the reference alpha value</doc>
      </member>
      <member name="notequal"
              value="517"
              c:identifier="COGL_PIPELINE_ALPHA_FUNC_NOTEQUAL">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="317">Let the fragment through if the incoming
  alpha value does not equal the reference alpha value</doc>
      </member>
      <member name="gequal"
              value="518"
              c:identifier="COGL_PIPELINE_ALPHA_FUNC_GEQUAL">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="319">Let the fragment through if the incoming
  alpha value is greater than or equal to the reference alpha value.</doc>
      </member>
      <member name="always"
              value="519"
              c:identifier="COGL_PIPELINE_ALPHA_FUNC_ALWAYS">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="321">Always let the fragment through.</doc>
      </member>
    </enumeration>
    <enumeration name="PipelineCullFaceMode" c:type="CoglPipelineCullFaceMode">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-pipeline-state.h"
           line="712">Specifies which faces should be culled. This can be set on a
pipeline using cogl_pipeline_set_cull_face_mode().</doc>
      <source-position filename="../cogl/cogl/cogl-pipeline-state.h"
                       line="729"/>
      <member name="none"
              value="0"
              c:identifier="COGL_PIPELINE_CULL_FACE_MODE_NONE">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="714">Neither face will be
 culled. This is the default.</doc>
      </member>
      <member name="front"
              value="1"
              c:identifier="COGL_PIPELINE_CULL_FACE_MODE_FRONT">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="716">Front faces will be culled.</doc>
      </member>
      <member name="back"
              value="2"
              c:identifier="COGL_PIPELINE_CULL_FACE_MODE_BACK">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="717">Back faces will be culled.</doc>
      </member>
      <member name="both"
              value="3"
              c:identifier="COGL_PIPELINE_CULL_FACE_MODE_BOTH">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-state.h"
             line="718">All faces will be culled.</doc>
      </member>
    </enumeration>
    <enumeration name="PipelineFilter" c:type="CoglPipelineFilter">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-pipeline-layer-state.h"
           line="45">Texture filtering is used whenever the current pixel maps either to more
than one texture element (texel) or less than one. These filter enums
correspond to different strategies used to come up with a pixel color, by
possibly referring to multiple neighbouring texels and taking a weighted
average or simply using the nearest texel.</doc>
      <source-position filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                       line="80"/>
      <member name="nearest"
              value="9728"
              c:identifier="COGL_PIPELINE_FILTER_NEAREST">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-layer-state.h"
             line="47">Measuring in manhatten distance from the,
  current pixel center, use the nearest texture texel</doc>
      </member>
      <member name="linear"
              value="9729"
              c:identifier="COGL_PIPELINE_FILTER_LINEAR">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-layer-state.h"
             line="49">Use the weighted average of the 4 texels
  nearest the current pixel center</doc>
      </member>
      <member name="nearest_mipmap_nearest"
              value="9984"
              c:identifier="COGL_PIPELINE_FILTER_NEAREST_MIPMAP_NEAREST">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-layer-state.h"
             line="51">Select the mimap level whose
  texel size most closely matches the current pixel, and use the
  %COGL_PIPELINE_FILTER_NEAREST criterion</doc>
      </member>
      <member name="linear_mipmap_nearest"
              value="9985"
              c:identifier="COGL_PIPELINE_FILTER_LINEAR_MIPMAP_NEAREST">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-layer-state.h"
             line="54">Select the mimap level whose
  texel size most closely matches the current pixel, and use the
  %COGL_PIPELINE_FILTER_LINEAR criterion</doc>
      </member>
      <member name="nearest_mipmap_linear"
              value="9986"
              c:identifier="COGL_PIPELINE_FILTER_NEAREST_MIPMAP_LINEAR">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-layer-state.h"
             line="57">Select the two mimap levels
  whose texel size most closely matches the current pixel, use
  the %COGL_PIPELINE_FILTER_NEAREST criterion on each one and take
  their weighted average</doc>
      </member>
      <member name="linear_mipmap_linear"
              value="9987"
              c:identifier="COGL_PIPELINE_FILTER_LINEAR_MIPMAP_LINEAR">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-layer-state.h"
             line="61">Select the two mimap levels
  whose texel size most closely matches the current pixel, use
  the %COGL_PIPELINE_FILTER_LINEAR criterion on each one and take
  their weighted average</doc>
      </member>
    </enumeration>
    <callback name="PipelineLayerCallback"
              c:type="CoglPipelineLayerCallback"
              version="2.0"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-pipeline.h"
           line="125">The callback prototype used with cogl_pipeline_foreach_layer() for
iterating all the layers of a @pipeline.</doc>
      <source-position filename="../cogl/cogl/cogl-pipeline.h" line="137"/>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="pipeline" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-pipeline.h"
               line="127">The #CoglPipeline whos layers are being iterated</doc>
          <type name="Pipeline" c:type="CoglPipeline*"/>
        </parameter>
        <parameter name="layer_index" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-pipeline.h"
               line="128">The current layer index</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="2">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-pipeline.h"
               line="129">The private data passed to cogl_pipeline_foreach_layer()</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="PipelineWrapMode"
                 version="2.0"
                 c:type="CoglPipelineWrapMode">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-pipeline-layer-state.h"
           line="83">The wrap mode specifies what happens when texture coordinates
outside the range 01 are used. Note that if the filter mode is
anything but %COGL_PIPELINE_FILTER_NEAREST then texels outside the
range 01 might be used even when the coordinate is exactly 0 or 1
because OpenGL will try to sample neighbouring pixels. For example
if you are trying to render the full texture then you may get
artifacts around the edges when the pixels from the other side are
merged in if the wrap mode is set to repeat.</doc>
      <source-position filename="../cogl/cogl/cogl-pipeline-layer-state.h"
                       line="123"/>
      <member name="repeat"
              value="10497"
              c:identifier="COGL_PIPELINE_WRAP_MODE_REPEAT">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-layer-state.h"
             line="85">The texture will be repeated. This
  is useful for example to draw a tiled background.</doc>
      </member>
      <member name="mirrored_repeat"
              value="33648"
              c:identifier="COGL_PIPELINE_WRAP_MODE_MIRRORED_REPEAT">
      </member>
      <member name="clamp_to_edge"
              value="33071"
              c:identifier="COGL_PIPELINE_WRAP_MODE_CLAMP_TO_EDGE">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-layer-state.h"
             line="87">The coordinates outside the
  range 01 will sample copies of the edge pixels of the
  texture. This is useful to avoid artifacts if only one copy of
  the texture is being rendered.</doc>
      </member>
      <member name="automatic"
              value="519"
              c:identifier="COGL_PIPELINE_WRAP_MODE_AUTOMATIC">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline-layer-state.h"
             line="91">Cogl will try to automatically
  decide which of the above two to use. For cogl_rectangle(), it
  will use repeat mode if any of the texture coordinates are
  outside the range 01, otherwise it will use clamp to edge. For
  cogl_polygon() it will always use repeat mode. For
  cogl_vertex_buffer_draw() it will use repeat mode except for
  layers that have point sprite coordinate generation enabled. This
  is the default value.</doc>
      </member>
    </enumeration>
    <bitfield name="PixelFormat" version="0.8" c:type="CoglPixelFormat">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-types.h"
           line="218">Pixel formats used by Cogl. For the formats with a byte per
component, the order of the components specify the order in
increasing memory addresses. So for example
%COGL_PIXEL_FORMAT_RGB_888 would have the red component in the
lowest address, green in the next address and blue after that
regardless of the endianness of the system.

For the formats with non byte aligned components the component
order specifies the order within a 16-bit or 32-bit number from
most significant bit to least significant. So for
%COGL_PIXEL_FORMAT_RGB_565, the red component would be in bits
11-15, the green component would be in 6-11 and the blue component
would be in 1-5. Therefore the order in memory depends on the
endianness of the system.

When uploading a texture %COGL_PIXEL_FORMAT_ANY can be used as the
internal format. Cogl will try to pick the best format to use
internally and convert the texture data if necessary.</doc>
      <source-position filename="../cogl/cogl/cogl-types.h" line="314"/>
      <member name="any" value="0" c:identifier="COGL_PIXEL_FORMAT_ANY">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="220">Any format</doc>
      </member>
      <member name="a_8" value="17" c:identifier="COGL_PIXEL_FORMAT_A_8">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="221">8 bits alpha mask</doc>
      </member>
      <member name="rgb_565"
              value="4"
              c:identifier="COGL_PIXEL_FORMAT_RGB_565">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="225">RGB, 16 bits</doc>
      </member>
      <member name="rgba_4444"
              value="21"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_4444">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="226">RGBA, 16 bits</doc>
      </member>
      <member name="rgba_5551"
              value="22"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_5551">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="227">RGBA, 16 bits</doc>
      </member>
      <member name="yuv" value="7" c:identifier="COGL_PIXEL_FORMAT_YUV">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="228">Not currently supported</doc>
      </member>
      <member name="g_8" value="8" c:identifier="COGL_PIXEL_FORMAT_G_8">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="229">Single luminance component</doc>
      </member>
      <member name="rg_88" value="9" c:identifier="COGL_PIXEL_FORMAT_RG_88">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="222">RG, 16 bits. Note that red-green textures
  are only available if %COGL_FEATURE_ID_TEXTURE_RG is advertised.
  See cogl_texture_set_components() for details.</doc>
      </member>
      <member name="rgb_888"
              value="2"
              c:identifier="COGL_PIXEL_FORMAT_RGB_888">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="230">RGB, 24 bits</doc>
      </member>
      <member name="bgr_888"
              value="34"
              c:identifier="COGL_PIXEL_FORMAT_BGR_888">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="231">BGR, 24 bits</doc>
      </member>
      <member name="rgba_8888"
              value="19"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_8888">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="232">RGBA, 32 bits</doc>
      </member>
      <member name="bgra_8888"
              value="51"
              c:identifier="COGL_PIXEL_FORMAT_BGRA_8888">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="233">BGRA, 32 bits</doc>
      </member>
      <member name="argb_8888"
              value="83"
              c:identifier="COGL_PIXEL_FORMAT_ARGB_8888">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="234">ARGB, 32 bits</doc>
      </member>
      <member name="abgr_8888"
              value="115"
              c:identifier="COGL_PIXEL_FORMAT_ABGR_8888">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="235">ABGR, 32 bits</doc>
      </member>
      <member name="rgba_1010102"
              value="29"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_1010102">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="236">RGBA, 32 bits, 10 bpc</doc>
      </member>
      <member name="bgra_1010102"
              value="61"
              c:identifier="COGL_PIXEL_FORMAT_BGRA_1010102">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="237">BGRA, 32 bits, 10 bpc</doc>
      </member>
      <member name="argb_2101010"
              value="93"
              c:identifier="COGL_PIXEL_FORMAT_ARGB_2101010">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="238">ARGB, 32 bits, 10 bpc</doc>
      </member>
      <member name="abgr_2101010"
              value="125"
              c:identifier="COGL_PIXEL_FORMAT_ABGR_2101010">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="239">ABGR, 32 bits, 10 bpc</doc>
      </member>
      <member name="rgba_8888_pre"
              value="147"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_8888_PRE">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="240">Premultiplied RGBA, 32 bits</doc>
      </member>
      <member name="bgra_8888_pre"
              value="179"
              c:identifier="COGL_PIXEL_FORMAT_BGRA_8888_PRE">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="241">Premultiplied BGRA, 32 bits</doc>
      </member>
      <member name="argb_8888_pre"
              value="211"
              c:identifier="COGL_PIXEL_FORMAT_ARGB_8888_PRE">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="242">Premultiplied ARGB, 32 bits</doc>
      </member>
      <member name="abgr_8888_pre"
              value="243"
              c:identifier="COGL_PIXEL_FORMAT_ABGR_8888_PRE">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="243">Premultiplied ABGR, 32 bits</doc>
      </member>
      <member name="rgba_4444_pre"
              value="149"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_4444_PRE">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="244">Premultiplied RGBA, 16 bits</doc>
      </member>
      <member name="rgba_5551_pre"
              value="150"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_5551_PRE">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="245">Premultiplied RGBA, 16 bits</doc>
      </member>
      <member name="rgba_1010102_pre"
              value="157"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_1010102_PRE">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="246">Premultiplied RGBA, 32 bits, 10 bpc</doc>
      </member>
      <member name="bgra_1010102_pre"
              value="189"
              c:identifier="COGL_PIXEL_FORMAT_BGRA_1010102_PRE">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="247">Premultiplied BGRA, 32 bits, 10 bpc</doc>
      </member>
      <member name="argb_2101010_pre"
              value="221"
              c:identifier="COGL_PIXEL_FORMAT_ARGB_2101010_PRE">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="248">Premultiplied ARGB, 32 bits, 10 bpc</doc>
      </member>
      <member name="abgr_2101010_pre"
              value="253"
              c:identifier="COGL_PIXEL_FORMAT_ABGR_2101010_PRE">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="249">Premultiplied ABGR, 32 bits, 10 bpc</doc>
      </member>
      <member name="depth_16"
              value="265"
              c:identifier="COGL_PIXEL_FORMAT_DEPTH_16">
      </member>
      <member name="depth_32"
              value="259"
              c:identifier="COGL_PIXEL_FORMAT_DEPTH_32">
      </member>
      <member name="depth_24_stencil_8"
              value="771"
              c:identifier="COGL_PIXEL_FORMAT_DEPTH_24_STENCIL_8">
      </member>
    </bitfield>
    <record name="Quaternion" c:type="CoglQuaternion" disguised="1">
      <source-position filename="../cogl/cogl/cogl-types.h" line="122"/>
    </record>
    <bitfield name="ReadPixelsFlags"
              version="1.0"
              c:type="CoglReadPixelsFlags">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-types.h"
           line="834">Flags for cogl_framebuffer_read_pixels_into_bitmap()</doc>
      <source-position filename="../cogl/cogl/cogl-types.h" line="845"/>
      <member name="read_pixels_color_buffer"
              value="1"
              c:identifier="COGL_READ_PIXELS_COLOR_BUFFER">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="836">Read from the color buffer</doc>
      </member>
    </bitfield>
    <enumeration name="RendererError" c:type="CoglRendererError">
      <source-position filename="../cogl/cogl/cogl-types.h" line="712"/>
      <member name="xlib_display_open"
              value="0"
              c:identifier="COGL_RENDERER_ERROR_XLIB_DISPLAY_OPEN">
      </member>
      <member name="bad_constraint"
              value="1"
              c:identifier="COGL_RENDERER_ERROR_BAD_CONSTRAINT">
      </member>
    </enumeration>
    <constant name="STENCIL_BIT" value="512" c:type="COGL_STENCIL_BIT">
      <source-position filename="../cogl/cogl/cogl-types.h" line="148"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <enumeration name="ShaderType" version="1.0" c:type="CoglShaderType">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-shader.h"
           line="228">Types of shaders</doc>
      <source-position filename="../cogl/cogl/deprecated/cogl-shader.h"
                       line="241"/>
      <member name="vertex" value="0" c:identifier="COGL_SHADER_TYPE_VERTEX">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-shader.h"
             line="230">A program for proccessing vertices</doc>
      </member>
      <member name="fragment"
              value="1"
              c:identifier="COGL_SHADER_TYPE_FRAGMENT">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-shader.h"
             line="231">A program for processing fragments</doc>
      </member>
    </enumeration>
    <enumeration name="StereoMode" c:type="CoglStereoMode">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-types.h"
           line="847">Represents how draw should affect the two buffers
of a stereo framebuffer. See cogl_framebuffer_set_stereo_mode().</doc>
      <source-position filename="../cogl/cogl/cogl-types.h" line="861"/>
      <member name="both" value="0" c:identifier="COGL_STEREO_BOTH">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="849">draw to both stereo buffers</doc>
      </member>
      <member name="left" value="1" c:identifier="COGL_STEREO_LEFT">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="850">draw only to the left stereo buffer</doc>
      </member>
      <member name="right" value="2" c:identifier="COGL_STEREO_RIGHT">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="851">draw only to the left stereo buffer</doc>
      </member>
    </enumeration>
    <callback name="SwapBuffersNotify" c:type="CoglSwapBuffersNotify">
      <source-position filename="../cogl/cogl/cogl-onscreen.h" line="521"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="framebuffer" transfer-ownership="none">
          <type name="Framebuffer" c:type="CoglFramebuffer*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="SystemError"
                 version="1.4"
                 stability="Unstable"
                 c:type="CoglSystemError">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-types.h"
           line="548">Error enumeration for Cogl

The @COGL_SYSTEM_ERROR_UNSUPPORTED error can be thrown for a
variety of reasons. For example:

&lt;itemizedlist&gt;
 &lt;listitem&gt;&lt;para&gt;You've tried to use a feature that is not
  advertised by cogl_has_feature(). This could happen if you create
  a 2d texture with a non-power-of-two size when
  %COGL_FEATURE_ID_TEXTURE_NPOT is not advertised.&lt;/para&gt;&lt;/listitem&gt;
 &lt;listitem&gt;&lt;para&gt;The GPU can not handle the configuration you have
  requested. An example might be if you try to use too many texture
  layers in a single #CoglPipeline&lt;/para&gt;&lt;/listitem&gt;
 &lt;listitem&gt;&lt;para&gt;The driver does not support some
  configuration.&lt;/para&gt;&lt;/listiem&gt;
&lt;/itemizedlist&gt;

Currently this is only used by Cogl API marked as experimental so
this enum should also be considered experimental.</doc>
      <source-position filename="../cogl/cogl/cogl-types.h" line="582"/>
      <member name="unsupported"
              value="0"
              c:identifier="COGL_SYSTEM_ERROR_UNSUPPORTED">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="550">You tried to use a feature or
   configuration not currently available.</doc>
      </member>
      <member name="no_memory"
              value="1"
              c:identifier="COGL_SYSTEM_ERROR_NO_MEMORY">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="552">You tried to allocate a resource
   such as a texture and there wasn't enough memory.</doc>
      </member>
    </enumeration>
    <constant name="TEXTURE_MAX_WASTE"
              value="127"
              c:type="COGL_TEXTURE_MAX_WASTE">
      <source-position filename="../cogl/cogl/cogl-texture.h" line="71"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <interface name="Texture"
               c:symbol-prefix="texture"
               c:type="CoglTexture"
               glib:type-name="CoglTexture"
               glib:get-type="cogl_texture_get_gtype">
      <prerequisite name="Object"/>
      <function name="error_quark" c:identifier="cogl_texture_error_quark">
        <source-position filename="../cogl/cogl/cogl-texture.h" line="129"/>
        <return-value transfer-ownership="none">
          <type name="guint32" c:type="uint32_t"/>
        </return-value>
      </function>
      <function name="new_from_bitmap"
                c:identifier="cogl_texture_new_from_bitmap"
                version="1.0"
                deprecated="1"
                deprecated-version="1.18">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
             line="166">Creates a #CoglTexture from a #CoglBitmap.</doc>
        <doc-deprecated xml:space="preserve">Use specific constructors such as
                  cogl_texture_2d_new_from_bitmap()</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                         line="184"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
               line="175">A newly created #CoglTexture or
              %NULL on failure</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </return-value>
        <parameters>
          <parameter name="bitmap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                 line="168">A #CoglBitmap pointer</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                 line="169">Optional flags for the texture, or %COGL_TEXTURE_NONE</doc>
            <type name="TextureFlags" c:type="CoglTextureFlags"/>
          </parameter>
          <parameter name="internal_format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                 line="170">the #CoglPixelFormat to use for the GPU storage of the
texture</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_from_data"
                c:identifier="cogl_texture_new_from_data"
                version="0.8"
                deprecated="1"
                deprecated-version="1.18">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
             line="91">Creates a new #CoglTexture based on data residing in memory.</doc>
        <doc-deprecated xml:space="preserve">Use specific constructors such as
                  cogl_texture_2d_new_from_data()</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                         line="120"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
               line="111">A newly created #CoglTexture or
              %NULL on failure</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </return-value>
        <parameters>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                 line="93">width of texture in pixels</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                 line="94">height of texture in pixels</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                 line="95">Optional flags for the texture, or %COGL_TEXTURE_NONE</doc>
            <type name="TextureFlags" c:type="CoglTextureFlags"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                 line="96">the #CoglPixelFormat the buffer is stored in in RAM</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="internal_format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                 line="97">the #CoglPixelFormat that will be used for storing
   the buffer on the GPU. If COGL_PIXEL_FORMAT_ANY is given then a
   premultiplied format similar to the format of the source data will
   be used. The default blending equations of Cogl expect premultiplied
   color data; the main use of passing a non-premultiplied format here
   is if you have non-premultiplied source data and are going to adjust
   the blend mode (see cogl_material_set_blend()) or use the data for
   something other than straight blending.</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                 line="105">the memory offset in bytes between the starts of
   scanlines in @data</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                 line="107">pointer the memory region where the source buffer resides</doc>
            <type name="guint8" c:type="const uint8_t*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_from_file"
                c:identifier="cogl_texture_new_from_file"
                version="0.8"
                deprecated="1"
                deprecated-version="1.18"
                throws="1">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
             line="61">Creates a #CoglTexture from an image file.</doc>
        <doc-deprecated xml:space="preserve">Use specific constructors such as
                  cogl_texture_2d_new_from_file()</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                         line="86"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
               line="77">A newly created #CoglTexture or
              %NULL on failure</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                 line="63">the file to load</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                 line="64">Optional flags for the texture, or %COGL_TEXTURE_NONE</doc>
            <type name="TextureFlags" c:type="CoglTextureFlags"/>
          </parameter>
          <parameter name="internal_format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                 line="65">the #CoglPixelFormat to use for the GPU storage of the
   texture. If %COGL_PIXEL_FORMAT_ANY is given then a premultiplied
   format similar to the format of the source data will be used. The
   default blending equations of Cogl expect premultiplied color data;
   the main use of passing a non-premultiplied format here is if you
   have non-premultiplied source data and are going to adjust the blend
   mode (see cogl_material_set_blend()) or use the data for something
   other than straight blending.</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_from_foreign"
                c:identifier="cogl_texture_new_from_foreign"
                version="0.8"
                deprecated="1"
                deprecated-version="1.18">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
             line="128">Creates a #CoglTexture based on an existing OpenGL texture; the
width, height and format are passed along since it is not always
possible to query these from OpenGL.

The waste arguments allow you to create a Cogl texture that maps to
a region smaller than the real OpenGL texture. For instance if your
hardware only supports power-of-two textures you may load a
non-power-of-two image into a larger power-of-two texture and use
the waste arguments to tell Cogl which region should be mapped to
the texture coordinate range [0:1].</doc>
        <doc-deprecated xml:space="preserve">Use specific constructors such as
                  cogl_texture_2d_new_from_foreign()</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                         line="158"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
               line="149">A newly created #CoglTexture or
              %NULL on failure</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </return-value>
        <parameters>
          <parameter name="gl_handle" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                 line="130">opengl handle of foreign texture.</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="gl_target" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                 line="131">opengl target type of foreign texture</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                 line="132">width of foreign texture</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                 line="133">height of foreign texture.</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="x_pot_waste" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                 line="134">horizontal waste on the right hand edge of the texture.</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="y_pot_waste" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                 line="135">vertical waste on the bottom edge of the texture.</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                 line="136">format of the foreign texture.</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_with_size"
                c:identifier="cogl_texture_new_with_size"
                version="0.8"
                deprecated="1"
                deprecated-version="1.18">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
             line="38">Creates a new #CoglTexture with the specified dimensions and pixel format.</doc>
        <doc-deprecated xml:space="preserve">Use specific constructors such as
                  cogl_texture_2d_new_with_size()</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                         line="56"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
               line="48">A newly created #CoglTexture or %NULL on failure</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </return-value>
        <parameters>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                 line="40">width of texture in pixels.</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                 line="41">height of texture in pixels.</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                 line="42">Optional flags for the texture, or %COGL_TEXTURE_NONE</doc>
            <type name="TextureFlags" c:type="CoglTextureFlags"/>
          </parameter>
          <parameter name="internal_format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                 line="43">the #CoglPixelFormat to use for the GPU storage of the
   texture.</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
        </parameters>
      </function>
      <method name="allocate" c:identifier="cogl_texture_allocate" throws="1">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-texture.h"
             line="494">Explicitly allocates the storage for the given @texture which
allows you to be sure that there is enough memory for the
texture and if not then the error can be handled gracefully.

&lt;note&gt;Normally applications don't need to use this api directly
since the texture will be implicitly allocated when data is set on
the texture, or if the texture is attached to a #CoglOffscreen
framebuffer and rendered too.&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/cogl-texture.h" line="513"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-texture.h"
               line="508">%TRUE if the texture was successfully allocated,
              otherwise %FALSE and @error will be updated if it
              wasn't %NULL.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="496">A #CoglTexture</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_components"
              c:identifier="cogl_texture_get_components"
              version="1.18">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-texture.h"
             line="196">Queries what components the given @texture stores internally as set
via cogl_texture_set_components().

For textures created by the _with_size constructors the default
is %COGL_TEXTURE_COMPONENTS_RGBA. The other constructors which take
a %CoglBitmap or a data pointer default to the same components as
the pixel format of the data.</doc>
        <source-position filename="../cogl/cogl/cogl-texture.h" line="211"/>
        <return-value transfer-ownership="none">
          <type name="TextureComponents" c:type="CoglTextureComponents"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="198">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_data" c:identifier="cogl_texture_get_data">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-texture.h"
             line="334">Copies the pixel data from a cogl texture to system memory.

&lt;note&gt;Don't pass the value of cogl_texture_get_rowstride() as the
@rowstride argument, the rowstride should be the rowstride you
want for the destination @data buffer not the rowstride of the
source texture&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/cogl-texture.h" line="354"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-texture.h"
               line="351">the size of the texture data in bytes</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="336">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="337">the #CoglPixelFormat to store the texture as.</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="338">the rowstride of @data in bytes or pass 0 to calculate
            from the bytes-per-pixel of @format multiplied by the
            @texture width.</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="341">memory location to write the @texture's contents, or %NULL
to only query the data size through the return value.</doc>
            <type name="guint8" c:type="uint8_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_gl_texture" c:identifier="cogl_texture_get_gl_texture">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-texture.h"
             line="313">Queries the GL handles for a GPU side texture through its #CoglTexture.

If the texture is spliced the data for the first sub texture will be
queried.</doc>
        <source-position filename="../cogl/cogl/cogl-texture.h" line="330"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-texture.h"
               line="326">%TRUE if the handle was successfully retrieved, %FALSE
  if the handle was invalid</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="315">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
          <parameter name="out_gl_handle"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="316">pointer to return location for the
  textures GL handle, or %NULL.</doc>
            <type name="guint" c:type="unsigned int*"/>
          </parameter>
          <parameter name="out_gl_target"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="318">pointer to return location for the
  GL target type, or %NULL.</doc>
            <type name="guint" c:type="unsigned int*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_height" c:identifier="cogl_texture_get_height">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-texture.h"
             line="277">Queries the height of a cogl texture.</doc>
        <source-position filename="../cogl/cogl/cogl-texture.h" line="286"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-texture.h"
               line="283">the height of the GPU side texture in pixels</doc>
          <type name="guint" c:type="unsigned int"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="279">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_max_waste" c:identifier="cogl_texture_get_max_waste">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-texture.h"
             line="288">Queries the maximum wasted (unused) pixels in one dimension of a GPU side
texture.</doc>
        <source-position filename="../cogl/cogl/cogl-texture.h" line="298"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-texture.h"
               line="295">the maximum waste</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="290">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_premultiplied"
              c:identifier="cogl_texture_get_premultiplied"
              version="1.18">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-texture.h"
             line="248">Queries the pre-multiplied alpha status for internally stored red,
green and blue components for the given @texture as set by
cogl_texture_set_premultiplied().

By default the pre-multipled state is @TRUE.</doc>
        <source-position filename="../cogl/cogl/cogl-texture.h" line="264"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-texture.h"
               line="258">%TRUE if red, green and blue components are
              internally stored pre-multiplied by the alpha
              value or %FALSE if not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="250">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_width" c:identifier="cogl_texture_get_width">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-texture.h"
             line="266">Queries the width of a cogl texture.</doc>
        <source-position filename="../cogl/cogl/cogl-texture.h" line="275"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-texture.h"
               line="272">the width of the GPU side texture in pixels</doc>
          <type name="guint" c:type="unsigned int"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="268">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_get_data_supported"
              c:identifier="cogl_texture_is_get_data_supported"
              introspectable="0">
        <source-position filename="../cogl/cogl/cogl-texture.h" line="520"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_sliced" c:identifier="cogl_texture_is_sliced">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-texture.h"
             line="300">Queries if a texture is sliced (stored as multiple GPU side tecture
objects).</doc>
        <source-position filename="../cogl/cogl/cogl-texture.h" line="311"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-texture.h"
               line="307">%TRUE if the texture is sliced, %FALSE if the texture
  is stored as a single GPU texture</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="302">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="new_from_sub_texture"
              c:identifier="cogl_texture_new_from_sub_texture"
              version="1.2"
              deprecated="1"
              deprecated-version="1.18">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
             line="188">Creates a new texture which represents a subregion of another
texture. The GL resources will be shared so that no new texture
data is actually allocated.

Sub textures have undefined behaviour texture coordinates outside
of the range [0,1] are used. They also do not work with
CoglVertexBuffers.

The sub texture will keep a reference to the full texture so you do
not need to keep one separately if you only want to use the sub
texture.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_sub_texture_new()</doc-deprecated>
        <source-position filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                         line="215"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
               line="208">A newly created #CoglTexture or
              %NULL on failure</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </return-value>
        <parameters>
          <instance-parameter name="full_texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                 line="190">a #CoglTexture pointer</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
          <parameter name="sub_x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                 line="191">X coordinate of the top-left of the subregion</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="sub_y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                 line="192">Y coordinate of the top-left of the subregion</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="sub_width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                 line="193">Width in pixels of the subregion</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="sub_height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                 line="194">Height in pixels of the subregion</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_components"
              c:identifier="cogl_texture_set_components"
              version="1.18">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-texture.h"
             line="166">Affects the internal storage format for this texture by specifying
what components will be required for sampling later.

This api affects how data is uploaded to the GPU since unused
components can potentially be discarded from source data.

For textures created by the _with_size constructors the default
is %COGL_TEXTURE_COMPONENTS_RGBA. The other constructors which take
a %CoglBitmap or a data pointer default to the same components as
the pixel format of the data.

Note that the %COGL_TEXTURE_COMPONENTS_RG format is not available
on all drivers. The availability can be determined by checking for
the %COGL_FEATURE_ID_TEXTURE_RG feature. If this format is used on
a driver where it is not available then %COGL_TEXTURE_ERROR_FORMAT
will be raised when the texture is allocated. Even if the feature
is not available then %COGL_PIXEL_FORMAT_RG_88 can still be used as
an image format as long as %COGL_TEXTURE_COMPONENTS_RG isn't used
as the texture's components.</doc>
        <source-position filename="../cogl/cogl/cogl-texture.h" line="193"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="168">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
          <parameter name="components" transfer-ownership="none">
            <type name="TextureComponents" c:type="CoglTextureComponents"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_data" c:identifier="cogl_texture_set_data" throws="1">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-texture.h"
             line="399">@texture a #CoglTexture.
Sets all the pixels for a given mipmap @level by copying the pixel
data pointed to by the @data argument into the given @texture.

@data should point to the first pixel to copy corresponding
to the top left of the mipmap @level being set.

If @rowstride equals 0 then it will be automatically calculated
from the width of the mipmap level and the bytes-per-pixel for the
given @format.

A mipmap @level of 0 corresponds to the largest, base image of a
texture and @level 1 is half the width and height of level 0. If
dividing any dimension of the previous level by two results in a
fraction then round the number down (floor()), but clamp to 1
something like this:

|[
 next_width = MAX (1, floor (prev_width));
]|

You can determine the number of mipmap levels for a given texture
like this:

|[
 n_levels = 1 + floor (log2 (max_dimension));
]|

Where %max_dimension is the larger of cogl_texture_get_width() and
cogl_texture_get_height().

It is an error to pass a @level number &gt;= the number of levels that
@texture can have according to the above calculation.

&lt;note&gt;Since the storage for a #CoglTexture is allocated lazily then
if the given @texture has not previously been allocated then this
api can return %FALSE and throw an exceptional @error if there is
not enough memory to allocate storage for @texture.&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/cogl-texture.h" line="452"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-texture.h"
               line="448">%TRUE if the data upload was successful, and
              %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="402">the #CoglPixelFormat used in the source @data buffer.</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="403">rowstride of the source @data buffer (computed from
            the texture width and @format if it equals 0)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="405">the source data, pointing to the first top-left pixel to set</doc>
            <type name="guint8" c:type="const uint8_t*"/>
          </parameter>
          <parameter name="level" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="406">The mipmap level to update (Normally 0 for the largest,
        base texture)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_premultiplied"
              c:identifier="cogl_texture_set_premultiplied"
              version="1.18">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-texture.h"
             line="213">Affects the internal storage format for this texture by specifying
whether red, green and blue color components should be stored as
pre-multiplied alpha values.

This api affects how data is uploaded to the GPU since Cogl will
convert source data to have premultiplied or unpremultiplied
components according to this state.

For example if you create a texture via
cogl_texture_2d_new_with_size() and then upload data via
cogl_texture_set_data() passing a source format of
%COGL_PIXEL_FORMAT_RGBA_8888 then Cogl will internally multiply the
red, green and blue components of the source data by the alpha
component, for each pixel so that the internally stored data has
pre-multiplied alpha components. If you instead upload data that
already has pre-multiplied components by passing
%COGL_PIXEL_FORMAT_RGBA_8888_PRE as the source format to
cogl_texture_set_data() then the data can be uploaded without being
converted.

By default the @premultipled state is @TRUE.</doc>
        <source-position filename="../cogl/cogl/cogl-texture.h" line="245"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="215">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
          <parameter name="premultiplied" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="216">Whether any internally stored red, green or blue
                components are pre-multiplied by an alpha
                component.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_region" c:identifier="cogl_texture_set_region">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-texture.h"
             line="359">Sets the pixels in a rectangular subregion of @texture from an in-memory
buffer containing pixel data.

&lt;note&gt;The region set can't be larger than the source @data&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/cogl-texture.h" line="386"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-texture.h"
               line="382">%TRUE if the subregion upload was successful, and
  %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="361">a #CoglTexture.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
          <parameter name="src_x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="362">upper left coordinate to use from source data.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="src_y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="363">upper left coordinate to use from source data.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dst_x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="364">upper left destination horizontal coordinate.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dst_y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="365">upper left destination vertical coordinate.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dst_width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="366">width of destination region to write. (Must be less
  than or equal to @width)</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="dst_height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="368">height of destination region to write. (Must be less
  than or equal to @height)</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="370">width of source data buffer.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="371">height of source data buffer.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="372">the #CoglPixelFormat used in the source buffer.</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="373">rowstride of source buffer (computed from width if none
specified)</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="375">the actual pixel data.</doc>
            <type name="guint8" c:type="const uint8_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_region_from_bitmap"
              c:identifier="cogl_texture_set_region_from_bitmap"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-texture.h"
             line="459">Copies a specified source region from @bitmap to the position
(@src_x, @src_y) of the given destination texture @handle.

&lt;note&gt;The region updated can't be larger than the source
bitmap&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/cogl-texture.h" line="485"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-texture.h"
               line="478">%TRUE if the subregion upload was successful, and
  %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="461">a #CoglTexture pointer</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
          <parameter name="src_x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="462">upper left coordinate to use from the source bitmap.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="src_y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="463">upper left coordinate to use from the source bitmap</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dst_x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="464">upper left destination horizontal coordinate.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dst_y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="465">upper left destination vertical coordinate.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dst_width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="466">width of destination region to write. (Must be less
  than or equal to the bitmap width)</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="dst_height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="468">height of destination region to write. (Must be less
  than or equal to the bitmap height)</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="bitmap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture.h"
                 line="470">The source bitmap to read from</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <class name="Texture2D"
           c:symbol-prefix="texture_2d"
           c:type="CoglTexture2D"
           parent="Object"
           glib:type-name="CoglTexture2D"
           glib:get-type="cogl_texture_2d_get_gtype"
           glib:fundamental="1">
      <implements name="Texture"/>
      <constructor name="new_from_bitmap"
                   c:identifier="cogl_texture_2d_new_from_bitmap"
                   version="2.0"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-texture-2d.h"
             line="203">Creates a low-level #CoglTexture2D texture based on data residing
in a #CoglBitmap.

The storage for the texture is not allocated before this function
returns. You can call cogl_texture_allocate() to explicitly
allocate the underlying storage or preferably let Cogl
automatically allocate storage lazily when it may know more about
how the texture is being used and can optimize how it is allocated.

The texture is still configurable until it has been allocated so
for example you can influence the internal format of the texture
using cogl_texture_set_components() and
cogl_texture_set_premultiplied().

&lt;note&gt;Many GPUs only support power of two sizes for #CoglTexture2D
textures. You can check support for non power of two textures by
checking for the %COGL_FEATURE_ID_TEXTURE_NPOT feature via
cogl_has_feature().&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/cogl-texture-2d.h" line="232"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-texture-2d.h"
               line="226">A newly allocated #CoglTexture2D</doc>
          <type name="Texture2D" c:type="CoglTexture2D*"/>
        </return-value>
        <parameters>
          <parameter name="bitmap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture-2d.h"
                 line="205">A #CoglBitmap</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_data"
                   c:identifier="cogl_texture_2d_new_from_data"
                   version="2.0"
                   introspectable="0"
                   throws="1">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-texture-2d.h"
             line="156">Creates a low-level #CoglTexture2D texture based on data residing
in memory.

&lt;note&gt;This api will always immediately allocate GPU memory for the
texture and upload the given data so that the @data pointer does
not need to remain valid once this function returns. This means it
is not possible to configure the texture before it is allocated. If
you do need to configure the texture before allocation (to specify
constraints on the internal format for example) then you can
instead create a #CoglBitmap for your data and use
cogl_texture_2d_new_from_bitmap() or use
cogl_texture_2d_new_with_size() and then upload data using
cogl_texture_set_data()&lt;/note&gt;

&lt;note&gt;Many GPUs only support power of two sizes for #CoglTexture2D
textures. You can check support for non power of two textures by
checking for the %COGL_FEATURE_ID_TEXTURE_NPOT feature via
cogl_has_feature().&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/cogl-texture-2d.h" line="195"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-texture-2d.h"
               line="187">A newly allocated #CoglTexture2D, or if
         the size is not supported (because it is too large or a
         non-power-of-two size that the hardware doesn't support)
         it will return %NULL and set @error.</doc>
          <type name="Texture2D" c:type="CoglTexture2D*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture-2d.h"
                 line="158">A #CoglContext</doc>
            <type c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture-2d.h"
                 line="159">width of texture in pixels</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture-2d.h"
                 line="160">height of texture in pixels</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture-2d.h"
                 line="161">the #CoglPixelFormat the buffer is stored in in RAM</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture-2d.h"
                 line="162">the memory offset in bytes between the starts of
   scanlines in @data. A value of 0 will make Cogl automatically
   calculate @rowstride from @width and @format.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture-2d.h"
                 line="165">pointer the memory region where the source buffer resides</doc>
            <type name="guint8" c:type="const uint8_t*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_egl_image_external"
                   c:identifier="cogl_texture_2d_new_from_egl_image_external"
                   introspectable="0"
                   throws="1">
        <source-position filename="../cogl/cogl/cogl-texture-2d.h" line="257"/>
        <return-value transfer-ownership="full">
          <type name="Texture2D" c:type="CoglTexture2D*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <type c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="alloc"
                     transfer-ownership="none"
                     scope="notified"
                     closure="4"
                     destroy="5">
            <type name="Texture2DEGLImageExternalAlloc"
                  c:type="CoglTexture2DEGLImageExternalAlloc"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_file"
                   c:identifier="cogl_texture_2d_new_from_file"
                   version="1.16"
                   introspectable="0"
                   throws="1">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-texture-2d.h"
             line="122">Creates a low-level #CoglTexture2D texture from an image file.

The storage for the texture is not allocated before this function
returns. You can call cogl_texture_allocate() to explicitly
allocate the underlying storage or preferably let Cogl
automatically allocate storage lazily when it may know more about
how the texture is being used and can optimize how it is allocated.

The texture is still configurable until it has been allocated so
for example you can influence the internal format of the texture
using cogl_texture_set_components() and
cogl_texture_set_premultiplied().

&lt;note&gt;Many GPUs only support power of two sizes for #CoglTexture2D
textures. You can check support for non power of two textures by
checking for the %COGL_FEATURE_ID_TEXTURE_NPOT feature via
cogl_has_feature().&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/cogl-texture-2d.h" line="152"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-texture-2d.h"
               line="146">A newly created #CoglTexture2D or %NULL on failure
              and @error will be updated.</doc>
          <type name="Texture2D" c:type="CoglTexture2D*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture-2d.h"
                 line="124">A #CoglContext</doc>
            <type c:type="CoglContext*"/>
          </parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture-2d.h"
                 line="125">the file to load</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_size"
                   c:identifier="cogl_texture_2d_new_with_size"
                   version="2.0"
                   introspectable="0">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-texture-2d.h"
             line="88">Creates a low-level #CoglTexture2D texture with a given @width and
@height that your GPU can texture from directly.

The storage for the texture is not allocated before this function
returns. You can call cogl_texture_allocate() to explicitly
allocate the underlying storage or preferably let Cogl
automatically allocate storage lazily when it may know more about
how the texture is being used and can optimize how it is allocated.

The texture is still configurable until it has been allocated so
for example you can influence the internal format of the texture
using cogl_texture_set_components() and
cogl_texture_set_premultiplied().

&lt;note&gt;Many GPUs only support power of two sizes for #CoglTexture2D
textures. You can check support for non power of two textures by
checking for the %COGL_FEATURE_ID_TEXTURE_NPOT feature via
cogl_has_feature().&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/cogl-texture-2d.h" line="118"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-texture-2d.h"
               line="113">A new #CoglTexture2D object with no storage yet allocated.</doc>
          <type name="Texture2D" c:type="CoglTexture2D*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture-2d.h"
                 line="90">A #CoglContext</doc>
            <type c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture-2d.h"
                 line="91">Width of the texture to allocate</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture-2d.h"
                 line="92">Height of the texture to allocate</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="egl_image_external_alloc_finish"
              c:identifier="cogl_texture_2d_egl_image_external_alloc_finish">
        <source-position filename="../cogl/cogl/cogl-texture-2d.h" line="269"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="tex_2d" transfer-ownership="none">
            <type name="Texture2D" c:type="CoglTexture2D*"/>
          </instance-parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="egl_image_external_bind"
              c:identifier="cogl_texture_2d_egl_image_external_bind">
        <source-position filename="../cogl/cogl/cogl-texture-2d.h" line="266"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="tex_2d" transfer-ownership="none">
            <type name="Texture2D" c:type="CoglTexture2D*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <callback name="Texture2DEGLImageExternalAlloc"
              c:type="CoglTexture2DEGLImageExternalAlloc"
              throws="1">
      <source-position filename="../cogl/cogl/cogl-texture-2d.h" line="249"/>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="tex_2d" transfer-ownership="none">
          <type name="Texture2D" c:type="CoglTexture2D*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="1">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="Texture2DSliced"
           c:symbol-prefix="texture_2d_sliced"
           c:type="CoglTexture2DSliced"
           parent="Object"
           glib:type-name="CoglTexture2DSliced"
           glib:get-type="cogl_texture_2d_sliced_get_gtype"
           glib:fundamental="1">
      <implements name="Texture"/>
      <constructor name="new_from_bitmap"
                   c:identifier="cogl_texture_2d_sliced_new_from_bitmap"
                   version="1.16">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-texture-2d-sliced.h"
             line="240">Creates a new #CoglTexture2DSliced texture based on data residing
in a bitmap.

A #CoglTexture2DSliced may internally be comprised of 1 or more
#CoglTexture2D textures depending on GPU limitations.  For example
if the GPU only supports power-of-two sized textures then a sliced
texture will turn a non-power-of-two size into a combination of
smaller power-of-two sized textures. If the requested texture size
is larger than is supported by the hardware then the texture will
be sliced into smaller textures that can be accessed by the
hardware.

@max_waste is used as a threshold for recursively slicing the
right-most or bottom-most slices into smaller sizes until the
wasted padding at the bottom and right of the textures is less than
specified. A negative @max_waste will disable slicing.

The storage for the texture is not allocated before this function
returns. You can call cogl_texture_allocate() to explicitly
allocate the underlying storage or let Cogl automatically allocate
storage lazily.

&lt;note&gt;It's possible for the allocation of a sliced texture to fail
later due to impossible slicing constraints if a negative
@max_waste value is given. If the given virtual texture size is
larger than is supported by the hardware but slicing is disabled
the texture size would be too large to handle.&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/cogl-texture-2d-sliced.h"
                         line="282"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-texture-2d-sliced.h"
               line="276">A newly created #CoglTexture2DSliced
              or %NULL on failure and @error will be updated.</doc>
          <type name="Texture2DSliced" c:type="CoglTexture2DSliced*"/>
        </return-value>
        <parameters>
          <parameter name="bmp" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture-2d-sliced.h"
                 line="242">A #CoglBitmap</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </parameter>
          <parameter name="max_waste" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture-2d-sliced.h"
                 line="243">The threshold of how wide a strip of wasted texels
            are allowed along the right and bottom textures before
            they must be sliced to reduce the amount of waste. A
            negative can be passed to disable slicing.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_data"
                   c:identifier="cogl_texture_2d_sliced_new_from_data"
                   version="1.16"
                   introspectable="0"
                   throws="1">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-texture-2d-sliced.h"
             line="175">Creates a new #CoglTexture2DSliced texture based on data residing
in memory.

A #CoglTexture2DSliced may internally be comprised of 1 or more
#CoglTexture2D textures depending on GPU limitations.  For example
if the GPU only supports power-of-two sized textures then a sliced
texture will turn a non-power-of-two size into a combination of
smaller power-of-two sized textures. If the requested texture size
is larger than is supported by the hardware then the texture will
be sliced into smaller textures that can be accessed by the
hardware.

@max_waste is used as a threshold for recursively slicing the
right-most or bottom-most slices into smaller sizes until the
wasted padding at the bottom and right of the textures is less than
specified. A negative @max_waste will disable slicing.

&lt;note&gt;This api will always immediately allocate GPU memory for all
the required texture slices and upload the given data so that the
@data pointer does not need to remain valid once this function
returns. This means it is not possible to configure the texture
before it is allocated. If you do need to configure the texture
before allocation (to specify constraints on the internal format
for example) then you can instead create a #CoglBitmap for your
data and use cogl_texture_2d_sliced_new_from_bitmap() or use
cogl_texture_2d_sliced_new_with_size() and then upload data using
cogl_texture_set_data()&lt;/note&gt;

&lt;note&gt;It's possible for the allocation of a sliced texture to fail
due to impossible slicing constraints if a negative @max_waste
value is given. If the given virtual texture size is larger than is
supported by the hardware but slicing is disabled the texture size
would be too large to handle.&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/cogl-texture-2d-sliced.h"
                         line="231"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-texture-2d-sliced.h"
               line="225">A newly created #CoglTexture2DSliced
              or %NULL on failure and @error will be updated.</doc>
          <type name="Texture2DSliced" c:type="CoglTexture2DSliced*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture-2d-sliced.h"
                 line="177">A #CoglContext</doc>
            <type c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture-2d-sliced.h"
                 line="178">width of texture in pixels</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture-2d-sliced.h"
                 line="179">height of texture in pixels</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="max_waste" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture-2d-sliced.h"
                 line="181">The threshold of how wide a strip of wasted texels
            are allowed along the right and bottom textures before
            they must be sliced to reduce the amount of waste. A
            negative can be passed to disable slicing.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture-2d-sliced.h"
                 line="180">the #CoglPixelFormat the buffer is stored in in RAM</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture-2d-sliced.h"
                 line="185">the memory offset in bytes between the start of each
   row in @data. A value of 0 will make Cogl automatically
   calculate @rowstride from @width and @format.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture-2d-sliced.h"
                 line="188">pointer the memory region where the source buffer resides</doc>
            <type name="guint8" c:type="const uint8_t*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_file"
                   c:identifier="cogl_texture_2d_sliced_new_from_file"
                   version="1.16"
                   introspectable="0"
                   throws="1">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-texture-2d-sliced.h"
             line="127">Creates a #CoglTexture2DSliced from an image file.

A #CoglTexture2DSliced may internally be comprised of 1 or more
#CoglTexture2D textures depending on GPU limitations.  For example
if the GPU only supports power-of-two sized textures then a sliced
texture will turn a non-power-of-two size into a combination of
smaller power-of-two sized textures. If the requested texture size
is larger than is supported by the hardware then the texture will
be sliced into smaller textures that can be accessed by the
hardware.

@max_waste is used as a threshold for recursively slicing the
right-most or bottom-most slices into smaller sizes until the
wasted padding at the bottom and right of the textures is less than
specified. A negative @max_waste will disable slicing.

The storage for the texture is not allocated before this function
returns. You can call cogl_texture_allocate() to explicitly
allocate the underlying storage or let Cogl automatically allocate
storage lazily.

&lt;note&gt;It's possible for the allocation of a sliced texture to fail
later due to impossible slicing constraints if a negative
@max_waste value is given. If the given virtual texture size is
larger than is supported by the hardware but slicing is disabled
the texture size would be too large to handle.&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/cogl-texture-2d-sliced.h"
                         line="170"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-texture-2d-sliced.h"
               line="164">A newly created #CoglTexture2DSliced
              or %NULL on failure and @error will be updated.</doc>
          <type name="Texture2DSliced" c:type="CoglTexture2DSliced*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture-2d-sliced.h"
                 line="129">A #CoglContext</doc>
            <type c:type="CoglContext*"/>
          </parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture-2d-sliced.h"
                 line="130">the file to load</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="max_waste" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture-2d-sliced.h"
                 line="131">The threshold of how wide a strip of wasted texels
            are allowed along the right and bottom textures before
            they must be sliced to reduce the amount of waste. A
            negative can be passed to disable slicing.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_size"
                   c:identifier="cogl_texture_2d_sliced_new_with_size"
                   version="1.10"
                   introspectable="0"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-texture-2d-sliced.h"
             line="80">Creates a #CoglTexture2DSliced that may internally be comprised of
1 or more #CoglTexture2D textures depending on GPU limitations.
For example if the GPU only supports power-of-two sized textures
then a sliced texture will turn a non-power-of-two size into a
combination of smaller power-of-two sized textures. If the
requested texture size is larger than is supported by the hardware
then the texture will be sliced into smaller textures that can be
accessed by the hardware.

@max_waste is used as a threshold for recursively slicing the
right-most or bottom-most slices into smaller sizes until the
wasted padding at the bottom and right of the textures is less than
specified. A negative @max_waste will disable slicing.

The storage for the texture is not allocated before this function
returns. You can call cogl_texture_allocate() to explicitly
allocate the underlying storage or let Cogl automatically allocate
storage lazily.

&lt;note&gt;It's possible for the allocation of a sliced texture to fail
later due to impossible slicing constraints if a negative
@max_waste value is given. If the given virtual texture size size
is larger than is supported by the hardware but slicing is disabled
the texture size would be too large to handle.&lt;/note&gt;</doc>
        <source-position filename="../cogl/cogl/cogl-texture-2d-sliced.h"
                         line="122"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-texture-2d-sliced.h"
               line="115">A new #CoglTexture2DSliced object with no storage
         allocated yet.</doc>
          <type name="Texture2DSliced" c:type="CoglTexture2DSliced*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture-2d-sliced.h"
                 line="82">A #CoglContext</doc>
            <type c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture-2d-sliced.h"
                 line="83">The virtual width of your sliced texture.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture-2d-sliced.h"
                 line="84">The virtual height of your sliced texture.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="max_waste" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="../cogl/cogl/cogl-texture-2d-sliced.h"
                 line="85">The threshold of how wide a strip of wasted texels
            are allowed along the right and bottom textures before
            they must be sliced to reduce the amount of waste. A
            negative can be passed to disable slicing.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
    </class>
    <enumeration name="TextureComponents"
                 version="1.18"
                 c:type="CoglTextureComponents">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-texture.h"
           line="143">See cogl_texture_set_components().</doc>
      <source-position filename="../cogl/cogl/cogl-texture.h" line="164"/>
      <member name="a" value="1" c:identifier="COGL_TEXTURE_COMPONENTS_A">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-texture.h"
             line="145">Only the alpha component</doc>
      </member>
      <member name="rg" value="2" c:identifier="COGL_TEXTURE_COMPONENTS_RG">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-texture.h"
             line="146">Red and green components. Note that
  this can only be used if the %COGL_FEATURE_ID_TEXTURE_RG feature
  is advertised.</doc>
      </member>
      <member name="rgb" value="3" c:identifier="COGL_TEXTURE_COMPONENTS_RGB">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-texture.h"
             line="149">Red, green and blue components</doc>
      </member>
      <member name="rgba"
              value="4"
              c:identifier="COGL_TEXTURE_COMPONENTS_RGBA">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-texture.h"
             line="150">Red, green, blue and alpha components</doc>
      </member>
      <member name="depth"
              value="5"
              c:identifier="COGL_TEXTURE_COMPONENTS_DEPTH">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-texture.h"
             line="151">Only a depth component</doc>
      </member>
    </enumeration>
    <enumeration name="TextureError"
                 version="1.8"
                 stability="Unstable"
                 c:type="CoglTextureError">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-texture.h"
           line="90">Error codes that can be thrown when allocating textures.</doc>
      <source-position filename="../cogl/cogl/cogl-texture.h" line="108"/>
      <member name="size" value="0" c:identifier="COGL_TEXTURE_ERROR_SIZE">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-texture.h"
             line="92">Unsupported size</doc>
      </member>
      <member name="format" value="1" c:identifier="COGL_TEXTURE_ERROR_FORMAT">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-texture.h"
             line="93">Unsupported format</doc>
      </member>
      <member name="bad_parameter"
              value="2"
              c:identifier="COGL_TEXTURE_ERROR_BAD_PARAMETER">
      </member>
      <member name="type" value="3" c:identifier="COGL_TEXTURE_ERROR_TYPE">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-texture.h"
             line="94">A primitive texture type that is
  unsupported by the driver was used</doc>
      </member>
    </enumeration>
    <bitfield name="TextureFlags" version="1.0" c:type="CoglTextureFlags">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-types.h"
           line="455">Flags to pass to the cogl_texture_new_* family of functions.</doc>
      <source-position filename="../cogl/cogl/cogl-types.h" line="477"/>
      <member name="none" value="0" c:identifier="COGL_TEXTURE_NONE">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="457">No flags specified</doc>
      </member>
      <member name="no_auto_mipmap"
              value="1"
              c:identifier="COGL_TEXTURE_NO_AUTO_MIPMAP">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="458">Disables the automatic generation of
  the mipmap pyramid from the base level image whenever it is
  updated. The mipmaps are only generated when the texture is
  rendered with a mipmap filter so it should be free to leave out
  this flag when using other filtering modes</doc>
      </member>
      <member name="no_slicing"
              value="2"
              c:identifier="COGL_TEXTURE_NO_SLICING">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="463">Disables the slicing of the texture</doc>
      </member>
      <member name="no_atlas" value="4" c:identifier="COGL_TEXTURE_NO_ATLAS">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="464">Disables the insertion of the texture inside
  the texture atlas used by Cogl</doc>
      </member>
    </bitfield>
    <enumeration name="TextureType"
                 version="1.10"
                 stability="Unstable"
                 c:type="CoglTextureType">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-texture.h"
           line="110">Constants representing the underlying hardware texture type of a
#CoglTexture.</doc>
      <source-position filename="../cogl/cogl/cogl-texture.h" line="127"/>
      <member name="2d" value="0" c:identifier="COGL_TEXTURE_TYPE_2D">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-texture.h"
             line="112">A #CoglTexture2D</doc>
      </member>
      <member name="3d" value="1" c:identifier="COGL_TEXTURE_TYPE_3D">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-texture.h"
             line="113">A #CoglTexture3D</doc>
      </member>
      <member name="rectangle"
              value="2"
              c:identifier="COGL_TEXTURE_TYPE_RECTANGLE">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-texture.h"
             line="114">A #CoglTextureRectangle</doc>
      </member>
    </enumeration>
    <record name="TextureVertex" c:type="CoglTextureVertex">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-types.h"
           line="434">Used to specify vertex information when calling cogl_polygon()</doc>
      <source-position filename="../cogl/cogl/cogl-types.h" line="452"/>
      <field name="x" writable="1">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="436">Model x-coordinate</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="y" writable="1">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="437">Model y-coordinate</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="z" writable="1">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="438">Model z-coordinate</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="tx" writable="1">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="439">Texture x-coordinate</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="ty" writable="1">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="440">Texture y-coordinate</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="color" writable="1">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="441">The color to use at this vertex. This is ignored if
  use_color is %FALSE when calling cogl_polygon()</doc>
        <type name="Color" c:type="CoglColor"/>
      </field>
    </record>
    <record name="UserDataKey" c:type="CoglUserDataKey" version="1.4">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-object.h"
           line="92">A #CoglUserDataKey is used to declare a key for attaching data to a
#CoglObject using cogl_object_set_user_data. The typedef only exists as a
formality to make code self documenting since only the unique address of a
#CoglUserDataKey is used.

Typically you would declare a static #CoglUserDataKey and set private data
on an object something like this:

|[
static CoglUserDataKey path_private_key;

static void
destroy_path_private_cb (void *data)
{
  g_free (data);
}

static void
my_path_set_data (CoglPath *path, void *data)
{
  cogl_object_set_user_data (COGL_OBJECT (path),
                             &amp;private_key,
                             data,
                             destroy_path_private_cb);
}
]|</doc>
      <source-position filename="../cogl/cogl/cogl-object.h" line="127"/>
      <field name="unused" writable="1">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-object.h"
             line="94">ignored.</doc>
        <type name="gint" c:type="int"/>
      </field>
    </record>
    <enumeration name="VerticesMode" version="1.0" c:type="CoglVerticesMode">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-types.h"
           line="633">Different ways of interpreting vertices when drawing.</doc>
      <source-position filename="../cogl/cogl/cogl-types.h" line="661"/>
      <member name="points" value="0" c:identifier="COGL_VERTICES_MODE_POINTS">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="635">FIXME, equivalent to
&lt;constant&gt;GL_POINTS&lt;/constant&gt;</doc>
      </member>
      <member name="lines" value="1" c:identifier="COGL_VERTICES_MODE_LINES">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="637">FIXME, equivalent to &lt;constant&gt;GL_LINES&lt;/constant&gt;</doc>
      </member>
      <member name="line_loop"
              value="2"
              c:identifier="COGL_VERTICES_MODE_LINE_LOOP">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="638">FIXME, equivalent to
&lt;constant&gt;GL_LINE_LOOP&lt;/constant&gt;</doc>
      </member>
      <member name="line_strip"
              value="3"
              c:identifier="COGL_VERTICES_MODE_LINE_STRIP">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="640">FIXME, equivalent to
&lt;constant&gt;GL_LINE_STRIP&lt;/constant&gt;</doc>
      </member>
      <member name="triangles"
              value="4"
              c:identifier="COGL_VERTICES_MODE_TRIANGLES">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="642">FIXME, equivalent to
&lt;constant&gt;GL_TRIANGLES&lt;/constant&gt;</doc>
      </member>
      <member name="triangle_strip"
              value="5"
              c:identifier="COGL_VERTICES_MODE_TRIANGLE_STRIP">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="644">FIXME, equivalent to
&lt;constant&gt;GL_TRIANGLE_STRIP&lt;/constant&gt;</doc>
      </member>
      <member name="triangle_fan"
              value="6"
              c:identifier="COGL_VERTICES_MODE_TRIANGLE_FAN">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="646">FIXME, equivalent to &lt;constant&gt;GL_TRIANGLE_FAN&lt;/constant&gt;</doc>
      </member>
    </enumeration>
    <enumeration name="Winding" c:type="CoglWinding">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-types.h"
           line="802">Enum used to represent the two directions of rotation. This can be
used to set the front face for culling by calling
cogl_pipeline_set_front_face_winding().</doc>
      <source-position filename="../cogl/cogl/cogl-types.h" line="815"/>
      <member name="clockwise" value="0" c:identifier="COGL_WINDING_CLOCKWISE">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="804">Vertices are in a clockwise order</doc>
      </member>
      <member name="counter_clockwise"
              value="1"
              c:identifier="COGL_WINDING_COUNTER_CLOCKWISE">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="805">Vertices are in a counter-clockwise order</doc>
      </member>
    </enumeration>
    <enumeration name="WinsysFeature" c:type="CoglWinsysFeature">
      <source-position filename="../cogl/cogl/cogl-types.h" line="774"/>
      <member name="multiple_onscreen"
              value="0"
              c:identifier="COGL_WINSYS_FEATURE_MULTIPLE_ONSCREEN">
      </member>
      <member name="swap_throttle"
              value="1"
              c:identifier="COGL_WINSYS_FEATURE_SWAP_THROTTLE">
      </member>
      <member name="vblank_counter"
              value="2"
              c:identifier="COGL_WINSYS_FEATURE_VBLANK_COUNTER">
      </member>
      <member name="vblank_wait"
              value="3"
              c:identifier="COGL_WINSYS_FEATURE_VBLANK_WAIT">
      </member>
      <member name="texture_from_pixmap"
              value="4"
              c:identifier="COGL_WINSYS_FEATURE_TEXTURE_FROM_PIXMAP">
      </member>
      <member name="swap_buffers_event"
              value="5"
              c:identifier="COGL_WINSYS_FEATURE_SWAP_BUFFERS_EVENT">
      </member>
      <member name="swap_region"
              value="6"
              c:identifier="COGL_WINSYS_FEATURE_SWAP_REGION">
      </member>
      <member name="swap_region_throttle"
              value="7"
              c:identifier="COGL_WINSYS_FEATURE_SWAP_REGION_THROTTLE">
      </member>
      <member name="swap_region_synchronized"
              value="8"
              c:identifier="COGL_WINSYS_FEATURE_SWAP_REGION_SYNCHRONIZED">
      </member>
      <member name="buffer_age"
              value="9"
              c:identifier="COGL_WINSYS_FEATURE_BUFFER_AGE">
      </member>
      <member name="sync_and_complete_event"
              value="10"
              c:identifier="COGL_WINSYS_FEATURE_SYNC_AND_COMPLETE_EVENT">
      </member>
      <member name="n_features"
              value="11"
              c:identifier="COGL_WINSYS_FEATURE_N_FEATURES">
      </member>
    </enumeration>
    <callback name="XlibFilterFunc"
              c:type="CoglXlibFilterFunc"
              introspectable="0">
      <source-position filename="../cogl/cogl/cogl-xlib-renderer.h" line="89"/>
      <return-value transfer-ownership="none">
        <type name="FilterReturn" c:type="CoglFilterReturn"/>
      </return-value>
      <parameters>
        <parameter name="event" transfer-ownership="none">
          <type c:type="XEvent*"/>
        </parameter>
        <parameter name="data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="_ColorSizeCheck" c:type="_CoglColorSizeCheck">
      <source-position filename="../cogl/cogl/cogl-types.h" line="432"/>
      <field name="compile_time_assert_CoglColor_size" writable="1">
        <array zero-terminated="0" fixed-size="-1">
          <type name="gchar" c:type="char"/>
        </array>
      </field>
    </record>
    <record name="_MatrixSizeCheck" c:type="_CoglMatrixSizeCheck">
      <source-position filename="../cogl/cogl/cogl-matrix.h" line="121"/>
      <field name="compile_time_assert_CoglMatrix_size" writable="1">
        <array zero-terminated="0" fixed-size="-1">
          <type name="gchar" c:type="char"/>
        </array>
      </field>
    </record>
    <record name="_TextureVertexSizeCheck"
            c:type="_CoglTextureVertexSizeCheck">
      <source-position filename="../cogl/cogl/cogl-types.h" line="453"/>
      <field name="compile_time_assert_CoglTextureVertex_size" writable="1">
        <array zero-terminated="0" fixed-size="-1">
          <type name="gchar" c:type="char"/>
        </array>
      </field>
    </record>
    <function name="begin_gl"
              c:identifier="cogl_begin_gl"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="769">We do not advise nor reliably support the interleaving of raw GL drawing and
Cogl drawing functions, but if you insist, cogl_begin_gl() and cogl_end_gl()
provide a simple mechanism that may at least give you a fighting chance of
succeeding.

Note: this doesn't help you modify the behaviour of Cogl drawing functions
through the modification of GL state; that will never be reliably supported,
but if you are trying to do something like:

|[
{
   - setup some OpenGL state.
   - draw using OpenGL (e.g. glDrawArrays() )
   - reset modified OpenGL state.
   - continue using Cogl to draw
}
]|

You should surround blocks of drawing using raw GL with cogl_begin_gl()
and cogl_end_gl():

|[
{
   cogl_begin_gl ();
   - setup some OpenGL state.
   - draw using OpenGL (e.g. glDrawArrays() )
   - reset modified OpenGL state.
   cogl_end_gl ();
   - continue using Cogl to draw
}
]|

Don't ever try and do:

|[
{
   - setup some OpenGL state.
   - use Cogl to draw
   - reset modified OpenGL state.
}
]|

When the internals of Cogl evolves, this is very liable to break.

This function will flush all batched primitives, and subsequently flush
all internal Cogl state to OpenGL as if it were going to draw something
itself.

The result is that the OpenGL modelview matrix will be setup; the state
corresponding to the current source material will be set up and other world
state such as backface culling, depth and fogging enabledness will be sent
to OpenGL.

&lt;note&gt;No special material state is flushed, so if you want Cogl to setup a
simplified material state it is your responsibility to set a simple source
material before calling cogl_begin_gl(). E.g. by calling
cogl_set_source_color4ub().&lt;/note&gt;

&lt;note&gt;It is your responsibility to restore any OpenGL state that you modify
to how it was after calling cogl_begin_gl() if you don't do this then the
result of further Cogl calls is undefined.&lt;/note&gt;

&lt;note&gt;You can not nest begin/end blocks.&lt;/note&gt;

Again we would like to stress, we do not advise the use of this API and if
possible we would prefer to improve Cogl than have developers require raw
OpenGL.</doc>
      <doc-deprecated xml:space="preserve">Use the #CoglGLES2Context api instead</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="845"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="blend_string_error_quark"
              c:identifier="cogl_blend_string_error_quark">
      <source-position filename="../cogl/cogl/cogl-types.h" line="544"/>
      <return-value transfer-ownership="none">
        <type name="guint32" c:type="uint32_t"/>
      </return-value>
    </function>
    <function name="check_extension"
              c:identifier="cogl_check_extension"
              deprecated="1"
              deprecated-version="1.2">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="112">Check whether @name occurs in list of extensions in @ext.</doc>
      <doc-deprecated xml:space="preserve">OpenGL is an implementation detail for Cogl and so it's
  not appropriate to expose OpenGL extensions through the Cogl API. This
  function can be replaced by the following equivalent code:
|[
  gboolean retval = (strstr (ext, name) != NULL) ? TRUE : FALSE;
]|</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="130"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl1-context.h"
             line="119">%TRUE if the extension occurs in the list, %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="114">extension to check for</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="ext" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="115">list of extensions</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="clear"
              c:identifier="cogl_clear"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="546">Clears all the auxiliary buffers identified in the @buffers mask, and if
that includes the color buffer then the specified @color is used.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_clear() api instead</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="559"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="color" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="548">Background color to clear to</doc>
          <type name="Color" c:type="const CoglColor*"/>
        </parameter>
        <parameter name="buffers" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="549">A mask of #CoglBufferBit&lt;!-- --&gt;'s identifying which auxiliary
  buffers to clear</doc>
          <type name="gulong" c:type="unsigned long"/>
        </parameter>
      </parameters>
    </function>
    <function name="clutter_check_extension_CLUTTER"
              c:identifier="cogl_clutter_check_extension_CLUTTER">
      <source-position filename="../cogl/cogl/deprecated/cogl-clutter.h"
                       line="41"/>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="ext" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="clutter_winsys_has_feature_CLUTTER"
              c:identifier="cogl_clutter_winsys_has_feature_CLUTTER">
      <source-position filename="../cogl/cogl/deprecated/cogl-clutter.h"
                       line="46"/>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="feature" transfer-ownership="none">
          <type name="WinsysFeature" c:type="CoglWinsysFeature"/>
        </parameter>
      </parameters>
    </function>
    <function name="color_equal"
              c:identifier="cogl_color_equal"
              moved-to="Color.equal"
              version="1.0">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-color.h"
           line="543">Compares two #CoglColor&lt;!-- --&gt;s and checks if they are the same.

This function can be passed to g_hash_table_new() as the @key_equal_func
parameter, when using #CoglColor&lt;!-- --&gt;s as keys in a #GHashTable.</doc>
      <source-position filename="../cogl/cogl/cogl-color.h" line="558"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-color.h"
             line="553">%TRUE if the two colors are the same.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="v1"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-color.h"
               line="545">a #CoglColor</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="v2"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-color.h"
               line="546">a #CoglColor</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="color_init_from_hsl"
              c:identifier="cogl_color_init_from_hsl"
              moved-to="Color.init_from_hsl"
              version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-color.h"
           line="580">Converts a color expressed in HLS (hue, luminance and saturation)
values into a #CoglColor.</doc>
      <source-position filename="../cogl/cogl/cogl-color.h" line="593"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="color"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-color.h"
               line="582">return location for a #CoglColor</doc>
          <type name="Color" c:type="CoglColor*"/>
        </parameter>
        <parameter name="hue" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-color.h"
               line="583">hue value, in the 0 .. 360 range</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="saturation" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-color.h"
               line="584">saturation value, in the 0 .. 1 range</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="luminance" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-color.h"
               line="585">luminance value, in the 0 .. 1 range</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="create_program"
              c:identifier="cogl_create_program"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-shader.h"
           line="373">Create a new cogl program object that can be used to replace parts of the GL
rendering pipeline with custom code.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-shader.h"
                       line="384"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-shader.h"
             line="379">a new cogl program.</doc>
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
    </function>
    <function name="create_shader"
              c:identifier="cogl_create_shader"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-shader.h"
           line="243">Create a new shader handle, use cogl_shader_source() to set the
source code to be used on it.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-shader.h"
                       line="255"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-shader.h"
             line="250">a new shader handle.</doc>
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="shader_type" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="245">COGL_SHADER_TYPE_VERTEX or COGL_SHADER_TYPE_FRAGMENT.</doc>
          <type name="ShaderType" c:type="CoglShaderType"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_matrix_print"
              c:identifier="cogl_debug_matrix_print"
              version="2.0">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-matrix.h"
           line="765">Prints the contents of a #CoglMatrix to stdout.</doc>
      <source-position filename="../cogl/cogl/cogl-matrix.h" line="774"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="matrix" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-matrix.h"
               line="767">A #CoglMatrix</doc>
          <type name="Matrix" c:type="const CoglMatrix*"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_object_foreach_type"
              c:identifier="cogl_debug_object_foreach_type"
              version="1.8"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-object.h"
           line="216">Invokes @func once for each type of object that Cogl uses and
passes a count of the number of objects for that type. This is
intended to be used solely for debugging purposes to track down
issues with objects leaking.</doc>
      <source-position filename="../cogl/cogl/cogl-object.h" line="230"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="func"
                   transfer-ownership="none"
                   scope="call"
                   closure="1">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-object.h"
               line="218">A callback function for each type</doc>
          <type name="DebugObjectForeachTypeCallback"
                c:type="CoglDebugObjectForeachTypeCallback"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-object.h"
               line="219">A pointer to pass to @func</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_object_print_instances"
              c:identifier="cogl_debug_object_print_instances"
              version="1.8"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-object.h"
           line="233">Prints a list of all the object types that Cogl uses along with the
number of objects of that type that are currently in use. This is
intended to be used solely for debugging purposes to track down
issues with objects leaking.</doc>
      <source-position filename="../cogl/cogl/cogl-object.h" line="245"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="disable_fog"
              c:identifier="cogl_disable_fog"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="534">This function disables fogging, so primitives drawn afterwards will not be
blended with any previously set fog color.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet shader api for fog</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="544"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="egl_texture_2d_new_from_image"
              c:identifier="cogl_egl_texture_2d_new_from_image"
              introspectable="0"
              throws="1">
      <source-position filename="../cogl/cogl/cogl-texture-2d.h" line="242"/>
      <return-value>
        <type name="Texture2D" c:type="CoglTexture2D*"/>
      </return-value>
      <parameters>
        <parameter name="ctx" transfer-ownership="none">
          <type c:type="CoglContext*"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <type name="PixelFormat" c:type="CoglPixelFormat"/>
        </parameter>
        <parameter name="image" transfer-ownership="none">
          <type c:type="EGLImageKHR"/>
        </parameter>
      </parameters>
    </function>
    <function name="end_gl"
              c:identifier="cogl_end_gl"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="847">This is the counterpart to cogl_begin_gl() used to delimit blocks of drawing
code using raw OpenGL. Please refer to cogl_begin_gl() for full details.</doc>
      <doc-deprecated xml:space="preserve">Use the #CoglGLES2Context api instead</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="858"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="features_available"
              c:identifier="cogl_features_available"
              deprecated="1"
              deprecated-version="1.10">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="78">Checks whether the given COGL features are available. Multiple
features can be checked for by or-ing them together with the '|'
operator. %TRUE is only returned if all of the requested features
are available.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_has_feature() instead</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="92"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl1-context.h"
             line="87">%TRUE if the features are available, %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="features" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="80">A bitmask of features to check for</doc>
          <type name="FeatureFlags" c:type="CoglFeatureFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="flush" c:identifier="cogl_flush" version="1.0">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="740">This function should only need to be called in exceptional circumstances.

As an optimization Cogl drawing functions may batch up primitives
internally, so if you are trying to use raw GL outside of Cogl you stand a
better chance of being successful if you ask Cogl to flush any batched
geometry before making your state changes.

It only ensure that the underlying driver is issued all the commands
necessary to draw the batched primitives. It provides no guarantees about
when the driver will complete the rendering.

This provides no guarantees about the GL state upon returning and to avoid
confusing Cogl you should aim to restore any changes you make before
resuming use of Cogl.

If you are making state changes with the intention of affecting Cogl drawing
primitives you are 100% on your own since you stand a good chance of
conflicting with Cogl internals. For example clutter-gst which currently
uses direct GL calls to bind ARBfp programs will very likely break when Cogl
starts to use ARBfb programs itself for the material API.</doc>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="767"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="framebuffer_error_quark"
              c:identifier="cogl_framebuffer_error_quark"
              moved-to="Framebuffer.error_quark">
      <source-position filename="../cogl/cogl/cogl-framebuffer.h" line="1821"/>
      <return-value transfer-ownership="none">
        <type name="guint32" c:type="uint32_t"/>
      </return-value>
    </function>
    <function name="frustum"
              c:identifier="cogl_frustum"
              version="0.8.2"
              deprecated="1"
              deprecated-version="1.10">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="178">Replaces the current projection matrix with a perspective matrix
for a given viewing frustum defined by 4 side clip planes that
all cross through the origin and 2 near and far clip planes.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_frustum() instead</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="200"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="180">X position of the left clipping plane where it
  intersects the near clipping plane</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="182">X position of the right clipping plane where it
  intersects the near clipping plane</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="bottom" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="184">Y position of the bottom clipping plane where it
  intersects the near clipping plane</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="top" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="186">Y position of the top clipping plane where it intersects
  the near clipping plane</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="z_near" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="188">The distance to the near clipping plane (Must be positive)</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="z_far" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="189">The distance to the far clipping plane (Must be positive)</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_backface_culling_enabled"
              c:identifier="cogl_get_backface_culling_enabled"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="485">Queries if backface culling has been enabled via
cogl_set_backface_culling_enabled()</doc>
      <doc-deprecated xml:space="preserve">Use cogl_pipeline_get_cull_face_mode() instead</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="497"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl1-context.h"
             line="491">%TRUE if backface culling is enabled, and %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="get_bitmasks"
              c:identifier="cogl_get_bitmasks"
              deprecated="1"
              deprecated-version="1.8">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="133">Gets the number of bitplanes used for each of the color components
in the color buffer. Pass %NULL for any of the arguments if the
value is not required.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_get_red/green/blue/alpha_bits()
                 instead</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="149"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="red"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="135">Return location for the number of red bits or %NULL</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="green"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="136">Return location for the number of green bits or %NULL</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="blue"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="137">Return location for the number of blue bits or %NULL</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="alpha"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="138">Return location for the number of alpha bits or %NULL</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_depth_test_enabled"
              c:identifier="cogl_get_depth_test_enabled"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="456">Queries if depth testing has been enabled via cogl_set_depth_test_enable()</doc>
      <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_depth_state() instead</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="467"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl1-context.h"
             line="461">%TRUE if depth testing is enabled, and %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="get_draw_framebuffer"
              c:identifier="cogl_get_draw_framebuffer"
              version="1.8"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-framebuffer.h"
           line="1807">Gets the current #CoglFramebuffer as set using
cogl_push_framebuffer()</doc>
      <source-position filename="../cogl/cogl/cogl-framebuffer.h" line="1818"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="1813">The current #CoglFramebuffer</doc>
        <type name="Framebuffer" c:type="CoglFramebuffer*"/>
      </return-value>
    </function>
    <function name="get_features"
              c:identifier="cogl_get_features"
              version="0.8"
              deprecated="1"
              deprecated-version="1.10">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="64">Returns all of the features supported by COGL.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_foreach_feature() instead</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="76"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl1-context.h"
             line="69">A logical OR of all the supported COGL features.</doc>
        <type name="FeatureFlags" c:type="CoglFeatureFlags"/>
      </return-value>
    </function>
    <function name="get_modelview_matrix"
              c:identifier="cogl_get_modelview_matrix"
              deprecated="1"
              deprecated-version="1.10">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="372">Stores the current model-view matrix in @matrix.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_get_modelview_matrix()
                  instead</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="383"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="matrix"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="374">return location for the model-view matrix</doc>
          <type name="Matrix" c:type="CoglMatrix*"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_option_group"
              c:identifier="cogl_get_option_group"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="47">Retrieves the #GOptionGroup used by Cogl to parse the command
line options. Clutter uses this to handle the Cogl command line
options during its initialization process.</doc>
      <doc-deprecated xml:space="preserve">Not replaced</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="61"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl1-context.h"
             line="54">a #GOptionGroup</doc>
        <type name="GLib.OptionGroup" c:type="GOptionGroup*"/>
      </return-value>
    </function>
    <function name="get_proc_address"
              c:identifier="cogl_get_proc_address"
              introspectable="0">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="94">Gets a pointer to a given GL or GL ES extension function. This acts
as a wrapper around glXGetProcAddress() or whatever is the
appropriate function for the current backend.

&lt;note&gt;This function should not be used to query core opengl API
symbols since eglGetProcAddress for example doesn't allow this and
and may return a junk pointer if you do.&lt;/note&gt;</doc>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="110"/>
      <return-value>
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl1-context.h"
             line="106">a pointer to the requested function or %NULL if the
  function is not available.</doc>
        <type name="GObject.Callback" c:type="GCallback"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="96">the name of the function.</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_projection_matrix"
              c:identifier="cogl_get_projection_matrix"
              deprecated="1"
              deprecated-version="1.10">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="398">Stores the current projection matrix in @matrix.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_get_projection_matrix()
                  instead</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="409"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="matrix"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="400">return location for the projection matrix</doc>
          <type name="Matrix" c:type="CoglMatrix*"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_source"
              c:identifier="cogl_get_source"
              version="1.6"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="580">Returns the current source material as previously set using
cogl_set_source().

&lt;note&gt;You should typically consider the returned material immutable
and not try to change any of its properties unless you own a
reference to that material. At times you may be able to get a
reference to an internally managed materials and the result of
modifying such materials is undefined.&lt;/note&gt;</doc>
      <doc-deprecated xml:space="preserve">Latest drawing apis all take an explicit
                  #CoglPipeline argument so this stack of
                  #CoglMaterial&lt;!-- --&gt;s shouldn't be used.</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="601"/>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl1-context.h"
             line="592">The current source material.</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
    </function>
    <function name="get_viewport"
              c:identifier="cogl_get_viewport"
              deprecated="1"
              deprecated-version="1.10">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="424">Stores the current viewport in @v. @v[0] and @v[1] get the x and y
position of the viewport and @v[2] and @v[3] get the width and
height.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_get_viewport4fv()
                  instead</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="438"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="v"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="426">pointer to a 4 element array
  of #float&lt;!-- --&gt;s to receive the viewport dimensions.</doc>
          <array zero-terminated="0" c:type="float*" fixed-size="4">
            <type name="gfloat" c:type="float"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="gtype_matrix_get_type"
              c:identifier="cogl_gtype_matrix_get_type"
              deprecated="1"
              deprecated-version="1.18">
      <doc-deprecated xml:space="preserve">Use cogl_matrix_get_gtype() instead.</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl-matrix.h" line="795"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-matrix.h"
             line="788">the GType for the registered "CoglMatrix" boxed type. This
can be used for example to define GObject properties that accept a
#CoglMatrix value.</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="handle_get_type" c:identifier="cogl_handle_get_type">
      <source-position filename="../cogl/cogl/cogl-types.h" line="93"/>
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="handle_ref" c:identifier="cogl_handle_ref">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-types.h"
           line="95">Increases the reference count of @handle by 1</doc>
      <source-position filename="../cogl/cogl/cogl-types.h" line="104"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-types.h"
             line="101">the handle, with its reference count increased</doc>
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-types.h"
               line="97">a #CoglHandle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_unref" c:identifier="cogl_handle_unref">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-types.h"
           line="106">Drecreases the reference count of @handle by 1; if the reference
count reaches 0, the resources allocated by @handle will be freed</doc>
      <source-position filename="../cogl/cogl/cogl-types.h" line="114"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-types.h"
               line="108">a #CoglHandle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_bitmap" c:identifier="cogl_is_bitmap" version="1.0">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-bitmap.h"
           line="254">Checks whether @object is a #CoglBitmap</doc>
      <source-position filename="../cogl/cogl/cogl-bitmap.h" line="266"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-bitmap.h"
             line="260">%TRUE if the passed @object represents a bitmap,
  and %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-bitmap.h"
               line="256">a #CoglObject pointer</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_framebuffer"
              c:identifier="cogl_is_framebuffer"
              version="1.10"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-framebuffer.h"
           line="1835">Gets whether the given object references a #CoglFramebuffer.</doc>
      <source-position filename="../cogl/cogl/cogl-framebuffer.h" line="1847"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-framebuffer.h"
             line="1841">%TRUE if the object references a #CoglFramebuffer
  and %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-framebuffer.h"
               line="1837">A #CoglObject pointer</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_material"
              c:identifier="cogl_is_material"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-material-compat.h"
           line="209">Gets whether the given handle references an existing material object.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_is_pipeline() instead</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                       line="221"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="215">%TRUE if the handle references a #CoglMaterial,
  %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-material-compat.h"
               line="211">A CoglHandle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_offscreen" c:identifier="cogl_is_offscreen">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-offscreen.h"
           line="125">Determines whether the given #CoglObject references an offscreen
framebuffer object.</doc>
      <source-position filename="../cogl/cogl/cogl-offscreen.h" line="136"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-offscreen.h"
             line="132">%TRUE if @object is a #CoglOffscreen framebuffer,
         %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-offscreen.h"
               line="127">A pointer to a #CoglObject</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_onscreen"
              c:identifier="cogl_is_onscreen"
              version="1.10"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-onscreen.h"
           line="852">Gets whether the given object references a #CoglOnscreen.</doc>
      <source-position filename="../cogl/cogl/cogl-onscreen.h" line="864"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-onscreen.h"
             line="858">%TRUE if the object references a #CoglOnscreen
  and %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-onscreen.h"
               line="854">A #CoglObject pointer</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_pipeline"
              c:identifier="cogl_is_pipeline"
              version="2.0"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-pipeline.h"
           line="110">Gets whether the given @object references an existing pipeline object.</doc>
      <source-position filename="../cogl/cogl/cogl-pipeline.h" line="123"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-pipeline.h"
             line="116">%TRUE if the @object references a #CoglPipeline,
  %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-pipeline.h"
               line="112">A #CoglObject</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_program"
              c:identifier="cogl_is_program"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-shader.h"
           line="413">Gets whether the given handle references an existing program object.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-shader.h"
                       line="426"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-shader.h"
             line="419">%TRUE if the handle references a program,
  %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="415">A CoglHandle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_shader"
              c:identifier="cogl_is_shader"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-shader.h"
           line="283">Gets whether the given handle references an existing shader object.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-shader.h"
                       line="295"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-shader.h"
             line="289">%TRUE if the handle references a shader,
  %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="285">A CoglHandle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_texture" c:identifier="cogl_is_texture">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-texture.h"
           line="131">Gets whether the given object references a texture object.</doc>
      <source-position filename="../cogl/cogl/cogl-texture.h" line="141"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-texture.h"
             line="137">%TRUE if the @object references a texture, and
  %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-texture.h"
               line="133">A #CoglObject pointer</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_texture_2d" c:identifier="cogl_is_texture_2d">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-texture-2d.h"
           line="75">Gets whether the given object references an existing #CoglTexture2D
object.</doc>
      <source-position filename="../cogl/cogl/cogl-texture-2d.h" line="86"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-texture-2d.h"
             line="82">%TRUE if the object references a #CoglTexture2D,
  %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-texture-2d.h"
               line="77">A #CoglObject</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_texture_2d_sliced"
              c:identifier="cogl_is_texture_2d_sliced"
              version="1.10"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-texture-2d-sliced.h"
           line="285">Gets whether the given object references a #CoglTexture2DSliced.</doc>
      <source-position filename="../cogl/cogl/cogl-texture-2d-sliced.h"
                       line="297"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-texture-2d-sliced.h"
             line="291">%TRUE if the object references a #CoglTexture2DSliced
  and %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-texture-2d-sliced.h"
               line="287">A #CoglObject pointer</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_vertex_buffer"
              c:identifier="cogl_is_vertex_buffer"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
           line="417">Checks whether @handle is a Vertex Buffer Object</doc>
      <doc-deprecated xml:space="preserve">Use the #CoglPrimitive api instead</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
                       line="431"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
             line="423">%TRUE if the handle is a VBO, and %FALSE
  otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
               line="419">a #CoglHandle for a vertex buffer object</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_vertex_buffer_indices"
              c:identifier="cogl_is_vertex_buffer_indices"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
           line="433">Checks whether @handle is a handle to the indices for a vertex
buffer object</doc>
      <doc-deprecated xml:space="preserve">Use the #CoglPrimitive api instead</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
                       line="448"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
             line="440">%TRUE if the handle is indices, and %FALSE
  otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
               line="435">a #CoglHandle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_ref"
              c:identifier="cogl_material_ref"
              moved-to="Material.ref"
              version="1.0"
              deprecated="1"
              deprecated-version="1.2">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-material-compat.h"
           line="179">Increment the reference count for a #CoglMaterial.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_object_ref() instead</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                       line="193"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-material-compat.h"
             line="185">the @material.</doc>
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="material" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-material-compat.h"
               line="181">a #CoglMaterial object.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_unref"
              c:identifier="cogl_material_unref"
              moved-to="Material.unref"
              version="1.0"
              deprecated="1"
              deprecated-version="1.2">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-material-compat.h"
           line="195">Decrement the reference count for a #CoglMaterial.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_object_unref() instead</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-material-compat.h"
                       line="207"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="material" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-material-compat.h"
               line="197">a #CoglMaterial object.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="matrix_equal"
              c:identifier="cogl_matrix_equal"
              moved-to="Matrix.equal"
              version="1.4">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-matrix.h"
           line="540">Compares two matrices to see if they represent the same
transformation. Although internally the matrices may have different
annotations associated with them and may potentially have a cached
inverse matrix these are not considered in the comparison.</doc>
      <source-position filename="../cogl/cogl/cogl-matrix.h" line="553"/>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="v1"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-matrix.h"
               line="542">A 4x4 transformation matrix</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="v2"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-matrix.h"
               line="543">A 4x4 transformation matrix</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="ortho"
              c:identifier="cogl_ortho"
              version="1.0"
              deprecated="1"
              deprecated-version="1.10">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="207">Replaces the current projection matrix with an orthographic projection
matrix. See &lt;xref linkend="cogl-ortho-matrix"/&gt; to see how the matrix is
calculated.

&lt;figure id="cogl-ortho-matrix"&gt;
  &lt;title&gt;&lt;/title&gt;
  &lt;graphic fileref="cogl_ortho.png" format="PNG"/&gt;
&lt;/figure&gt;

&lt;note&gt;This function copies the arguments from OpenGL's glOrtho() even
though they are unnecessarily confusing due to the z near and z far
arguments actually being a "distance" from the origin, where
negative values are behind the viewer, instead of coordinates for
the z clipping planes which would have been consistent with the
left, right bottom and top arguments.&lt;/note&gt;</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_orthographic() instead</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="239"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="209">The coordinate for the left clipping plane</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="210">The coordinate for the right clipping plane</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="bottom" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="211">The coordinate for the bottom clipping plane</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="top" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="212">The coordinate for the top clipping plane</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="near" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="213">The &lt;emphasis&gt;distance&lt;/emphasis&gt; to the near clipping
  plane (negative if the plane is behind the viewer)</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="far" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="215">The &lt;emphasis&gt;distance&lt;/emphasis&gt; for the far clipping
  plane (negative if the plane is behind the viewer)</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="perspective"
              c:identifier="cogl_perspective"
              deprecated="1"
              deprecated-version="1.10">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="154">Replaces the current projection matrix with a perspective matrix
based on the provided values.

&lt;note&gt;You should be careful not to have to great a @z_far / @z_near
ratio since that will reduce the effectiveness of depth testing
since there wont be enough precision to identify the depth of
objects near to each other.&lt;/note&gt;</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_perspective() instead</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="173"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="fovy" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="156">Vertical field of view angle in degrees.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="aspect" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="157">The (width over height) aspect ratio for display</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="z_near" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="158">The distance to the near clipping plane (Must be positive)</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="z_far" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="159">The distance to the far clipping plane (Must be positive)</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="polygon" c:identifier="cogl_polygon" version="1.0">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-primitives.h"
           line="166">Draws a convex polygon using the current source material to fill / texture
with according to the texture coordinates passed.

If @use_color is %TRUE then the color will be changed for each vertex using
the value specified in the color member of #CoglTextureVertex. This can be
used for example to make the texture fade out by setting the alpha value of
the color.

All of the texture coordinates must be in the range [0,1] and repeating the
texture is not supported.

Because of the way this function is implemented it will currently
only work if either the texture is not sliced or the backend is not
OpenGL ES and the minifying and magnifying functions are both set
to COGL_MATERIAL_FILTER_NEAREST.</doc>
      <source-position filename="../cogl/cogl/cogl-primitives.h" line="191"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="vertices" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-primitives.h"
               line="168">An array of #CoglTextureVertex structs</doc>
          <type name="TextureVertex" c:type="const CoglTextureVertex*"/>
        </parameter>
        <parameter name="n_vertices" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-primitives.h"
               line="169">The length of the vertices array</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
        <parameter name="use_color" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-primitives.h"
               line="170">%TRUE if the color member of #CoglTextureVertex should be used</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="pop_matrix"
              c:identifier="cogl_pop_matrix"
              deprecated="1"
              deprecated-version="1.10">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="292">Restores the current model-view matrix from the matrix stack.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_pop_matrix() instead</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="301"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="pop_source"
              c:identifier="cogl_pop_source"
              version="1.6"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="620">Removes the material at the top of the source stack. The material
at the top of this stack defines the GPU state used to process
later primitives as defined by cogl_set_source().</doc>
      <doc-deprecated xml:space="preserve">Latest drawing apis all take an explicit
                  #CoglPipeline argument so this stack of
                  #CoglMaterial&lt;!-- --&gt;s shouldn't be used.</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="634"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="program_attach_shader"
              c:identifier="cogl_program_attach_shader"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-shader.h"
           line="428">Attaches a shader to a program object. A program can have multiple
vertex or fragment shaders but only one of them may provide a
main() function. It is allowed to use a program with only a vertex
shader or only a fragment shader.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-shader.h"
                       line="442"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="program_handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="430">a #CoglHandle for a shdaer program.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="shader_handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="431">a #CoglHandle for a vertex of fragment shader.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_get_uniform_location"
              c:identifier="cogl_program_get_uniform_location"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-shader.h"
           line="478">Retrieve the location (offset) of a uniform variable in a shader program,
a uniform is a variable that is constant for all vertices/fragments for a
shader object and is possible to modify as an external parameter.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api instead</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-shader.h"
                       line="494"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-shader.h"
             line="487">the offset of a uniform in a specified program.
  This uniform can be set using cogl_program_uniform_1f() when the
  program is in use.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="480">a #CoglHandle for a shader program.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="uniform_name" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="481">the name of a uniform.</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_link"
              c:identifier="cogl_program_link"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-shader.h"
           line="445">Links a program making it ready for use. Note that calling this
function is optional. If it is not called the program will
automatically be linked the first time it is used.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-shader.h"
                       line="457"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="447">a #CoglHandle for a shader program.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_ref"
              c:identifier="cogl_program_ref"
              deprecated="1"
              deprecated-version="1.0">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-shader.h"
           line="386">Add an extra reference to a program.</doc>
      <doc-deprecated xml:space="preserve">Please use cogl_object_ref() instead.</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-shader.h"
                       line="398"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-shader.h"
             line="394">@handle</doc>
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="388">A #CoglHandle to a program.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_set_uniform_1f"
              c:identifier="cogl_program_set_uniform_1f"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-shader.h"
           line="497">Changes the value of a floating point uniform for the given linked
@program.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api instead</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-shader.h"
                       line="512"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="program" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="499">A #CoglHandle for a linked program</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="uniform_location" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="500">the uniform location retrieved from
   cogl_program_get_uniform_location().</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="502">the new value of the uniform.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_set_uniform_1i"
              c:identifier="cogl_program_set_uniform_1i"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-shader.h"
           line="516">Changes the value of an integer uniform for the given linked
@program.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api instead</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-shader.h"
                       line="531"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="program" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="518">A #CoglHandle for a linked program</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="uniform_location" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="519">the uniform location retrieved from
   cogl_program_get_uniform_location().</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="521">the new value of the uniform.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_set_uniform_float"
              c:identifier="cogl_program_set_uniform_float"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-shader.h"
           line="535">Changes the value of a float vector uniform, or uniform array for
the given linked @program.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api instead</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-shader.h"
                       line="554"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="program" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="537">A #CoglHandle for a linked program</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="uniform_location" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="538">the uniform location retrieved from
   cogl_program_get_uniform_location().</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="n_components" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="540">The number of components for the uniform. For
example with glsl you'd use 3 for a vec3 or 4 for a vec4.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="542">For uniform arrays this is the array length otherwise just
pass 1</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="544">the new value of the uniform[s].</doc>
          <array length="3" zero-terminated="0" c:type="const float*">
            <type name="gfloat" c:type="float"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="program_set_uniform_int"
              c:identifier="cogl_program_set_uniform_int"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-shader.h"
           line="560">Changes the value of a int vector uniform, or uniform array for
the given linked @program.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api instead</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-shader.h"
                       line="579"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="program" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="562">A #CoglHandle for a linked program</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="uniform_location" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="563">the uniform location retrieved from
   cogl_program_get_uniform_location().</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="n_components" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="565">The number of components for the uniform. For
example with glsl you'd use 3 for a vec3 or 4 for a vec4.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="567">For uniform arrays this is the array length otherwise just
pass 1</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="569">the new value of the uniform[s].</doc>
          <array length="3" zero-terminated="0" c:type="const int*">
            <type name="gint" c:type="int"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="program_set_uniform_matrix"
              c:identifier="cogl_program_set_uniform_matrix"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-shader.h"
           line="585">Changes the value of a matrix uniform, or uniform array in the
given linked @program.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api instead</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-shader.h"
                       line="605"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="program" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="587">A #CoglHandle for a linked program</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="uniform_location" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="588">the uniform location retrieved from
   cogl_program_get_uniform_location().</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="dimensions" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="590">The dimensions of the matrix. So for for example pass
   2 for a 2x2 matrix or 3 for 3x3.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="592">For uniform arrays this is the array length otherwise just
pass 1</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="transpose" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="594">Whether to transpose the matrix when setting the uniform.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="595">the new value of the uniform.</doc>
          <array length="3" zero-terminated="0" c:type="const float*">
            <type name="gfloat" c:type="float"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="program_uniform_1f"
              c:identifier="cogl_program_uniform_1f"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-shader.h"
           line="612">Changes the value of a floating point uniform in the currently
used (see cogl_program_use()) shader program.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-shader.h"
                       line="624"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="uniform_no" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="614">the uniform to set.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="615">the new value of the uniform.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_uniform_1i"
              c:identifier="cogl_program_uniform_1i"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-shader.h"
           line="627">Changes the value of an integer uniform in the currently
used (see cogl_program_use()) shader program.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-shader.h"
                       line="639"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="uniform_no" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="629">the uniform to set.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="630">the new value of the uniform.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_uniform_float"
              c:identifier="cogl_program_uniform_float"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-shader.h"
           line="642">Changes the value of a float vector uniform, or uniform array in the
currently used (see cogl_program_use()) shader program.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-shader.h"
                       line="656"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="uniform_no" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="644">the uniform to set.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="645">Size of float vector.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="646">Size of array of uniforms.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="647">the new value of the uniform.</doc>
          <array length="2" zero-terminated="0" c:type="const float*">
            <type name="gfloat" c:type="float"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="program_uniform_int"
              c:identifier="cogl_program_uniform_int"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-shader.h"
           line="661">Changes the value of a int vector uniform, or uniform array in the
currently used (see cogl_program_use()) shader program.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-shader.h"
                       line="675"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="uniform_no" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="663">the uniform to set.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="664">Size of int vector.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="665">Size of array of uniforms.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="666">the new value of the uniform.</doc>
          <array length="2" zero-terminated="0" c:type="const int*">
            <type name="gint" c:type="int"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="program_uniform_matrix"
              c:identifier="cogl_program_uniform_matrix"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-shader.h"
           line="680">Changes the value of a matrix uniform, or uniform array in the
currently used (see cogl_program_use()) shader program. The @size
parameter is used to determine the square size of the matrix.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-shader.h"
                       line="696"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="uniform_no" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="682">the uniform to set.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="683">Size of matrix.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="684">Size of array of uniforms.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="transpose" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="685">Whether to transpose the matrix when setting the uniform.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="686">the new value of the uniform.</doc>
          <array length="2" zero-terminated="0" c:type="const float*">
            <type name="gfloat" c:type="float"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="program_unref"
              c:identifier="cogl_program_unref"
              deprecated="1"
              deprecated-version="1.0">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-shader.h"
           line="400">Removes a reference to a program. If it was the last reference the
program object will be destroyed.</doc>
      <doc-deprecated xml:space="preserve">Please use cogl_object_unref() instead.</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-shader.h"
                       line="411"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="402">A #CoglHandle to a program.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_use"
              c:identifier="cogl_program_use"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-shader.h"
           line="459">Activate a specific shader program replacing that part of the GL
rendering pipeline, if passed in %COGL_INVALID_HANDLE the default
behavior of GL is reinstated.

This function affects the global state of the current Cogl
context. It is much more efficient to attach the shader to a
specific material used for rendering instead by calling
cogl_material_set_user_program().</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-shader.h"
                       line="476"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="461">a #CoglHandle for a shader program or %COGL_INVALID_HANDLE.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="push_matrix"
              c:identifier="cogl_push_matrix"
              deprecated="1"
              deprecated-version="1.10">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="280">Stores the current model-view matrix on the matrix stack. The matrix
can later be restored with cogl_pop_matrix().</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_push_matrix() instead</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="290"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="push_source"
              c:identifier="cogl_push_source"
              version="1.6"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="603">Pushes the given @material to the top of the source stack. The
material at the top of this stack defines the GPU state used to
process later primitives as defined by cogl_set_source().</doc>
      <doc-deprecated xml:space="preserve">Latest drawing apis all take an explicit
                  #CoglPipeline argument so this stack of
                  #CoglMaterial&lt;!-- --&gt;s shouldn't be used.</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="618"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="material"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="605">A #CoglMaterial</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="rectangle" c:identifier="cogl_rectangle">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-primitives.h"
           line="47">Fills a rectangle at the given coordinates with the current source material</doc>
      <source-position filename="../cogl/cogl/cogl-primitives.h" line="57"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x_1" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-primitives.h"
               line="49">X coordinate of the top-left corner</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y_1" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-primitives.h"
               line="50">Y coordinate of the top-left corner</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="x_2" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-primitives.h"
               line="51">X coordinate of the bottom-right corner</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y_2" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-primitives.h"
               line="52">Y coordinate of the bottom-right corner</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="rectangle_with_multitexture_coords"
              c:identifier="cogl_rectangle_with_multitexture_coords"
              version="1.0">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-primitives.h"
           line="89">This function draws a rectangle using the current source material to
texture or fill with. As a material may contain multiple texture layers
this interface lets you supply texture coordinates for each layer of the
material.

The first pair of coordinates are for the first layer (with the smallest
layer index) and if you supply less texture coordinates than there are
layers in the current source material then default texture coordinates
(0.0, 0.0, 1.0, 1.0) are generated.</doc>
      <source-position filename="../cogl/cogl/cogl-primitives.h" line="117"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x1" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-primitives.h"
               line="91">x coordinate upper left on screen.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y1" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-primitives.h"
               line="92">y coordinate upper left on screen.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="x2" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-primitives.h"
               line="93">x coordinate lower right on screen.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y2" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-primitives.h"
               line="94">y coordinate lower right on screen.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="tex_coords" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-primitives.h"
               line="95">An array containing groups of
  4 float values: [tx1, ty1, tx2, ty2] that are interpreted as two texture
  coordinates; one for the upper left texel, and one for the lower right
  texel. Each value should be between 0.0 and 1.0, where the coordinate
  (0.0, 0.0) represents the top left of the texture, and (1.0, 1.0) the
  bottom right.</doc>
          <array zero-terminated="0" c:type="const float*">
            <type name="gfloat" c:type="float"/>
          </array>
        </parameter>
        <parameter name="tex_coords_len" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-primitives.h"
               line="101">The length of the tex_coords array. (e.g. for one layer
  and one group of texture coordinates, this would be 4)</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="rectangle_with_texture_coords"
              c:identifier="cogl_rectangle_with_texture_coords"
              version="1.0">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-primitives.h"
           line="62">Draw a rectangle using the current material and supply texture coordinates
to be used for the first texture layer of the material. To draw the entire
texture pass in @tx1=0.0 @ty1=0.0 @tx2=1.0 @ty2=1.0.</doc>
      <source-position filename="../cogl/cogl/cogl-primitives.h" line="80"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x1" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-primitives.h"
               line="64">x coordinate upper left on screen.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y1" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-primitives.h"
               line="65">y coordinate upper left on screen.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="x2" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-primitives.h"
               line="66">x coordinate lower right on screen.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y2" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-primitives.h"
               line="67">y coordinate lower right on screen.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="tx1" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-primitives.h"
               line="68">x part of texture coordinate to use for upper left pixel</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="ty1" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-primitives.h"
               line="69">y part of texture coordinate to use for upper left pixel</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="tx2" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-primitives.h"
               line="70">x part of texture coordinate to use for lower right pixel</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="ty2" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-primitives.h"
               line="71">y part of texture coordinate to use for left pixel</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="rectangles" c:identifier="cogl_rectangles" version="1.0">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-primitives.h"
           line="145">Draws a series of rectangles in the same way that
cogl_rectangle() does. In some situations it can give a
significant performance boost to use this function rather than
calling cogl_rectangle() separately for each rectangle.

@verts should point to an array of #float&lt;!-- --&gt;s with
@n_rects * 4 elements. Each group of 4 values corresponds to the
parameters x1, y1, x2, and y2, and have the same
meaning as in cogl_rectangle().</doc>
      <source-position filename="../cogl/cogl/cogl-primitives.h" line="163"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="verts" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-primitives.h"
               line="147">an array of vertices</doc>
          <array zero-terminated="0" c:type="const float*">
            <type name="gfloat" c:type="float"/>
          </array>
        </parameter>
        <parameter name="n_rects" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-primitives.h"
               line="148">number of rectangles to draw</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
      </parameters>
    </function>
    <function name="rectangles_with_texture_coords"
              c:identifier="cogl_rectangles_with_texture_coords"
              version="0.8.6">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-primitives.h"
           line="124">Draws a series of rectangles in the same way that
cogl_rectangle_with_texture_coords() does. In some situations it can give a
significant performance boost to use this function rather than
calling cogl_rectangle_with_texture_coords() separately for each rectangle.

@verts should point to an array of #float&lt;!-- --&gt;s with
@n_rects * 8 elements. Each group of 8 values corresponds to the
parameters x1, y1, x2, y2, tx1, ty1, tx2 and ty2 and have the same
meaning as in cogl_rectangle_with_texture_coords().</doc>
      <source-position filename="../cogl/cogl/cogl-primitives.h" line="142"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="verts" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-primitives.h"
               line="126">an array of vertices</doc>
          <array zero-terminated="0" c:type="const float*">
            <type name="gfloat" c:type="float"/>
          </array>
        </parameter>
        <parameter name="n_rects" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-primitives.h"
               line="127">number of rectangles to draw</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
      </parameters>
    </function>
    <function name="rotate"
              c:identifier="cogl_rotate"
              deprecated="1"
              deprecated-version="1.10">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="337">Multiplies the current model-view matrix by one that rotates the
model around the vertex specified by @x, @y and @z. The rotation
follows the right-hand thumb rule so for example rotating by 10
degrees about the vertex (0, 0, 1) causes a small counter-clockwise
rotation.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_rotate() instead</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="354"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="angle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="339">Angle in degrees to rotate.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="x" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="340">X-component of vertex to rotate around.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="341">Y-component of vertex to rotate around.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="z" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="342">Z-component of vertex to rotate around.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="scale"
              c:identifier="cogl_scale"
              deprecated="1"
              deprecated-version="1.10">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="303">Multiplies the current model-view matrix by one that scales the x,
y and z axes by the given values.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_pop_matrix() instead</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="316"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="305">Amount to scale along the x-axis</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="306">Amount to scale along the y-axis</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="z" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="307">Amount to scale along the z-axis</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_backface_culling_enabled"
              c:identifier="cogl_set_backface_culling_enabled"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="469">Sets whether textures positioned so that their backface is showing
should be hidden. This can be used to efficiently draw two-sided
textures or fully closed cubes without enabling depth testing. This
only affects calls to the cogl_rectangle* family of functions and
cogl_vertex_buffer_draw*. Backface culling is disabled by default.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_cull_face_mode() instead</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="483"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="setting" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="471">%TRUE to enable backface culling or %FALSE to disable.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_depth_test_enabled"
              c:identifier="cogl_set_depth_test_enabled"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="440">Sets whether depth testing is enabled. If it is disabled then the
order that actors are layered on the screen depends solely on the
order specified using clutter_actor_raise() and
clutter_actor_lower(), otherwise it will also take into account the
actor's depth. Depth testing is disabled by default.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_depth_state() instead</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="454"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="setting" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="442">%TRUE to enable depth testing or %FALSE to disable.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_fog"
              c:identifier="cogl_set_fog"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="499">Enables fogging. Fogging causes vertices that are further away from the eye
to be rendered with a different color. The color is determined according to
the chosen fog mode; at it's simplest the color is linearly interpolated so
that vertices at @z_near are drawn fully with their original color and
vertices at @z_far are drawn fully with @fog_color. Fogging will remain
enabled until you call cogl_disable_fog().

&lt;note&gt;The fogging functions only work correctly when primitives use
unmultiplied alpha colors. By default Cogl will premultiply textures
and cogl_set_source_color() will premultiply colors, so unless you
explicitly load your textures requesting an unmultiplied internal format
and use cogl_material_set_color() you can only use fogging with fully
opaque primitives. This might improve in the future when we can depend
on fragment shaders.&lt;/note&gt;</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet shader api for fog</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="528"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="fog_color" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="501">The color of the fog</doc>
          <type name="Color" c:type="const CoglColor*"/>
        </parameter>
        <parameter name="mode" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="502">A #CoglFogMode that determines the equation used to calculate the
  fogging blend factor.</doc>
          <type name="FogMode" c:type="CoglFogMode"/>
        </parameter>
        <parameter name="density" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="504">Used by %COGL_FOG_MODE_EXPONENTIAL and by
  %COGL_FOG_MODE_EXPONENTIAL_SQUARED equations.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="z_near" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="506">Position along Z axis where no fogging should be applied</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="z_far" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="507">Position along Z axis where full fogging should be applied</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_modelview_matrix"
              c:identifier="cogl_set_modelview_matrix"
              deprecated="1"
              deprecated-version="1.10">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="385">Loads @matrix as the new model-view matrix.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_set_modelview_matrix()
                  instead</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="396"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="matrix" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="387">the new model-view matrix</doc>
          <type name="Matrix" c:type="CoglMatrix*"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_projection_matrix"
              c:identifier="cogl_set_projection_matrix"
              deprecated="1"
              deprecated-version="1.10">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="411">Loads matrix as the new projection matrix.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_set_projection_matrix()
                  instead</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="422"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="matrix" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="413">the new projection matrix</doc>
          <type name="Matrix" c:type="CoglMatrix*"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_source"
              c:identifier="cogl_set_source"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="562">This function changes the material at the top of the source stack.
The material at the top of this stack defines the GPU state used to
process subsequent primitives, such as rectangles drawn with
cogl_rectangle() or vertices drawn using cogl_vertex_buffer_draw().</doc>
      <doc-deprecated xml:space="preserve">Latest drawing apis all take an explicit
                  #CoglPipeline argument so this stack of
                  #CoglMaterial&lt;!-- --&gt;s shouldn't be used.</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="578"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="material"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="564">A #CoglMaterial</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_source_color"
              c:identifier="cogl_set_source_color"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="636">This is a convenience function for creating a solid fill source material
from the given color. This color will be used for any subsequent drawing
operation.

The color will be premultiplied by Cogl, so the color should be
non-premultiplied. For example: use (1.0, 0.0, 0.0, 0.5) for
semi-transparent red.

See also cogl_set_source_color4ub() and cogl_set_source_color4f()
if you already have the color components.</doc>
      <doc-deprecated xml:space="preserve">Latest drawing apis all take an explicit
                  #CoglPipeline argument so this stack of
                  #CoglMaterial&lt;!-- --&gt;s shouldn't be used.</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="658"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="color" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="638">a #CoglColor</doc>
          <type name="Color" c:type="const CoglColor*"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_source_color4f"
              c:identifier="cogl_set_source_color4f"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="686">This is a convenience function for creating a solid fill source material
from the given color using normalized values for each component. This color
will be used for any subsequent drawing operation.

The value for each component is a fixed point number in the range
between 0 and %1.0. If the values passed in are outside that
range, they will be clamped.</doc>
      <doc-deprecated xml:space="preserve">Latest drawing apis all take an explicit
                  #CoglPipeline argument so this stack of
                  #CoglMaterial&lt;!-- --&gt;s shouldn't be used.</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="708"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="red" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="688">value of the red channel, between 0 and %1.0</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="green" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="689">value of the green channel, between 0 and %1.0</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="blue" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="690">value of the blue channel, between 0 and %1.0</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="alpha" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="691">value of the alpha channel, between 0 and %1.0</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_source_color4ub"
              c:identifier="cogl_set_source_color4ub"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="660">This is a convenience function for creating a solid fill source material
from the given color using unsigned bytes for each component. This
color will be used for any subsequent drawing operation.

The value for each component is an unsigned byte in the range
between 0 and 255.</doc>
      <doc-deprecated xml:space="preserve">Latest drawing apis all take an explicit
                  #CoglPipeline argument so this stack of
                  #CoglMaterial&lt;!-- --&gt;s shouldn't be used.</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="681"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="red" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="662">value of the red channel, between 0 and 255</doc>
          <type name="guint8" c:type="uint8_t"/>
        </parameter>
        <parameter name="green" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="663">value of the green channel, between 0 and 255</doc>
          <type name="guint8" c:type="uint8_t"/>
        </parameter>
        <parameter name="blue" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="664">value of the blue channel, between 0 and 255</doc>
          <type name="guint8" c:type="uint8_t"/>
        </parameter>
        <parameter name="alpha" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="665">value of the alpha channel, between 0 and 255</doc>
          <type name="guint8" c:type="uint8_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_source_texture"
              c:identifier="cogl_set_source_texture"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="713">This is a convenience function for creating a material with the first
layer set to @texture and setting that material as the source with
cogl_set_source.

Note: There is no interaction between calls to cogl_set_source_color
and cogl_set_source_texture. If you need to blend a texture with a color then
you can create a simple material like this:
&lt;programlisting&gt;
material = cogl_material_new ();
cogl_material_set_color4ub (material, 0xff, 0x00, 0x00, 0x80);
cogl_material_set_layer (material, 0, tex_handle);
cogl_set_source (material);
&lt;/programlisting&gt;</doc>
      <doc-deprecated xml:space="preserve">Latest drawing apis all take an explicit
                  #CoglPipeline argument so this stack of
                  #CoglMaterial&lt;!-- --&gt;s shouldn't be used.</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="738"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="texture" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="715">The #CoglTexture you want as your source</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_viewport"
              c:identifier="cogl_set_viewport"
              version="1.2"
              deprecated="1"
              deprecated-version="1.8">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="261">Replaces the current viewport with the given values.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_set_viewport() instead</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="275"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="263">X offset of the viewport</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="264">Y offset of the viewport</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="265">Width of the viewport</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="266">Height of the viewport</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="shader_compile"
              c:identifier="cogl_shader_compile"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-shader.h"
           line="315">Compiles the shader, no return value, but the shader is now ready
for linking into a program. Note that calling this function is
optional. If it is not called then the shader will be automatically
compiled when it is linked.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-shader.h"
                       line="327"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="317">#CoglHandle for a shader.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="shader_get_info_log"
              c:identifier="cogl_shader_get_info_log"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-shader.h"
           line="329">Retrieves the information log for a coglobject, can be used in conjunction
with cogl_shader_get_parameteriv() to retrieve the compiler warnings/error
messages that caused a shader to not compile correctly, mainly useful for
debugging purposes.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-shader.h"
                       line="344"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-shader.h"
             line="338">a newly allocated string containing the info log. Use
  g_free() to free it</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="331">#CoglHandle for a shader.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="shader_get_type"
              c:identifier="cogl_shader_get_type"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-shader.h"
           line="346">Retrieves the type of a shader #CoglHandle</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-shader.h"
                       line="358"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-shader.h"
             line="352">%COGL_SHADER_TYPE_VERTEX if the shader is a vertex processor
         or %COGL_SHADER_TYPE_FRAGMENT if the shader is a frament processor</doc>
        <type name="ShaderType" c:type="CoglShaderType"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="348">#CoglHandle for a shader.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="shader_is_compiled"
              c:identifier="cogl_shader_is_compiled"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-shader.h"
           line="360">Retrieves whether a shader #CoglHandle has been compiled</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-shader.h"
                       line="371"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-shader.h"
             line="366">%TRUE if the shader object has sucessfully be compiled</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="362">#CoglHandle for a shader.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="shader_ref"
              c:identifier="cogl_shader_ref"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-shader.h"
           line="257">Add an extra reference to a shader.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-shader.h"
                       line="268"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-shader.h"
             line="263">@handle</doc>
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="259">A #CoglHandle to a shader.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="shader_source"
              c:identifier="cogl_shader_source"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-shader.h"
           line="297">Replaces the current source associated with a shader with a new
one.

Please see &lt;link
linkend="cogl-Shaders-and-Programmable-Pipeline.description"&gt;above&lt;/link&gt;
for a description of the recommended format for the shader code.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-shader.h"
                       line="312"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="shader" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="299">#CoglHandle for a shader.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="300">Shader source.</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="shader_unref"
              c:identifier="cogl_shader_unref"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-shader.h"
           line="270">Removes a reference to a shader. If it was the last reference the
shader object will be destroyed.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-shader.h"
                       line="281"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-shader.h"
               line="272">A #CoglHandle to a shader.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="texture_error_quark"
              c:identifier="cogl_texture_error_quark"
              moved-to="Texture.error_quark">
      <source-position filename="../cogl/cogl/cogl-texture.h" line="129"/>
      <return-value transfer-ownership="none">
        <type name="guint32" c:type="uint32_t"/>
      </return-value>
    </function>
    <function name="texture_new_from_bitmap"
              c:identifier="cogl_texture_new_from_bitmap"
              moved-to="Texture.new_from_bitmap"
              version="1.0"
              deprecated="1"
              deprecated-version="1.18">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
           line="166">Creates a #CoglTexture from a #CoglBitmap.</doc>
      <doc-deprecated xml:space="preserve">Use specific constructors such as
                  cogl_texture_2d_new_from_bitmap()</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                       line="184"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
             line="175">A newly created #CoglTexture or
              %NULL on failure</doc>
        <type name="Texture" c:type="CoglTexture*"/>
      </return-value>
      <parameters>
        <parameter name="bitmap" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
               line="168">A #CoglBitmap pointer</doc>
          <type name="Bitmap" c:type="CoglBitmap*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
               line="169">Optional flags for the texture, or %COGL_TEXTURE_NONE</doc>
          <type name="TextureFlags" c:type="CoglTextureFlags"/>
        </parameter>
        <parameter name="internal_format" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
               line="170">the #CoglPixelFormat to use for the GPU storage of the
texture</doc>
          <type name="PixelFormat" c:type="CoglPixelFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="texture_new_from_data"
              c:identifier="cogl_texture_new_from_data"
              moved-to="Texture.new_from_data"
              version="0.8"
              deprecated="1"
              deprecated-version="1.18">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
           line="91">Creates a new #CoglTexture based on data residing in memory.</doc>
      <doc-deprecated xml:space="preserve">Use specific constructors such as
                  cogl_texture_2d_new_from_data()</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                       line="120"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
             line="111">A newly created #CoglTexture or
              %NULL on failure</doc>
        <type name="Texture" c:type="CoglTexture*"/>
      </return-value>
      <parameters>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
               line="93">width of texture in pixels</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
               line="94">height of texture in pixels</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
               line="95">Optional flags for the texture, or %COGL_TEXTURE_NONE</doc>
          <type name="TextureFlags" c:type="CoglTextureFlags"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
               line="96">the #CoglPixelFormat the buffer is stored in in RAM</doc>
          <type name="PixelFormat" c:type="CoglPixelFormat"/>
        </parameter>
        <parameter name="internal_format" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
               line="97">the #CoglPixelFormat that will be used for storing
   the buffer on the GPU. If COGL_PIXEL_FORMAT_ANY is given then a
   premultiplied format similar to the format of the source data will
   be used. The default blending equations of Cogl expect premultiplied
   color data; the main use of passing a non-premultiplied format here
   is if you have non-premultiplied source data and are going to adjust
   the blend mode (see cogl_material_set_blend()) or use the data for
   something other than straight blending.</doc>
          <type name="PixelFormat" c:type="CoglPixelFormat"/>
        </parameter>
        <parameter name="rowstride" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
               line="105">the memory offset in bytes between the starts of
   scanlines in @data</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
               line="107">pointer the memory region where the source buffer resides</doc>
          <type name="guint8" c:type="const uint8_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="texture_new_from_file"
              c:identifier="cogl_texture_new_from_file"
              moved-to="Texture.new_from_file"
              version="0.8"
              deprecated="1"
              deprecated-version="1.18"
              throws="1">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
           line="61">Creates a #CoglTexture from an image file.</doc>
      <doc-deprecated xml:space="preserve">Use specific constructors such as
                  cogl_texture_2d_new_from_file()</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                       line="86"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
             line="77">A newly created #CoglTexture or
              %NULL on failure</doc>
        <type name="Texture" c:type="CoglTexture*"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
               line="63">the file to load</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
               line="64">Optional flags for the texture, or %COGL_TEXTURE_NONE</doc>
          <type name="TextureFlags" c:type="CoglTextureFlags"/>
        </parameter>
        <parameter name="internal_format" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
               line="65">the #CoglPixelFormat to use for the GPU storage of the
   texture. If %COGL_PIXEL_FORMAT_ANY is given then a premultiplied
   format similar to the format of the source data will be used. The
   default blending equations of Cogl expect premultiplied color data;
   the main use of passing a non-premultiplied format here is if you
   have non-premultiplied source data and are going to adjust the blend
   mode (see cogl_material_set_blend()) or use the data for something
   other than straight blending.</doc>
          <type name="PixelFormat" c:type="CoglPixelFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="texture_new_from_foreign"
              c:identifier="cogl_texture_new_from_foreign"
              moved-to="Texture.new_from_foreign"
              version="0.8"
              deprecated="1"
              deprecated-version="1.18">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
           line="128">Creates a #CoglTexture based on an existing OpenGL texture; the
width, height and format are passed along since it is not always
possible to query these from OpenGL.

The waste arguments allow you to create a Cogl texture that maps to
a region smaller than the real OpenGL texture. For instance if your
hardware only supports power-of-two textures you may load a
non-power-of-two image into a larger power-of-two texture and use
the waste arguments to tell Cogl which region should be mapped to
the texture coordinate range [0:1].</doc>
      <doc-deprecated xml:space="preserve">Use specific constructors such as
                  cogl_texture_2d_new_from_foreign()</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                       line="158"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
             line="149">A newly created #CoglTexture or
              %NULL on failure</doc>
        <type name="Texture" c:type="CoglTexture*"/>
      </return-value>
      <parameters>
        <parameter name="gl_handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
               line="130">opengl handle of foreign texture.</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
        <parameter name="gl_target" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
               line="131">opengl target type of foreign texture</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
               line="132">width of foreign texture</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
               line="133">height of foreign texture.</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
        <parameter name="x_pot_waste" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
               line="134">horizontal waste on the right hand edge of the texture.</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
        <parameter name="y_pot_waste" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
               line="135">vertical waste on the bottom edge of the texture.</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
               line="136">format of the foreign texture.</doc>
          <type name="PixelFormat" c:type="CoglPixelFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="texture_new_with_size"
              c:identifier="cogl_texture_new_with_size"
              moved-to="Texture.new_with_size"
              version="0.8"
              deprecated="1"
              deprecated-version="1.18">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
           line="38">Creates a new #CoglTexture with the specified dimensions and pixel format.</doc>
      <doc-deprecated xml:space="preserve">Use specific constructors such as
                  cogl_texture_2d_new_with_size()</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
                       line="56"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
             line="48">A newly created #CoglTexture or %NULL on failure</doc>
        <type name="Texture" c:type="CoglTexture*"/>
      </return-value>
      <parameters>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
               line="40">width of texture in pixels.</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
               line="41">height of texture in pixels.</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
               line="42">Optional flags for the texture, or %COGL_TEXTURE_NONE</doc>
          <type name="TextureFlags" c:type="CoglTextureFlags"/>
        </parameter>
        <parameter name="internal_format" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-auto-texture.h"
               line="43">the #CoglPixelFormat to use for the GPU storage of the
   texture.</doc>
          <type name="PixelFormat" c:type="CoglPixelFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="transform"
              c:identifier="cogl_transform"
              version="1.4"
              deprecated="1"
              deprecated-version="1.10">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="359">Multiplies the current model-view matrix by the given matrix.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_transform() instead</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="370"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="matrix" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="361">the matrix to multiply with the current model-view</doc>
          <type name="Matrix" c:type="const CoglMatrix*"/>
        </parameter>
      </parameters>
    </function>
    <function name="translate"
              c:identifier="cogl_translate"
              deprecated="1"
              deprecated-version="1.10">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="320">Multiplies the current model-view matrix by one that translates the
model along all three axes according to the given values.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_translate() instead</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="333"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="322">Distance to translate along the x-axis</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="323">Distance to translate along the y-axis</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="z" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="324">Distance to translate along the z-axis</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_add"
              c:identifier="cogl_vertex_buffer_add"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
           line="112">Adds an attribute to a buffer, or replaces a previously added
attribute with the same name.

You either can use one of the built-in names such as "gl_Vertex", or
"gl_MultiTexCoord0" to add standard attributes, like positions, colors
and normals, or you can add custom attributes for use in shaders.

The number of vertices declared when calling cogl_vertex_buffer_new()
determines how many attribute values will be read from the supplied
@pointer.

The data for your attribute isn't copied anywhere until you call
cogl_vertex_buffer_submit(), or issue a draw call which automatically
submits pending attribute changes. so the supplied pointer must remain
valid until then. If you are updating an existing attribute (done by
re-adding it) then you still need to re-call cogl_vertex_buffer_submit()
to commit the changes to the GPU. Be carefull to minimize the number
of calls to cogl_vertex_buffer_submit(), though.

&lt;note&gt;If you are interleving attributes it is assumed that each interleaved
attribute starts no farther than +- stride bytes from the other attributes
it is interleved with. I.e. this is ok:
&lt;programlisting&gt;
|-0-0-0-0-0-0-0-0-0-0|
&lt;/programlisting&gt;
This is not ok:
&lt;programlisting&gt;
|- - - - -0-0-0-0-0-0 0 0 0 0|
&lt;/programlisting&gt;
(Though you can have multiple groups of interleved attributes)&lt;/note&gt;</doc>
      <doc-deprecated xml:space="preserve">Use the #CoglPrimitive api instead</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
                       line="179"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
               line="114">A vertex buffer handle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="attribute_name" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
               line="115">The name of your attribute. It should be a valid GLSL
  variable name and standard attribute types must use one of following
  built-in names: (Note: they correspond to the built-in names of GLSL)
  &lt;itemizedlist&gt;
    &lt;listitem&gt;"gl_Color"&lt;/listitem&gt;
    &lt;listitem&gt;"gl_Normal"&lt;/listitem&gt;
    &lt;listitem&gt;"gl_MultiTexCoord0, gl_MultiTexCoord1, ..."&lt;/listitem&gt;
    &lt;listitem&gt;"gl_Vertex"&lt;/listitem&gt;
  &lt;/itemizedlist&gt;
  To support adding multiple variations of the same attribute the name
  can have a detail component, E.g. "gl_Color::active" or
  "gl_Color::inactive"</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="n_components" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
               line="127">The number of components per attribute and must be 1, 2,
  3 or 4</doc>
          <type name="guint8" c:type="uint8_t"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
               line="129">a #CoglAttributeType specifying the data type of each component.</doc>
          <type name="AttributeType" c:type="CoglAttributeType"/>
        </parameter>
        <parameter name="normalized" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
               line="130">If %TRUE, this specifies that values stored in an integer
  format should be mapped into the range [-1.0, 1.0] or [0.0, 1.0]
  for unsigned values. If %FALSE they are converted to floats
  directly.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="stride" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
               line="134">This specifies the number of bytes from the start of one attribute
  value to the start of the next value (for the same attribute). So, for
  example, with a position interleved with color like this:
  XYRGBAXYRGBAXYRGBA, then if each letter represents a byte, the
  stride for both attributes is 6. The special value 0 means the
  values are stored sequentially in memory.</doc>
          <type name="guint16" c:type="uint16_t"/>
        </parameter>
        <parameter name="pointer"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
               line="140">This addresses the first attribute in the vertex array. This
  must remain valid until you either call cogl_vertex_buffer_submit() or
  issue a draw call.</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_delete"
              c:identifier="cogl_vertex_buffer_delete"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
           line="187">Deletes an attribute from a buffer. You will need to call
cogl_vertex_buffer_submit() or issue a draw call to commit this
change to the GPU.</doc>
      <doc-deprecated xml:space="preserve">Use the #CoglPrimitive api instead</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
                       line="200"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
               line="189">A vertex buffer handle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="attribute_name" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
               line="190">The name of a previously added attribute</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_disable"
              c:identifier="cogl_vertex_buffer_disable"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
           line="221">Disables a previosuly added attribute.

Since it can be costly to add and remove new attributes to buffers; to make
individual buffers more reuseable it is possible to enable and disable
attributes before using a buffer for drawing.

You don't need to call cogl_vertex_buffer_submit() after using this
function.</doc>
      <doc-deprecated xml:space="preserve">Use the #CoglPrimitive api instead</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
                       line="239"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
               line="223">A vertex buffer handle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="attribute_name" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
               line="224">The name of the attribute you want to disable</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_draw"
              c:identifier="cogl_vertex_buffer_draw"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
           line="262">Allows you to draw geometry using all or a subset of the
vertices in a vertex buffer.

Any un-submitted attribute changes are automatically submitted before
drawing.</doc>
      <doc-deprecated xml:space="preserve">Use the #CoglPrimitive api instead</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
                       line="280"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
               line="264">A vertex buffer handle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="mode" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
               line="265">A #CoglVerticesMode specifying how the vertices should be
  interpreted.</doc>
          <type name="VerticesMode" c:type="CoglVerticesMode"/>
        </parameter>
        <parameter name="first" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
               line="267">Specifies the index of the first vertex you want to draw with</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
               line="268">Specifies the number of vertices you want to draw.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_draw_elements"
              c:identifier="cogl_vertex_buffer_draw_elements"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
           line="323">This function lets you use an array of indices to specify the vertices
within your vertex buffer that you want to draw. The indices themselves
are created by calling cogl_vertex_buffer_indices_new ()

Any un-submitted attribute changes are automatically submitted before
drawing.</doc>
      <doc-deprecated xml:space="preserve">Use the #CoglPrimitive api instead</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
                       line="346"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
               line="325">A vertex buffer handle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="mode" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
               line="326">A #CoglVerticesMode specifying how the vertices should be
   interpreted.</doc>
          <type name="VerticesMode" c:type="CoglVerticesMode"/>
        </parameter>
        <parameter name="indices" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
               line="328">A CoglHandle for a set of indices allocated via
   cogl_vertex_buffer_indices_new ()</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="min_index" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
               line="330">Specifies the minimum vertex index contained in indices</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="max_index" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
               line="331">Specifies the maximum vertex index contained in indices</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="indices_offset" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
               line="332">An offset into named indices. The offset marks the first
   index to use for drawing.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
               line="334">Specifies the number of vertices you want to draw.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_enable"
              c:identifier="cogl_vertex_buffer_enable"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
           line="242">Enables a previosuly disabled attribute.

Since it can be costly to add and remove new attributes to buffers; to make
individual buffers more reuseable it is possible to enable and disable
attributes before using a buffer for drawing.

You don't need to call cogl_vertex_buffer_submit() after using this function</doc>
      <doc-deprecated xml:space="preserve">Use the #CoglPrimitive api instead</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
                       line="259"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
               line="244">A vertex buffer handle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="attribute_name" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
               line="245">The name of the attribute you want to enable</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_get_n_vertices"
              c:identifier="cogl_vertex_buffer_get_n_vertices"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
           line="99">Retrieves the number of vertices that @handle represents</doc>
      <doc-deprecated xml:space="preserve">Use the #CoglPrimitive api instead</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
                       line="110"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
             line="105">the number of vertices</doc>
        <type name="guint" c:type="unsigned int"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
               line="101">A vertex buffer handle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_indices_get_for_quads"
              c:identifier="cogl_vertex_buffer_indices_get_for_quads"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
           line="380">Creates a vertex buffer containing the indices needed to draw pairs
of triangles from a list of vertices grouped as quads. There will
be at least @n_indices entries in the buffer (but there may be
more).

The indices will follow this pattern:

0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7 ... etc

For example, if you submit vertices for a quad like like that shown
in &lt;xref linkend="quad-indices-order"/&gt; then you can request 6
indices to render two triangles like those shown in &lt;xref
linkend="quad-indices-triangles"/&gt;.

&lt;figure id="quad-indices-order"&gt;
  &lt;title&gt;Example of vertices submitted to form a quad&lt;/title&gt;
  &lt;graphic fileref="quad-indices-order.png" format="PNG"/&gt;
&lt;/figure&gt;

&lt;figure id="quad-indices-triangles"&gt;
  &lt;title&gt;Illustration of the triangle indices that will be generated&lt;/title&gt;
  &lt;graphic fileref="quad-indices-triangles.png" format="PNG"/&gt;
&lt;/figure&gt;</doc>
      <doc-deprecated xml:space="preserve">Use the #CoglPrimitive api instead</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
                       line="415"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
             line="408">A %CoglHandle containing the indices. The handled is
owned by Cogl and should not be modified or unref'd.</doc>
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="n_indices" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
               line="382">the number of indices in the vertex buffer.</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_indices_get_type"
              c:identifier="cogl_vertex_buffer_indices_get_type"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
           line="309">Queries back the data type used for the given indices</doc>
      <doc-deprecated xml:space="preserve">Use the #CoglPrimitive api instead</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
                       line="321"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
             line="315">The CoglIndicesType used</doc>
        <type name="IndicesType" c:type="CoglIndicesType"/>
      </return-value>
      <parameters>
        <parameter name="indices" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
               line="311">An indices handle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_indices_new"
              c:identifier="cogl_vertex_buffer_indices_new"
              introspectable="0"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
           line="285">Depending on how much geometry you are submitting it can be worthwhile
optimizing the number of redundant vertices you submit. Using an index
array allows you to reference vertices multiple times, for example
during triangle strips.</doc>
      <doc-deprecated xml:space="preserve">Use the #CoglPrimitive api instead</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
                       line="305"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
             line="298">A CoglHandle for the indices which you can pass to
  cogl_vertex_buffer_draw_elements().</doc>
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="indices_type" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
               line="287">a #CoglIndicesType specifying the data type used for
   the indices.</doc>
          <type name="IndicesType" c:type="CoglIndicesType"/>
        </parameter>
        <parameter name="indices_array" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
               line="289">Specifies the address of
  your array of indices</doc>
          <array length="2" zero-terminated="0" c:type="void*">
            <type name="gpointer" c:type="void"/>
          </array>
        </parameter>
        <parameter name="indices_len" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
               line="291">The number of indices in indices_array</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_new"
              c:identifier="cogl_vertex_buffer_new"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
           line="86">Creates a new vertex buffer that you can use to add attributes.</doc>
      <doc-deprecated xml:space="preserve">Use the #CoglPrimitive api instead</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
                       line="97"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
             line="92">a new #CoglHandle</doc>
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="n_vertices" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
               line="88">The number of vertices that your attributes will correspond to.</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_ref"
              c:identifier="cogl_vertex_buffer_ref"
              deprecated="1"
              deprecated-version="1.2">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
           line="354">Increment the reference count for a vertex buffer</doc>
      <doc-deprecated xml:space="preserve">Use cogl_object_ref() instead</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
                       line="366"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
             line="360">the @handle.</doc>
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
               line="356">a @CoglHandle.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_submit"
              c:identifier="cogl_vertex_buffer_submit"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
           line="203">Submits all the user added attributes to the GPU; once submitted, the
attributes can be used for drawing.

You should aim to minimize calls to this function since it implies
validating your data; it potentially incurs a transport cost (especially if
you are using GLX indirect rendering) and potentially a format conversion
cost if the GPU doesn't natively support any of the given attribute formats.</doc>
      <doc-deprecated xml:space="preserve">Use the #CoglPrimitive api instead</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
                       line="219"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
               line="205">A vertex buffer handle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_unref"
              c:identifier="cogl_vertex_buffer_unref"
              deprecated="1"
              deprecated-version="1.2">
      <doc xml:space="preserve"
           filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
           line="368">Decrement the reference count for a vertex buffer</doc>
      <doc-deprecated xml:space="preserve">Use cogl_object_unref() instead</doc-deprecated>
      <source-position filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
                       line="378"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/deprecated/cogl-vertex-buffer.h"
               line="370">a @CoglHandle.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="viewport"
              c:identifier="cogl_viewport"
              version="0.8.2"
              deprecated="1"
              deprecated-version="1.8">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl1-context.h"
           line="246">Replace the current viewport with the given values.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_set_viewport instead</doc-deprecated>
      <source-position filename="../cogl/cogl/cogl1-context.h" line="258"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="248">Width of the viewport</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl1-context.h"
               line="249">Height of the viewport</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
      </parameters>
    </function>
    <function name="x11_onscreen_get_visual_xid"
              c:identifier="cogl_x11_onscreen_get_visual_xid">
      <source-position filename="../cogl/cogl/cogl-onscreen.h" line="162"/>
      <return-value transfer-ownership="none">
        <type name="guint32" c:type="uint32_t"/>
      </return-value>
      <parameters>
        <parameter name="onscreen" transfer-ownership="none">
          <type name="Onscreen" c:type="CoglOnscreen*"/>
        </parameter>
      </parameters>
    </function>
    <function name="x11_onscreen_get_window_xid"
              c:identifier="cogl_x11_onscreen_get_window_xid"
              version="1.10"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-onscreen.h"
           line="139">Assuming you know the given @onscreen framebuffer is based on an x11 window
this queries the XID of that window. If
cogl_x11_onscreen_set_foreign_window_xid() was previously called then it
will return that same XID otherwise it will be the XID of a window Cogl
created internally. If the window has not been allocated yet and a foreign
xid has not been set then it's undefined what value will be returned.

It's undefined what this function does if called when not using an x11 based
renderer.</doc>
      <source-position filename="../cogl/cogl/cogl-onscreen.h" line="157"/>
      <return-value transfer-ownership="none">
        <type name="guint32" c:type="uint32_t"/>
      </return-value>
      <parameters>
        <parameter name="onscreen" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-onscreen.h"
               line="141">A #CoglOnscreen framebuffer</doc>
          <type name="Onscreen" c:type="CoglOnscreen*"/>
        </parameter>
      </parameters>
    </function>
    <function name="x11_onscreen_set_foreign_window_xid"
              c:identifier="cogl_x11_onscreen_set_foreign_window_xid"
              version="2.0"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-onscreen.h"
           line="82">Ideally we would recommend that you let Cogl be responsible for
creating any X window required to back an onscreen framebuffer but
if you really need to target a window created manually this
function can be called before @onscreen has been allocated to set a
foreign XID for your existing X window.

Since Cogl needs, for example, to track changes to the size of an X
window it requires that certain events be selected for via the core
X protocol. This requirement may also be changed asynchronously so
you must pass in an @update callback to inform you of Cogl's
required event mask.

For example if you are using Xlib you could use this API roughly
as follows:
[{
static void
my_update_cogl_x11_event_mask (CoglOnscreen *onscreen,
                               uint32_t event_mask,
                               void *user_data)
{
  XSetWindowAttributes attrs;
  MyData *data = user_data;
  attrs.event_mask = event_mask | data-&gt;my_event_mask;
  XChangeWindowAttributes (data-&gt;xdpy,
                           data-&gt;xwin,
                           CWEventMask,
                           &amp;attrs);
}

{
  *snip*
  cogl_x11_onscreen_set_foreign_window_xid (onscreen,
                                            data-&gt;xwin,
                                            my_update_cogl_x11_event_mask,
                                            data);
  *snip*
}
}]</doc>
      <source-position filename="../cogl/cogl/cogl-onscreen.h" line="134"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="onscreen" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-onscreen.h"
               line="84">The unallocated framebuffer to associated with an X
           window.</doc>
          <type name="Onscreen" c:type="CoglOnscreen*"/>
        </parameter>
        <parameter name="xid" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-onscreen.h"
               line="86">The XID of an existing X window</doc>
          <type name="guint32" c:type="uint32_t"/>
        </parameter>
        <parameter name="update"
                   transfer-ownership="none"
                   scope="async"
                   closure="3">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-onscreen.h"
               line="87">A callback that notifies of updates to what Cogl
         requires to be in the core X protocol event mask.</doc>
          <type name="OnscreenX11MaskCallback"
                c:type="CoglOnscreenX11MaskCallback"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-onscreen.h"
               line="89">user data passed to @update</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xlib_renderer_add_filter"
              c:identifier="cogl_xlib_renderer_add_filter"
              introspectable="0">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-xlib-renderer.h"
           line="92">Adds a callback function that will receive all native events. The
function can stop further processing of the event by return
%COGL_FILTER_REMOVE.</doc>
      <source-position filename="../cogl/cogl/cogl-xlib-renderer.h"
                       line="103"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-xlib-renderer.h"
               line="94">a #CoglRenderer</doc>
          <type c:type="CoglRenderer*"/>
        </parameter>
        <parameter name="func" transfer-ownership="none" closure="2">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-xlib-renderer.h"
               line="95">the callback function</doc>
          <type name="XlibFilterFunc" c:type="CoglXlibFilterFunc"/>
        </parameter>
        <parameter name="data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-xlib-renderer.h"
               line="96">user data passed to @func when called</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xlib_renderer_get_display"
              c:identifier="cogl_xlib_renderer_get_display"
              introspectable="0">
      <source-position filename="../cogl/cogl/cogl-xlib-renderer.h"
                       line="204"/>
      <return-value>
        <type c:type="Display*"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <type c:type="CoglRenderer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xlib_renderer_get_foreign_display"
              c:identifier="cogl_xlib_renderer_get_foreign_display"
              introspectable="0">
      <source-position filename="../cogl/cogl/cogl-xlib-renderer.h"
                       line="130"/>
      <return-value>
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-xlib-renderer.h"
             line="125">the foreign Xlib display that will be used by any Xlib based
winsys backend. The display needs to be set with
cogl_xlib_renderer_set_foreign_display() before this function is called.</doc>
        <type c:type="Display*"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-xlib-renderer.h"
               line="123">a #CoglRenderer</doc>
          <type c:type="CoglRenderer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xlib_renderer_get_visual_info"
              c:identifier="cogl_xlib_renderer_get_visual_info"
              introspectable="0">
      <source-position filename="../cogl/cogl/cogl-xlib-renderer.h"
                       line="210"/>
      <return-value>
        <type c:type="XVisualInfo*"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <type c:type="CoglRenderer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xlib_renderer_handle_event"
              c:identifier="cogl_xlib_renderer_handle_event"
              introspectable="0">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-xlib-renderer.h"
           line="60">This function processes a single event; it can be used to hook into
external event retrieval (for example that done by Clutter or
GDK).</doc>
      <source-position filename="../cogl/cogl/cogl-xlib-renderer.h" line="76"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="../cogl/cogl/cogl-xlib-renderer.h"
             line="69">#CoglFilterReturn. %COGL_FILTER_REMOVE indicates that
Cogl has internally handled the event and the caller should do no
further processing. %COGL_FILTER_CONTINUE indicates that Cogl is
either not interested in the event, or has used the event to update
internal state without taking any exclusive action.</doc>
        <type name="FilterReturn" c:type="CoglFilterReturn"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-xlib-renderer.h"
               line="62">a #CoglRenderer</doc>
          <type c:type="CoglRenderer*"/>
        </parameter>
        <parameter name="event" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-xlib-renderer.h"
               line="63">pointer to an XEvent structure</doc>
          <type c:type="XEvent*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xlib_renderer_remove_filter"
              c:identifier="cogl_xlib_renderer_remove_filter"
              introspectable="0">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-xlib-renderer.h"
           line="107">Removes a callback that was previously added with
cogl_xlib_renderer_add_filter().</doc>
      <source-position filename="../cogl/cogl/cogl-xlib-renderer.h"
                       line="117"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-xlib-renderer.h"
               line="109">a #CoglRenderer</doc>
          <type c:type="CoglRenderer*"/>
        </parameter>
        <parameter name="func" transfer-ownership="none" closure="2">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-xlib-renderer.h"
               line="110">the callback function</doc>
          <type name="XlibFilterFunc" c:type="CoglXlibFilterFunc"/>
        </parameter>
        <parameter name="data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-xlib-renderer.h"
               line="111">user data given when the callback was installed</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xlib_renderer_request_reset_on_video_memory_purge"
              c:identifier="cogl_xlib_renderer_request_reset_on_video_memory_purge"
              introspectable="0">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-xlib-renderer.h"
           line="212">Sets whether Cogl should make use of the
NV_robustness_video_memory_purge extension, if exposed by the
driver, by initializing the GLX context appropriately.

The extension is only useful when running on certain versions of
the NVIDIA driver. Quoting from the spec:

"The NVIDIA OpenGL driver architecture on Linux has a limitation:
 resources located in video memory are not persistent across certain
 events. VT switches, suspend/resume events, and mode switching
 events may erase the contents of video memory. Any resource that
 is located exclusively in video memory, such as framebuffer objects
 (FBOs), will be lost."

"This extension provides a way for applications to discover when video
 memory content has been lost, so that the application can re-populate
 the video memory content as necessary."

"Any driver that exposes this extension is a driver that considers
 video memory to be volatile. Once the driver stack has been
 improved, the extension will no longer be exposed."

cogl_get_graphics_reset_status() needs to be called at least once
every frame to find out if video memory was purged.

Note that this doesn't cause Cogl to enable robust buffer access
but other context reset errors may still happen and be reported via
cogl_get_graphics_reset_status() if external factors cause the
driver to trigger them.

This defaults to %FALSE and is effective only if called before
cogl_display_setup() .</doc>
      <source-position filename="../cogl/cogl/cogl-xlib-renderer.h"
                       line="251"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-xlib-renderer.h"
               line="214">a #CoglRenderer</doc>
          <type c:type="CoglRenderer*"/>
        </parameter>
        <parameter name="enable" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-xlib-renderer.h"
               line="215">The new value</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="xlib_renderer_set_event_retrieval_enabled"
              c:identifier="cogl_xlib_renderer_set_event_retrieval_enabled"
              version="1.10"
              introspectable="0"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-xlib-renderer.h"
           line="149">Sets whether Cogl should automatically retrieve events from the X
display. This defaults to %TRUE unless
cogl_xlib_renderer_set_foreign_display() is called. It can be set
to %FALSE if the application wants to handle its own event
retrieval. Note that Cogl still needs to see all of the X events to
function properly so the application should call
cogl_xlib_renderer_handle_event() for each event if it disables
automatic event retrieval.</doc>
      <source-position filename="../cogl/cogl/cogl-xlib-renderer.h"
                       line="167"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-xlib-renderer.h"
               line="151">a #CoglRenderer</doc>
          <type c:type="CoglRenderer*"/>
        </parameter>
        <parameter name="enable" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-xlib-renderer.h"
               line="152">The new value</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="xlib_renderer_set_foreign_display"
              c:identifier="cogl_xlib_renderer_set_foreign_display"
              introspectable="0">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-xlib-renderer.h"
           line="132">Sets a foreign Xlib display that Cogl will use for and Xlib based winsys
backend.

Note that calling this function will automatically call
cogl_xlib_renderer_set_event_retrieval_enabled() to disable Cogl's
event retrieval. Cogl still needs to see all of the X events so the
application should also use cogl_xlib_renderer_handle_event() if it
uses this function.</doc>
      <source-position filename="../cogl/cogl/cogl-xlib-renderer.h"
                       line="146"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-xlib-renderer.h"
               line="134">a #CoglRenderer</doc>
          <type c:type="CoglRenderer*"/>
        </parameter>
        <parameter name="display" transfer-ownership="none">
          <type c:type="Display*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xlib_renderer_set_threaded_swap_wait_enabled"
              c:identifier="cogl_xlib_renderer_set_threaded_swap_wait_enabled"
              introspectable="0"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="../cogl/cogl/cogl-xlib-renderer.h"
           line="170">Sets whether Cogl is allowed to use a separate threaded to wait for the
completion of glXSwapBuffers() and call the frame callback for the
corresponding #CoglOnscreen. This is a way of emulating the
INTEL_swap_event extension, and will only ever be used if
INTEL_swap_event is not present; it will also only be used for
specific white-listed drivers that are known to work correctly with
multiple contexts sharing state between threads.

The advantage of enabling this is that it will allow your main loop
to do other work while waiting for the system to be ready to draw
the next frame, instead of blocking in glXSwapBuffers(). A disadvantage
is that the driver will be prevented from buffering up multiple frames
even if it thinks that it would be advantageous. In general, this
will work best for something like a system compositor that is doing
simple drawing but handling lots of other complex tasks.

If you enable this, you must call XInitThreads() before any other
X11 calls in your program. (See the documentation for XInitThreads())</doc>
      <source-position filename="../cogl/cogl/cogl-xlib-renderer.h"
                       line="197"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-xlib-renderer.h"
               line="172">a #CoglRenderer</doc>
          <type c:type="CoglRenderer*"/>
        </parameter>
        <parameter name="enable" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="../cogl/cogl/cogl-xlib-renderer.h"
               line="173">The new value</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
